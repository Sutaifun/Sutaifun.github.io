<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
    <link rel="icon" href="/images/favicon.ico">
  
  <title>Styphon&#39;s Site</title>
  
<link rel="stylesheet" href="/css/styles.css">

  
<script src="/lib/jquery.js"></script>

  
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">

  
<script src="/js/common.js"></script>

  
<script src="/lib/bootstrap/js/bootstrap.js"></script>

  
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Styphon's Site" type="application/atom+xml">
</head>

  <body>
    <header class="header">
  <div class="color-bar">
    <ul>
      <li class="bar1"></li>
      <li class="bar2"></li>
      <li class="bar3"></li>
      <li class="bar4"></li>
      <li class="bar5"></li>
      <li class="bar6"></li>
    </ul>
  </div>
  <div class="header-wrapper">
    <div class="blog-title">
      
        <img class="logo" src="/images/logo.png" alt="logo">
      
      <a href="/" class="title">Styphon&#39;s Site</a>
    </div>
    <nav class="navbar navbar-menu">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" id="nav-btn" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>
      </div>
        <ul class="menu menu-pc">
          
            <li class="menu-item">
              <a href="/" class="menu-item-link"><i class="fa fa-home"></i><span>首页</span></a>
            </li>
          
            <li class="menu-item">
              <a href="/tags/" class="menu-item-link"><i class="fa fa-tags"></i><span>标签</span></a>
            </li>
          
            <li class="menu-item">
              <a href="/archives/" class="menu-item-link"><i class="fa fa-file"></i><span>归档</span></a>
            </li>
          
            <li class="menu-item">
              <a target="_blank" rel="noopener" href="https://github.com/Sutaifun" class="menu-item-link"><i class="fa fa-github"></i><span>github</span></a>
            </li>
          
        </ul>
    </nav>
  </div>
</header>
<div class="collapse nav-collapse" style="position:fixed;top:59px;" id="bs-example-navbar-collapse-1">
  <ul class="menu menu-mobile" style="list-style:none">
    
      <li class="menu-item">
        <a href="/" class="menu-item-link"><i class="fa fa-home"></i><span>首页</span></a>
      </li>
    
      <li class="menu-item">
        <a href="/tags/" class="menu-item-link"><i class="fa fa-tags"></i><span>标签</span></a>
      </li>
    
      <li class="menu-item">
        <a href="/archives/" class="menu-item-link"><i class="fa fa-file"></i><span>归档</span></a>
      </li>
    
      <li class="menu-item">
        <a target="_blank" rel="noopener" href="https://github.com/Sutaifun" class="menu-item-link"><i class="fa fa-github"></i><span>github</span></a>
      </li>
    
  </ul>
</div>

    <main class="main">
      <div class="content">
        
  <article class="post">
    <div class="post-title">
      <h2 class="title">2019CCBSummary#MT</h2>
       
        <p>python</p>
      
    </div>
     <div class="post-meta">
      <span class="post-time">2020-04-26</span>
    </div>
    <div class="post-content">
      </p>
<h1 id="阶段测试问题汇总"><a href="#阶段测试问题汇总" class="headerlink" title="阶段测试问题汇总"></a>阶段测试问题汇总</h1><hr>
<h2 id="A-助教机器人"><a href="#A-助教机器人" class="headerlink" title="A.助教机器人"></a><font color=#0033FF>A.助教机器人</font></h2><p>这道题可能有些同学是复制的PDF文件上的句子，导致<code>fi</code>这两个字符被复制成了<code>ﬁ</code>这个奇怪的字符，从而 <strong><font color=#FF0000>WA</font></strong> 掉，着实可惜。<br>在复制文本时，优先复制代码框内部的文本。  </p>
<h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">s = input()
if s == &#39;Why was I right on my machine, but WA on OJ?&#39;:
    print(&#39;OJ must be broken!&#39;)
elif s == &#39;Why did my code work out the wrong result?&#39;:
    print(&#39;Output intermediate variables during running, and find error!&#39;)
elif s == &#39;I do not know what data my code would go wrong on!&#39;:
    print(&#39;Here may be the data you need!&#39;)
else:
    print(&#39;Let me have a look.&#39;)
</code></pre>
<p>具体代码部分不需要解释了。如果还有问题请查阅第二次上机实验相关内容。  </p>
<hr>
<h2 id="B-自闭程度"><a href="#B-自闭程度" class="headerlink" title="B.自闭程度"></a><font color=#0033FF>B.自闭程度</font></h2><p>同样也是复制的问题，题面上的数字是经过LaTeX渲染后的，里面的字符不一定是我们常用的字符。直接从题面复制的话，会被那个负号坑到。<br>还是上面那句话，优先复制代码框内部的文本。  </p>
<h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">n, m = map(int, input().split())
mark = [0] * n                              # 默认每一道题都没有通过
for _ in range(m):
    a, b = map(int, input().split())
    mark[a-1] = b                           # 直接更新题目状况
s = sum(mark)
if s == 0:
    print(&#39;998244353&#39;)
elif s == n:
    print(&#39;-998244353&#39;)
else:
    print(50*n-150*s)
</code></pre>
<p>需要注意的是题目中的前提条件，一道题目在AC后不会再有新的提交记录，所以我们可以直接覆盖更新题目的状况。  </p>
<hr>
<h2 id="C-汉诺塔栈"><a href="#C-汉诺塔栈" class="headerlink" title="C.汉诺塔栈"></a><font color=#0033FF>C.汉诺塔栈</font></h2><p>这道题目无论是直接模拟题面的描述还是将其本质问题抽象出来，都是可以完成的。<br>本质问题是冒泡排序，并且输出结果是互换位置的次数。  </p>
<h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">T = int(input())
for _ in range(T):
    lnums = list(map(int, input().split()))
    count = 0
    hanoi = [-1]                            # 防止访问越界，提前添加一个不会混淆的元素，代表汉诺塔底部
    stack = []                              # 暂存用的栈，与上面的hanoi均用列表模拟
    for plt in lnums:                       # plate，盘子（
        while hanoi[-1] != -1 and hanoi[-1] &lt; plt:
            stack.append(hanoi.pop())       # 不等于-1是指非底部
        hanoi.append(plt)                   # 放入圆盘
        while stack != []:                  # 然后把暂存区的圆盘挪回去
            hanoi.append(stack.pop())
            count += 1                      # 每挪一个都要更新计数器
    print(count)
</code></pre>
<p>这个是使用栈直接完成题面的描述，可以看出并不复杂。  </p>
<h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="lang-python">T = int(input())
for _ in range(T):
    lnums = list(map(int, input().split()))
    lenth = len(lnums)
    count = 0
    flag = True
    while flag:                             # 这里就是冒泡排序，注意我们要的是递减序列
        flag = False
        for i in range(1, lenth):
            if lnums[i] &gt; lnums[i-1]:
                lnums[i], lnums[i-1] = lnums[i-1], lnums[i]
                count += 1                  # 在冒泡排序中加入计数器即可
                flag = True
    print(count)
</code></pre>
<p>使用冒泡排序的思想。将题面转化为冒泡排序思维量不小，感兴趣的同学可以想一下为什么这道题目是冒泡排序。  </p>
<hr>
<h2 id="D-异或序列"><a href="#D-异或序列" class="headerlink" title="D.异或序列"></a><font color=#0033FF>D.异或序列</font></h2><p>本次测试最具有区分度的一道题目，拿<code>0.6</code>分也不用太失落。<br>就像高考数学全国卷必做部分最后一道题一样，这道题的前<code>0.6</code>分就好像第一小问，再往后的<code>0.2</code>分就好像第二小问，最后<code>0.2</code>分就是超难的第三小问。<br>首先再解释一下异或运算。逻辑上的异或运算的法则是<code>A xor B</code>当且仅当<code>A</code>与<code>B</code>逻辑值不同时，运算结果为<code>True</code>，否则为<code>False</code>，可以使用符号<code>⊕</code>表示。真值表如下：<br>A|B|A xor B<br>:-:|:-:|:-:|</p>
<font color=5ECCFF>True</font>|<font color=5ECCFF>True</font>|<font color=FF5E5E>False</font>
<font color=5ECCFF>True</font>|<font color=FF5E5E>False</font>|<font color=5ECCFF>True</font>
<font color=FF5E5E>False</font>|<font color=5ECCFF>True</font>|<font color=5ECCFF>True</font>
<font color=FF5E5E>False</font>|<font color=FF5E5E>False</font>|<font color=FF5E5E>False</font>  

<p>两个正整数间的按位异或则是将两个数转化为二进制，然后<code>0</code>对应<code>False</code>，<code>1</code>对应<code>True</code>，每一位进行异或运算，最后将结果转化为十进制。在<code>python</code>中，按位异或运算符是<code>^</code>，在英文输入法下使用<kbd>Shift</kbd>+<kbd>6</kbd>输入（中文输入法下会输入省略号）。<br>然后是异或运算的一些性质：  </p>
<blockquote>
<p>A xor A = 0<br>A xor 0 = A<br>A xor B = B xor A<br>A xor B = 0 iff A = B<br>A xor B = A iff B = 0<br>A xor B = C iff A xor C = B iff B xor C = A<br>(A xor B) xor C = A xor (B xor C)</p>
</blockquote>
<p>其中”iff”是”if and only if”的缩写，即“当且仅当”。<br>由于<code>python</code>程序<code>1s</code>内最多运行$10^6$次运算，所以如果想要<font color=#0033FF>AC</font>，则需要将时间复杂度优化为$O(n)$即线性。  </p>
<h4 id="正确答案（TLE-0-6）"><a href="#正确答案（TLE-0-6）" class="headerlink" title="正确答案（TLE 0.6）"></a><font color=#5ECCFF>正确答案（TLE 0.6）</font></h4><p>这里给出最终得分<code>0.6</code>的暴力解法。  </p>
<pre><code class="lang-python">def xor(L):
    ans = 0
    for i in L:
        ans ^= i                            # 等价于ans = ans ^ i
    return ans                              # 不要换了运算符就不认识了

n = int(input())
lnums = list(map(int, input().split()))
count = 0
for i in range(n):
    for j in range(i+1, n+1):               # 这里是遍历了每一个可能的区间
        if xor(lnums[i:j]) == 0:
            count += 1
print(count)
</code></pre>
<p>这个时间复杂度是$O(n^3)$，所以对于$100$以内的数据可以在<code>1s</code>内完成。<br>计算时间复杂度时，注意函数的时间复杂度。  </p>
<h4 id="优化解法（TLE-0-8）"><a href="#优化解法（TLE-0-8）" class="headerlink" title="优化解法（TLE 0.8）"></a><font color=#33EEBB>优化解法（TLE 0.8）</font></h4><p>经过部分优化之后的程序，最终得分<code>0.8</code>.</p>
<pre><code class="lang-python">n = int(input())
lnums = list(map(int, input().split()))
count = 0
for i in range(n):
    xcur = 0
    for j in range(i, n):                   # 这样避免重复运算，减少了运算量
        xcur ^= lnums[j]
        if xcur == 0:
            count += 1
print(count)
</code></pre>
<p>其实还是直接翻译题面，不过是先固定了区间左端点，然后一次性找出所有满足条件的右端点，再换下一个左端点，避免了很多重复运算。<br><del>实际上并没有用到异或运算的特殊性质。</del><br>这个算法的时间复杂度是$O(n^2)$，所以对于$1000$以内的数据可以在<code>1s</code>内完成。  </p>
<h4 id="优化解法（AC）"><a href="#优化解法（AC）" class="headerlink" title="优化解法（AC）"></a><font color=#33EEBB>优化解法（AC）</font></h4><p>能够<font color=#0033FF>AC</font>这道题的算法比较难想，我想了半个小时才想出来。要将时间复杂度优化成线性，意味着我们只能够遍历一次序列。由于异或运算良好的性质，我们的运算可以得到很大程度的简化。<br>首先，异或运算同时满足交换律和结合律，这意味着异或运算可以像加法和乘法一样随意交换次序，并且可以从表达式的任何一个地方开始运算。<br>我们将题目给出的序列记为$\left\{ a_{n} \right\}$，如果有$a_i \oplus a_{i+1}\oplus\cdots\oplus a_j=0$，则必有</p>
<script type="math/tex; mode=display">
\forall x,\quad x\oplus a_i\oplus a_{i+1}\oplus\cdots\oplus a_j = x</script><p>则有</p>
<script type="math/tex; mode=display">
a_1\oplus a_2\oplus\cdots\oplus a_j = a_1\oplus a_2\oplus\cdots\oplus a_{i-1}</script><p>所以我们只需要创建出一个序列$\left\{ b_{n} \right\}$,使得$b_i = a_1\oplus a_2 \oplus\cdots\oplus a_i$,那么有如下性质</p>
<script type="math/tex; mode=display">
\exist i,j,\quad b_i=b_j\Rightarrow a_{i+1}\oplus a_{i+2} \oplus\cdots\oplus a_j=0</script><p>为了能够找出使得$b_i=0$的序列，需要规定$b_0=0$,这样就可以将$b_i$与之对应，找到从头开始的满足条件的序列。<br>举两个例子：</p>
<blockquote>
<p>有序列<code>1 2 4 5 3 6 4</code><br>我们将$\{a_n\}$和$\{b_n\}$列出来如下<br><code>a: - 1 2 4 5 3 6 4</code><br><code>b: 0 1 3 7 2 1 7 3</code><br>可以注意到$b_1=b_5=1,b_2=b_7=3,b_3=b_6=7$<br>则在$\{a_n\}$中提取对应序列<code>2 4 5 3</code>,<code>4 5 3 6 4</code>和<code>5 3 6</code>，最终找到三个满足条件的序列</p>
<p>有序列<code>1 2 4 7 3 6 4 2</code><br><code>a: - 1 2 4 7 3 6 4 2</code><br><code>b: 0 1 3 7 0 3 5 1 3</code><br>有$b_0=b_4=0, b_1=b_7=1, b_2=b_5=b_8=3$<br>提取序列<code>1 2 4 7</code>,<code>2 4 7 3 6 4</code>,<code>4 7 3</code>,<code>6 4 2</code>,<code>4 7 3 6 4 2</code>总计五个<br>注意$b_2=b_5=b_8$贡献了$\left(2,5\right],(5,8],(2,8]$三个序列</p>
</blockquote>
<p>这样一来，问题就变得简单多了，代码也很短。  </p>
<pre><code class="lang-python">n = int(input())
lnums = list(map(int, input().split()))
l = [0] * 100010                            # 创建好足够长的序列，l[i]指数字i在bn中出现过的次数
l[0] = 1                                    # b0=0，所以预先添加一个
xcur = 0                                    # 用来记录bi的值
count = 0
for i in lnums:
    xcur ^= i                               # 计算bi
    count += l[xcur]                        # 这个值出现过几次，则可以匹配到几个新的序列
    l[xcur] += 1                            # 出现次数加一
print(count)
</code></pre>
<p>对代码的第<code>9</code>行做更详细的说明：<code>count += l[xcur]</code></p>
<blockquote>
<p><code>l[x]</code>表示的是目前为止$x$在$\{b_n\}$中出现了几次<br>这时如果再出现一次$x$，则这个$x$可以跟前面每一个$x$都形成一个序列<br>比如上面举的例子中<br><code>a: - 1 2 4 7 3 6 4 2</code><br><code>b: 0 1 3 7 0 3 5 1 3</code><br>在计算到最后一个值时,<code>x=3</code><br>而之前由于<code>3</code>出现了两次，所以<code>l[x]=2</code><br>所以最终结果加<code>2</code>，代表找到了<code>4 7 3 6 4 2</code>和<code>6 4 2</code>两个序列</p>
</blockquote>
<p>这个算法的时间复杂度是$O(n)$，所以对于$100000$以内的数据可以在<code>1s</code>内完成。  </p>
    </div>
  </article>
  <div class="post-nav">
    <div class="post-nav-next post-nav-item">
      
        <a href="/2020/04/20/2019CCBSummary-05/" rel="next" title="2019CCBSummary#05">
          <i class="fa fa-chevron-left"></i> 2019CCBSummary#05
        </a>
      
    </div>

    <span class="post-nav-divider"></span>

    <div class="post-nav-prev post-nav-item">
    
        <a href="/2020/05/03/2019CCBSummary-06/" rel="prev" title="2019CCBSummary#06">
          2019CCBSummary#06 <i class="fa fa-chevron-right"></i>
        </a>
      
    </div>
  </div>



      </div>
        <div class="footer">
  <div class="footer-wrapper">
    <div class="copyright">
      
      <span>&copy;</span>
      
      <span>2020</span>
      
      <span class="author"><i class="fa fa-user"></i>Styphon</span>
    </div>
    
      <span>由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</span>
    
    
      <span>|</span> <span>主题 - <a target="_blank" rel="noopener" href="https://github.com/littleee/corazon">Corazon</a></span>
      
        <span>v1.0.0</span>
      
    
  </div>
</div>

    </main>
  </body>
</html>
