<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
    <link rel="icon" href="/images/favicon.ico">
  
  <title>Styphon&#39;s Site</title>
  
<link rel="stylesheet" href="/css/styles.css">

  
<script src="/lib/jquery.js"></script>

  
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">

  
<script src="/js/common.js"></script>

  
<script src="/lib/bootstrap/js/bootstrap.js"></script>

  
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<meta name="generator" content="Hexo 4.2.0"></head>

  <body>
    <header class="header">
  <div class="color-bar">
    <ul>
      <li class="bar1"></li>
      <li class="bar2"></li>
      <li class="bar3"></li>
      <li class="bar4"></li>
      <li class="bar5"></li>
      <li class="bar6"></li>
    </ul>
  </div>
  <div class="header-wrapper">
    <div class="blog-title">
      
        <img class="logo" src="/images/logo.png" alt="logo">
      
      <a href="/" class="title">Styphon&#39;s Site</a>
    </div>
    <nav class="navbar navbar-menu">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" id="nav-btn" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>
      </div>
        <ul class="menu menu-pc">
          
            <li class="menu-item">
              <a href="/" class="menu-item-link"><i class="fa fa-home"></i><span>首页</span></a>
            </li>
          
            <li class="menu-item">
              <a href="/tags/" class="menu-item-link"><i class="fa fa-tags"></i><span>标签</span></a>
            </li>
          
            <li class="menu-item">
              <a href="/archives/" class="menu-item-link"><i class="fa fa-file"></i><span>归档</span></a>
            </li>
          
            <li class="menu-item">
              <a href="https://github.com/Sutaifun" target="_blank" rel="noopener" class="menu-item-link"><i class="fa fa-github"></i><span>github</span></a>
            </li>
          
        </ul>
    </nav>
  </div>
</header>
<div class="collapse nav-collapse" style="position:fixed;top:59px;" id="bs-example-navbar-collapse-1">
  <ul class="menu menu-mobile" style="list-style:none">
    
      <li class="menu-item">
        <a href="/" class="menu-item-link"><i class="fa fa-home"></i><span>首页</span></a>
      </li>
    
      <li class="menu-item">
        <a href="/tags/" class="menu-item-link"><i class="fa fa-tags"></i><span>标签</span></a>
      </li>
    
      <li class="menu-item">
        <a href="/archives/" class="menu-item-link"><i class="fa fa-file"></i><span>归档</span></a>
      </li>
    
      <li class="menu-item">
        <a href="https://github.com/Sutaifun" target="_blank" rel="noopener" class="menu-item-link"><i class="fa fa-github"></i><span>github</span></a>
      </li>
    
  </ul>
</div>

    <main class="main">
      <div class="content">
        
  <article class="post">
    <div class="post-title">
      <h2 class="title">2019CCBSummary-04</h2>
       
        <p>python</p>
      
    </div>
     <div class="post-meta">
      <span class="post-time">2020-04-13</span>
    </div>
    <div class="post-content">
      <h1 id="第四次实验问题汇总"><a href="#第四次实验问题汇总" class="headerlink" title="第四次实验问题汇总"></a>第四次实验问题汇总</h1><hr>
<p>本次试验中需要用到栈和队列这两种数据结构。为了演示自定义类的实际应用，这篇总结的A.C.E三道题均使用了<code>class Stack():</code>的自定义类来存储栈结构。现给出栈的定义。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'stackIsEmpty'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'stackIsEmpty'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.items[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="A-修电脑"><a href="#A-修电脑" class="headerlink" title="A.修电脑"></a><font color=#0033FF>A.修电脑</font></h2><p>经典的使用堆栈处理指令的题目，只需要根据输入决定入栈还是出栈即可。<br>需要注意的是，题目中并没有说指令只有一个字母！所以逐字符读取和使用了<code>.isalpha()</code>的都是思路跑偏了，实际上不复杂。  </p>
<h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">commands = Stack()                              <span class="comment"># 实例化</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    com = input()</span><br><span class="line">    <span class="keyword">if</span> com == <span class="string">'Ctrl+Z'</span>:                         <span class="comment"># 判断指令是否为撤销</span></span><br><span class="line">        commands.pop()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        commands.push(com)</span><br><span class="line">print(<span class="string">"/"</span>.join(commands.items))                 <span class="comment"># 使用self.items可以直接访问items对象</span></span><br><span class="line"><span class="comment"># 最后输出时，可以直接访问类中创建的列表，也可以逐一进行pop操作后逆序输出。</span></span><br></pre></td></tr></table></figure>
<p><code>.join()</code>是非常实用的方法，希望大家都可以掌握。  </p>
<hr>
<h2 id="B-老千层饼"><a href="#B-老千层饼" class="headerlink" title="B.老千层饼"></a><font color=#0033FF>B.老千层饼</font></h2><p>题目的本意是使用队列来从小到大存储“千层饼”。有的同学在生成新“千层饼”并传入的时候没有将已经用过的千层饼删除，这样有两个问题。其一是如果是删除后再填进去的话，会有很多的重复；第二是即便没有重复，当<code>n</code>值很大的时候，列表会变得非常长，这样在访问靠后的元素的时候会非常浪费时间，从而导致<font color=#FF0000>TLE</font>.<br>有的同学在按数位依次递减的时候，减到了0以下，产生了<code>2100-10</code>这样的奇怪输出。  </p>
<h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><p>暴力解法，注意不优化的话会<font color=#FF0000>TLE</font>，需要一定程度的优化。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span>&lt;=n&lt;=<span class="number">12</span>:</span><br><span class="line">    print(n)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    n -= <span class="number">12</span></span><br><span class="line">    i = <span class="number">20</span></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> n:                                    <span class="comment"># 这里写成 while n!=0: 更容易理解</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            i += <span class="number">9</span></span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        s = str(i)</span><br><span class="line">        <span class="keyword">if</span> ord(s[<span class="number">-1</span>])-ord(s[<span class="number">-2</span>]) == <span class="number">1</span>:          <span class="comment"># 末两位递增，可以一次排除掉8个非千层饼</span></span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):               <span class="comment"># 对每相邻的两位进行判断</span></span><br><span class="line">            <span class="keyword">if</span> abs(ord(s[j])-ord(s[j+<span class="number">1</span>])) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:                                   <span class="comment"># 找到一个千层饼，n-1</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>不难看出，如果一个“千层饼”是以“67”这种严格增序列结尾的，那么下一个“千层饼”一定是+9之后的产物，这样可以优化枚举的过程，从而在规定时间内完成输出。  </p>
<h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)]                <span class="comment"># 模拟队列</span></span><br><span class="line"><span class="keyword">while</span> n:</span><br><span class="line">    a = nums.pop(<span class="number">0</span>)</span><br><span class="line">    d = a % <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> d == <span class="number">0</span>:                                  <span class="comment"># 通过末尾的数字判断添加的数</span></span><br><span class="line">        nums.append(<span class="number">10</span>*a)</span><br><span class="line">        nums.append(<span class="number">10</span>*a+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> d == <span class="number">9</span>:</span><br><span class="line">        nums.append(<span class="number">10</span>*a+<span class="number">8</span>)</span><br><span class="line">        nums.append(<span class="number">10</span>*a+<span class="number">9</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nums.append(<span class="number">10</span>*a+d<span class="number">-1</span>)</span><br><span class="line">        nums.append(<span class="number">10</span>*a+d)</span><br><span class="line">        nums.append(<span class="number">10</span>*a+d+<span class="number">1</span>)</span><br><span class="line">    n -= <span class="number">1</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 这道题目的答案应该很好理解，如果实在难以理解不妨仿照这个程序在纸上画一画。</span></span><br></pre></td></tr></table></figure>
<p>本题的原意是使用队列完成。<br>在这里画出前几次吧，便于大家理解。  </p>
<blockquote>
<p>[1, 2, 3, 4, 5, 6, 7, 8, 9]<br>[<del>1</del>, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]<br>[<del>1</del>, <del>2</del>, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 21, 22, 23]<br>[<del>1</del>, <del>2</del>, <del>3</del>, 4, 5, 6, 7, 8, 9, 10, 11, 12, 21, 22, 23, 32, 33, 34]</p>
<p><del>这些是看到实验指导书之前写的，没想到指导书直接给出了这个。</del>  </p>
</blockquote>
<h4 id="奇怪的解法"><a href="#奇怪的解法" class="headerlink" title="奇怪的解法"></a><font color=#9966FF>奇怪的解法</font></h4><p>由于我刚开始会错了题意，于是诞生了这个稍显奇怪的使用栈完成的程序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">S = [<span class="number">-2</span>, <span class="number">1</span>]                                     <span class="comment"># 模拟栈，并提前压入两个数据，其中-2用于标记首位，防止越界</span></span><br><span class="line">digits = <span class="number">1</span>                                      <span class="comment"># 该栈存储的是各个位上的数字</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):                            <span class="comment"># 每经过一次循环，栈内存的数字就表示下一个更大的千层饼</span></span><br><span class="line">    dpopped = <span class="number">1</span></span><br><span class="line">    t = S.pop()                                 <span class="comment"># 取末尾数字</span></span><br><span class="line">    <span class="keyword">while</span> ((t == <span class="number">9</span>) <span class="keyword">or</span> (t == S[<span class="number">-1</span>]+<span class="number">1</span>)) <span class="keyword">and</span> S[<span class="number">-1</span>] != <span class="number">-2</span>:</span><br><span class="line">        dpopped += <span class="number">1</span>                            <span class="comment"># 末尾数字达到9或者比次末位大1，则需要进位</span></span><br><span class="line">        t = S.pop()                             <span class="comment"># dpopped记录需要进位的位数</span></span><br><span class="line">    <span class="keyword">if</span> S[<span class="number">-1</span>] == <span class="number">-2</span>:                             <span class="comment"># 这里判断是否要改变首位</span></span><br><span class="line">        <span class="keyword">if</span> t == <span class="number">9</span>:                              <span class="comment"># 首位是9，则变成1000...</span></span><br><span class="line">            S += [<span class="number">1</span>]+[<span class="number">0</span>]*digits</span><br><span class="line">            digits += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:                                   <span class="comment"># 否则首位加一，后续依次递减</span></span><br><span class="line">            S.append(t+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(digits<span class="number">-1</span>):</span><br><span class="line">                S.append(max(t-j,<span class="number">0</span>))            <span class="comment"># 注意此处max()函数的使用，不要减到0以下</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(dpopped):                <span class="comment"># 从右向左第一个不用进位的数位+1，向后依次递减</span></span><br><span class="line">            S.append(max(t+<span class="number">1</span>-j,<span class="number">0</span>))              <span class="comment"># 此处也是</span></span><br><span class="line">S.pop(<span class="number">0</span>)                                        <span class="comment"># 把-2删掉</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">    print(i, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>另外，此题可打表，但是打表完全是为了做题而做题，完全不能体现题目价值。  </p>
<hr>
<h2 id="C-破解虫洞"><a href="#C-破解虫洞" class="headerlink" title="C.破解虫洞"></a><font color=#0033FF>C.破解虫洞</font></h2><p>这道题目本质上是前缀表达式。由于题目保证所有数字都是一位数，所以可以安心地逐个读取字符。<br>所谓前缀表达式，是将运算符放到数据之前，这样不需要括号来规定运算顺序也不会产生歧义。<br>与之对应的有后缀表达式以及我们常用的中缀表达式。<br>简单来讲，中缀表达式中<code>2 - 1</code>使用前缀表达式表示为<code>- 2 1</code>，使用后缀表达式表示为<code>2 1 -</code>；<br>稍复杂的例子如下：  </p>
<blockquote>
<p>举例：<br>中缀表达式：<code>3*(6+4*(5-3))-2</code><br>计算过程：<code>3*(6+4*(5-3))-2 = 3*(6+4*2)-2 = 3*(6+8)-2 = 3*14-2 = 42-2 = 40</code></p>
<hr>
<p>前缀表达式：<code>- * 3 + 6 * 4 - 5 3 2</code><br>计算过程： <strong>从后向前</strong> 依次读取入栈，读取到运算符时出栈两次并执行操作， <strong>顺序为（顶元素 操作 次顶元素）</strong> ，然后将结果入栈。<br>（个人喜欢用竖杠表示栈底，意为此处不可进出元素）<br>先依次入栈，得到<code>|2, 3, 5</code><br><code>|2, 3, 5</code>，当前元素<code>-</code>，剩余未读取<code>- * 3 + 6 * 4</code><br>出栈两次，执行<code>- 5 3</code>，结果为<code>2</code>，入栈<br><code>|2, 2</code>，当前元素<code>4</code>，剩余未读取<code>- * 3 + 6 *</code><br>入栈直至读取到运算符，此时<br><code>|2, 2, 4</code>，当前元素<code>*</code>，剩余未读取<code>- * 3 + 6</code><br>出栈两次，执行<code>* 4 2</code>，结果为<code>8</code>，入栈<br><code>|2, 8</code>，当前元素<code>6</code>，入栈，剩余未读取<code>- * 3 +</code><br><code>|2, 8, 6</code>，当前元素<code>+</code>，剩余未读取<code>- * 3</code><br><code>|2, 14</code>，当前元素<code>3</code>，入栈，剩余未读取<code>- *</code><br><code>|2, 14, 3</code>，当前元素<code>*</code>，剩余未读取<code>-</code><br><code>|2, 42</code>，当前元素<code>-</code>，执行最后一次操作，得到最终结果<code>40</code></p>
<hr>
<p>后缀表达式：<code>3 6 4 5 3 - * + * 2 -</code><br>计算过程： <strong>从前向后</strong> 依次读取入栈，读取到运算符时出栈两次并执行操作， <strong>顺序为（次顶元素 操作 顶元素）</strong> ，然后将结果入栈。<br>先依次入栈，得到<code>|3, 6, 4, 5, 3</code><br>然后读取到<code>-</code>，出栈两次，执行<code>5 3 -</code>，结果为<code>2</code>，入栈<br><code>|3, 6, 4, 2</code>，当前元素<code>*</code>，剩余未读<code>+ * 2 -</code><br>出栈两次，执行<code>4 2 *</code>，结果为<code>8</code>，入栈<br><code>|3, 6, 8</code>，当前元素<code>+</code>，剩余未读<code>* 2 -</code><br><code>|3, 14</code>，当前元素<code>*</code>，剩余未读<code>2 -</code><br><code>|42</code>，当前元素<code>2</code>，剩余未读<code>-</code><br><code>|42, 2</code>，最后一个操作符<code>-</code>，执行<code>42 2 -</code>，得到最终结果<code>40</code></p>
</blockquote>
<h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><p>当然，如果不了解前缀表达式的话，不容易想到从后向前读取的方法。这里提供一个从前向后读取的方法。<br>思路就是函数符号和数字依次入栈，当栈顶两元素均为数时，运行栈顶三个元素组成的函数并入栈。当数据读完之后，栈内仅剩一个元素，即最终结果。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">42</span>*y) / (<span class="number">42</span>*x + y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x*y) / (<span class="number">42</span>*x - <span class="number">42</span>*y)</span><br><span class="line"></span><br><span class="line">coms = Stack()                                  <span class="comment"># 实例化</span></span><br><span class="line">s = input().replace(<span class="string">'('</span>, <span class="string">''</span>).replace(<span class="string">')'</span>, <span class="string">''</span>).replace(<span class="string">','</span>, <span class="string">''</span>)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s:                                     <span class="comment"># 删掉括号和逗号</span></span><br><span class="line">    <span class="keyword">if</span> c.isdigit():</span><br><span class="line">        <span class="keyword">while</span> coms.peek() <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'fg'</span>:          <span class="comment"># 判断是否连续两个数字</span></span><br><span class="line">            temp = coms.pop()                   <span class="comment"># 因为有可能运算完成之后仍然是连续两个数字</span></span><br><span class="line">            opr = coms.pop()                    <span class="comment"># 所以需要用while循环</span></span><br><span class="line">            <span class="keyword">if</span> opr == <span class="string">'f'</span>:</span><br><span class="line">                temp = str(f(float(temp), float(c)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = str(g(float(temp), float(c)))</span><br><span class="line">            c = temp</span><br><span class="line">            <span class="keyword">if</span> coms.is_empty():                 <span class="comment"># 当栈为空说明运算完成了，提前跳出避免报错</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    coms.push(c)</span><br><span class="line">print(<span class="string">"%.7f"</span>%float(coms.pop()))</span><br></pre></td></tr></table></figure>
<h4 id="优化解法-1"><a href="#优化解法-1" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">42</span>*y) / (<span class="number">42</span>*x + y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x*y) / (<span class="number">42</span>*x - <span class="number">42</span>*y)</span><br><span class="line"></span><br><span class="line">coms = Stack()                                  <span class="comment"># 实例化</span></span><br><span class="line">s = list(input())                               <span class="comment"># 使用list是为了后续使用.reverse()方法</span></span><br><span class="line">s.reverse()                                     <span class="comment"># 逆序便于完成从后向前读取</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> c.isdigit():                             <span class="comment"># 将数字入栈</span></span><br><span class="line">        coms.push(int(c))</span><br><span class="line">    <span class="keyword">elif</span> c == <span class="string">'f'</span>:                              <span class="comment"># 遇到函数符则将栈顶两元素弹出，运算后入栈</span></span><br><span class="line">        coms.push(f(coms.pop(), coms.pop()))    <span class="comment"># 要注意出栈顺序</span></span><br><span class="line">    <span class="keyword">elif</span> c == <span class="string">'g'</span>:</span><br><span class="line">        coms.push(g(coms.pop(), coms.pop()))</span><br><span class="line">print(<span class="string">"%.7f"</span>%coms.pop())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先明确一点，括号和逗号并不能影响运算，所以我们将其排除。<br>然后使用样例举例:<code>f(9, g(f(5, 2), 7))</code><br>去掉括号后变成<code>f, 9, g, f, 5, 2, 7</code><br>逆序之后变成<code>7, 2, 5, f, g, 9, f</code><br>然后从前向后读取。首先读到<code>7, 2, 5</code>，均入栈。此时栈内元素为<br><code>|7, 2, 5</code><br>然后读取到<code>f</code>，则出栈两次，依次得到<code>5</code>，<code>2</code>，然后施加<code>f(x, y)</code>函数<br>将函数的返回值<code>f(5, 2)</code>入栈。此时栈内元素为<br><code>|7, f(5, 2)</code><br>然后读到<code>g</code>，出栈两次得到<code>f(5, 2)</code>和<code>7</code>，施加<code>g(x, y)</code>函数，将返回值入栈。此时栈内元素为<br><code>|g(f(5, 2), 7)</code><br>然后读取<code>9</code>，入栈，栈内元素为<br><code>|g(f(5, 2), 7), 9</code><br>最后读到<code>f</code>，出栈两次后运算，结果入栈。此时栈内仅剩一个元素<br><code>|f(9, g(f(5, 2), 7))</code>，即为最终结果。</p>
</blockquote>
<h4 id="奇怪的解法-1"><a href="#奇怪的解法-1" class="headerlink" title="奇怪的解法"></a><font color=#9966FF>奇怪的解法</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">42</span>*y) / (<span class="number">42</span>*x + y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x*y) / (<span class="number">42</span>*x - <span class="number">42</span>*y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"%.7f"</span>%eval(input()))</span><br></pre></td></tr></table></figure>
<p>很不幸，我一直强调的不要使用的<code>eval()</code>函数可以轻松解决这道题目（并且使这道题目失去其原有价值）。但是如此这般使用<code>eval(input())</code>仅限于OJ题目测评，因为这样的形式会使得代码的强壮程度急剧下降， <strong>非常不建议直接在<code>input()</code>外套用<code>eval()</code>函数！</strong><br><strong><font color=#FF0000>实验报告上不要出现这个解法！</font></strong>  </p>
<hr>
<h2 id="D-合理复习（选做）"><a href="#D-合理复习（选做）" class="headerlink" title="D.合理复习（选做）"></a><font color=#0033FF>D.合理复习（选做）</font></h2><p>这道题又是构造类题目，代码不难，难在思维上。只需要明白可供复习的时间总长大于等于需要的时间总长就一定可以给出一个复习方案。我们只需要证明用$1$到$n$的所有正整数可以从中挑出若干不重复的整数，使之和为$\left[ 1, \frac {n \left( n+1 \right)}{2} \right]$中任意一个整数即可。<br>具体构造方法如下：  </p>
<blockquote>
<p>对于$\left[1, n\right]$中的整数，直接取自身即可；<br>对于接下来的$\left[n+1, n+\left(n-1\right)\right]$中的整数，取$n$，再从剩下的数中取一个即可；<br>对于接下来的$\left[n+\left(n-1\right)-1, n+\left(n-1\right)+\left(n-2\right)\right]$中的整数，取$n$和$n-1$，再取剩下的数中的一个；<br>以此类推即可证明以上结论。  </p>
</blockquote>
<p>因此这道题就变成了找到最小的$n$，使得$\sum^{n}_{i=1} i \ge x$.  </p>
<h4 id="正确答案-3"><a href="#正确答案-3" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a, b = map(int, input().split())</span><br><span class="line">s = (a+b)*<span class="number">2</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> (i*(i+<span class="number">1</span>)&gt;=s):</span><br><span class="line">        print(i)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="comment"># 通过枚举的方法正向找到解，注意压常数</span></span><br></pre></td></tr></table></figure>
<h4 id="优化解法-2"><a href="#优化解法-2" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> m</span><br><span class="line"></span><br><span class="line">a, b = map(int, input().split())</span><br><span class="line">c = a + b</span><br><span class="line">n = (m.sqrt(<span class="number">8</span> * c + <span class="number">1</span>) - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">print(m.ceil(n))</span><br><span class="line"><span class="comment"># 求公式反向求解</span></span><br></pre></td></tr></table></figure>
<p>$$<br>\frac {n(n+1)}{2} \ge x \Rightarrow n = \left\lceil \frac{\sqrt{8x+1}-1}{2} \right\rceil<br>$$</p>
<hr>
<h2 id="E-复杂相对分子质量（选做）"><a href="#E-复杂相对分子质量（选做）" class="headerlink" title="E.复杂相对分子质量（选做）"></a><font color=#0033FF>E.复杂相对分子质量（选做）</font></h2><p>这道题目的答题思路是使用栈进行数据存储和运算。读取到元素符号则将其原子量压入，读取到左括号直接压入，读取到数字则弹出栈顶元素，乘上数字后再压入，读取到右括号则弹出至左括号，将弹出的数据全部相加再压入，最后栈内剩下的唯一元素则是最终结果。<br>有的同学在一开始删除了所有的括号，可能是受到了破解虫洞那道题的影响。 <strong>这道题目的括号会对最终结果产生影响，所以不能删去括号！</strong>  </p>
<h4 id="正确答案-4"><a href="#正确答案-4" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">c = input() + <span class="string">'/'</span>                               <span class="comment"># 为了能够录入最后一个数，在末尾添加一个符号</span></span><br><span class="line">s = Stack()                                     <span class="comment"># 实例化</span></span><br><span class="line">temp = <span class="string">''</span>                                       <span class="comment"># 用于存放数字，因为不保证数都是一位，所以需要这个变量</span></span><br><span class="line">Ar=&#123;<span class="string">'H'</span>:<span class="number">1.007</span>, <span class="string">'C'</span>:<span class="number">12.011</span>,                      <span class="comment"># 字典，存放原子量</span></span><br><span class="line">    <span class="string">'N'</span>:<span class="number">14.007</span>, <span class="string">'O'</span>:<span class="number">15.999</span>&#125;</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> c:                                    <span class="comment"># 逐字符遍历</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ch.isdigit():                        <span class="comment"># 如果不是数字，这里也可以写 if ch.isdigit() == 0:</span></span><br><span class="line">        <span class="keyword">if</span> temp != <span class="string">''</span>:                          <span class="comment"># temp非空说明需要将前一个原子的原子量乘以乘数</span></span><br><span class="line">            m = s.pop()</span><br><span class="line">            s.push(int(temp) * m)</span><br><span class="line">            temp = <span class="string">''</span>                           <span class="comment"># 注意清空temp</span></span><br><span class="line">    <span class="keyword">else</span>:                                       <span class="comment"># 如果是数字，则暂存进temp</span></span><br><span class="line">        temp += ch</span><br><span class="line">        <span class="keyword">continue</span>                                <span class="comment"># 并且不用进行后续处理</span></span><br><span class="line">    <span class="keyword">if</span> ch == <span class="string">'('</span>:                               <span class="comment"># 左括号直接压栈</span></span><br><span class="line">        s.push(ch)</span><br><span class="line">        <span class="keyword">continue</span>                                <span class="comment"># 此处不写continue，后续使用elif也是可以的</span></span><br><span class="line">    <span class="keyword">if</span> ch <span class="keyword">in</span> Ar.keys():                         <span class="comment"># 如果是元素符号</span></span><br><span class="line">        s.push(Ar[ch])                          <span class="comment"># 则压入原子量</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> ch == <span class="string">')'</span>:                               <span class="comment"># 如果是右括号</span></span><br><span class="line">        sum_ = <span class="number">0</span>                                <span class="comment"># 循环变量赋初值</span></span><br><span class="line">        <span class="keyword">while</span> s.peek() != <span class="string">'('</span>:                  <span class="comment"># 不断弹出直至遇到左括号</span></span><br><span class="line">            sum_ += s.pop()                     <span class="comment"># 累加弹出的值</span></span><br><span class="line">        s.pop()                                 <span class="comment"># 弹出左括号</span></span><br><span class="line">        s.push(sum_)                            <span class="comment"># 压入总和</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> s.is_empty() == <span class="number">0</span>:                        <span class="comment"># 栈内剩余元素的和即为答案</span></span><br><span class="line">    ans += s.pop()</span><br><span class="line">print(<span class="string">"%.2f"</span>%ans)</span><br></pre></td></tr></table></figure>
<h4 id="优化解法-3"><a href="#优化解法-3" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">'('</span> + input() + <span class="string">')'</span></span><br><span class="line"></span><br><span class="line">    &lt;code block&gt;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"%.2f"</span>%s.pop())</span><br><span class="line"><span class="comment"># 直接在最外侧加上括号，就可以直接在循环内加和，不需要最后单独加和</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ar=&#123;<span class="string">'H'</span>:<span class="number">1007</span>, <span class="string">'C'</span>:<span class="number">12011</span>, </span><br><span class="line">    <span class="string">'N'</span>:<span class="number">14007</span>, <span class="string">'O'</span>:<span class="number">15999</span>&#125;</span><br><span class="line"></span><br><span class="line">    &lt;code block&gt;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"%.2f"</span>%(ans/<span class="number">1000</span>))</span><br><span class="line"><span class="comment"># 使用整型数运算避免精度问题。</span></span><br></pre></td></tr></table></figure>
    </div>
  </article>
  <div class="post-nav">
    <div class="post-nav-next post-nav-item">
      
        <a href="/2020/04/13/2019CCBSummary-03/" rel="next" title="2019CCBSummary-03">
          <i class="fa fa-chevron-left"></i> 2019CCBSummary-03
        </a>
      
    </div>

    <span class="post-nav-divider"></span>

    <div class="post-nav-prev post-nav-item">
    
        <a href="/2020/04/20/2019CCBSummary-05/" rel="prev" title="2019CCBSummary-05">
          2019CCBSummary-05 <i class="fa fa-chevron-right"></i>
        </a>
      
    </div>
  </div>



      </div>
        <div class="footer">
  <div class="footer-wrapper">
    <div class="copyright">
      
      <span>&copy;</span>
      
      <span>2020</span>
      
      <span class="author"><i class="fa fa-user"></i>Styphon</span>
    </div>
    
      <span>由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</span>
    
    
      <span>|</span> <span>主题 - <a href="https://github.com/littleee/corazon" target="_blank" rel="noopener">Corazon</a></span>
      
        <span>v1.0.0</span>
      
    
  </div>
</div>

    </main>
  </body>
</html>
