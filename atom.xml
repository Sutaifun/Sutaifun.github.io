<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Styphon&#39;s Site</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sutai.fun/"/>
  <updated>2020-11-12T23:37:30.146Z</updated>
  <id>http://sutai.fun/</id>
  
  <author>
    <name>Styphon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>スタイフン的麻将教室！——立直麻将基础规则（1）</title>
    <link href="http://sutai.fun/2020/11/13/StyphonMGClass01/"/>
    <id>http://sutai.fun/2020/11/13/StyphonMGClass01/</id>
    <published>2020-11-12T22:54:08.000Z</published>
    <updated>2020-11-12T23:37:30.146Z</updated>
    
    <content type="html"><![CDATA[<p>スタイフン的麻将教室！——立直麻将基础规则（1）<br>スタイフン终于出日麻教程啦，感谢各位的捧场！<br><a id="more"></a></p><h1 id="スタイフン的麻将教室！——立直麻将基础规则（1）"><a href="#スタイフン的麻将教室！——立直麻将基础规则（1）" class="headerlink" title="スタイフン的麻将教室！——立直麻将基础规则（1）"></a>スタイフン的麻将教室！——立直麻将基础规则（1）</h1><hr><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>お待たせしました！スタイフン终于出日麻教程啦，感谢各位的捧场！<br>本系列文章将分为基础规则篇和进阶篇，将立直麻将的玩法及其魅力展现给读者，并希望能够吸引更多人接触到竞技麻将。同时编写这些文章，也是有作为录制视频时用作文字稿件的想法。<br>在基础规则篇，文章将会对立直麻将的规则进行表述。这一部分的表述会偏学术，并且有很多内容是图一乐的学术形式。在进阶篇，文章将体现一部分作者个人在进行立直麻将对局时的经验以及技术。受到作者自身立直麻将水平的限制，这一部分的内容参考价值因人而异，并且其内容主观性很强，不作为一般普适性规律的表述。<br>本系列文章中的所有表述均未参考其他文献中的表述方式，如有表述不清、表述有误或有歧义，还请联系作者进行修改。  </p><p>スタイフン<br>2020/11/11</p><hr><h2 id="1-麻将基本概念"><a href="#1-麻将基本概念" class="headerlink" title="1 麻将基本概念"></a>1 麻将基本概念</h2><p>所谓麻将，本质上是一个四个人（或三个人，或两个人，或一个人）进行的比拼谁更快凑出符合规则的牌的游戏。<br>麻将原写作“麻雀”，因其在粤语中发音与普通话的“麻将”发音类似，故最终也得到了“麻将”这一名称。麻将的日语同样写作“麻雀”，发音为“マージャン”，与普通话“麻将”发音类似。因此在表示与麻将相关的概念时，会使用到“雀”这个字。如“雀士（ジャンシ）”表示麻将玩家。  </p><h3 id="1-1-麻将用具的介绍"><a href="#1-1-麻将用具的介绍" class="headerlink" title="1.1 麻将用具的介绍"></a>1.1 麻将用具的介绍</h3><h4 id="1-1-1-麻将牌"><a href="#1-1-1-麻将牌" class="headerlink" title="1.1.1 麻将牌"></a>1.1.1 麻将牌</h4><p>麻将中最核心的道具便是麻将牌，传统的麻将牌以木、竹、金属或牛骨作为材料制作，现代麻将多以聚合物材料制作（如大洋化学品牌的麻将牌多以密胺制作）。其单张麻将牌的尺寸多与一般的学生用橡皮相仿，并以其最长边在$\rm{mm}$为单位时的数值作为表示麻将牌尺寸的标号。最长边为$44\rm{mm}$的麻将牌，也称为“#44麻将”，读作“四十四号麻将牌”。一般中国的麻将牌多用#38至#50的麻将牌，而日本的麻将牌则是以#26，#28，#30这三个尺寸最为常见，因此先前接触过中国麻将牌的人第一次接触日本麻将牌时会觉得日本麻将牌尺寸非常小。<br>立直麻将是广泛流传于日本各地的麻将规则，因此立直麻将的对局一般使用日本麻将牌，并且也可以用“日本麻将”这一名称或其简称“日麻”来称呼立直麻将。<br>一张麻将牌会在其表面积最大的两个面其中的一个面刻上牌面图案并上色，称这个面为牌面，一般认知下视为一张牌的正面；与之相对的一个面则称为牌背，视为一张牌的背面。<br>在一般的立直麻将对局中，会使用到34种牌，并且每一种牌有4枚，总计136张牌，称这样的136张牌为一副麻将牌。同一种牌的4枚在用途上无任何区别。<br>34种牌的牌面如下所示。<br><img src="https://mj.black-desk.cn/123456789m" alt=""><br><img src="https://mj.black-desk.cn/123456789s" alt=""><br><img src="https://mj.black-desk.cn/123456789p" alt=""><br><img src="https://mj.black-desk.cn/1234z" alt=""><br><img src="https://mj.black-desk.cn/567z" alt=""><br>同一副牌中，所有牌的牌背外观上是相同的，其目的是使得牌背向上的牌无法区分。最常见的日本麻将牌背颜色是黄色和蓝色，分别如下。<br><img src="https://mj.black-desk.cn/+?color=orange" alt=""> <img src="https://mj.black-desk.cn/+" alt=""> </p><h5 id="麻将牌的名称及分类"><a href="#麻将牌的名称及分类" class="headerlink" title="麻将牌的名称及分类"></a>麻将牌的名称及分类</h5><p><img src="https://mj.black-desk.cn/123456789m" alt=""><br>以上九张牌的名称分别为<strong>一万</strong>，<strong>二万</strong>，<strong>三万</strong>，<strong>四万</strong>，<strong>五万</strong>，<strong>六万</strong>，<strong>七万</strong>，<strong>八万</strong>，<strong>九万</strong>，统称<strong>万牌</strong>。<br>其对应的缩写表达为对应阿拉伯数字加上字母m，比如<img src="https://mj.black-desk.cn/6m?scale=0.5" alt="">在简写时可以写作<code>6m</code>，多张万牌同时表达时可以连续写若干数字，然后在最后添加一个字母m即可，如<img src="https://mj.black-desk.cn/4467m?scale=0.5" alt="">可以简写成为<code>4467m</code>。  </p><p><img src="https://mj.black-desk.cn/123456789s" alt=""><br>以上九张牌的名称分别为<strong>一索</strong>，<strong>二索</strong>，<strong>三索</strong>，<strong>四索</strong>，<strong>五索</strong>，<strong>六索</strong>，<strong>七索</strong>，<strong>八索</strong>，<strong>九索</strong>，统称<strong>索牌</strong>。<br>其对应的缩写表达为对应阿拉伯数字加上字母s，多张索牌表示与万牌同理。<br>索牌也可称作一条，二条等，但这并不代表可以使用字母t表示索牌的简写。  </p><blockquote><p>中国麻将有将一索称为“幺鸡”的习惯，因为中国麻将中的一索形象是一只鸟<img src="https://mj.black-desk.cn/1s?scale=0.5&amp;country=cn" alt="">，但是日本麻将中并没有这一习惯，望读者注意。<br>日本麻将牌中的一索的形象是一只孔雀，而其他索牌则是以竹子为基本图案元素。<br>麻将新手可能会在记忆麻将图形与数字的关联方面产生不同程度的障碍，这一点在8s这张牌上尤其明显。  </p></blockquote><p><img src="https://mj.black-desk.cn/123456789p" alt=""><br>以上九张牌的名称分别为<strong>一饼</strong>，<strong>二饼</strong>，<strong>三饼</strong>，<strong>四饼</strong>，<strong>五饼</strong>，<strong>六饼</strong>，<strong>七饼</strong>，<strong>八饼</strong>，<strong>九饼</strong>，统称<strong>饼牌</strong>。<br>其对应的缩写表达为对应阿拉伯数字加上字母p，多张饼牌表示与万牌同理。<br>饼牌也可称作一筒，二筒等，但这并不代表可以使用字母t表示饼牌的简写。  </p><blockquote><p>日本麻将中饼牌的牌面是以樱花作为基本图案元素。  </p></blockquote><p>万、索、饼这三类总计27种牌统称<strong>序数牌</strong>，简称<strong>数牌</strong>，万、索、饼则称为数牌的<strong>花色</strong>。  </p><p><img src="https://mj.black-desk.cn/1234z" alt=""><br>以上四张牌分别称作<strong>东风</strong>，<strong>南风</strong>，<strong>西风</strong>，<strong>北风</strong>，其简称分别为<strong>东</strong>，<strong>南</strong>，<strong>西</strong>，<strong>北</strong>，这四种牌统称<strong>风牌</strong>，也可称为<strong>四喜牌</strong>。<br><img src="https://mj.black-desk.cn/567z" alt=""><br>以上三张牌分别称作<strong>白板</strong>，<strong>发财</strong>，<strong>红中</strong>，其简称分别为<strong>白</strong>，<strong>发</strong>，<strong>中</strong>，这三种牌统称<strong>三元牌</strong>。<br>在缩写时，一般直接采用对应的单个汉字简称作为其缩写，也可以使用阿拉伯数字1234567加上字母z分别表示“东南西北白发中”。如<img src="https://mj.black-desk.cn/222z?scale=0.5" alt="">可以简写作“南南南”，也可以简写作<code>222z</code>，在不便使用汉字的场景下（如仅支持<code>ASCII</code>字符的场景下）则使用后者。<br>风牌与三元牌统称<strong>字牌</strong>，与之前提及的数牌是相对的概念。<br>在表示许多牌时，可以采用“合并同类项”的思想进行表示，如<img src="https://mj.black-desk.cn/12677m345s557p16z?scale=0.5" alt="">就可以表示为<code>12677m345s557p16z</code></p><blockquote><p>万牌虽然牌面也是汉字，但属于数牌；白板虽然牌面没有汉字，但属于字牌。<br>中国麻将的白板在牌面上会有一个方框，看起来是这样的<img src="https://mj.black-desk.cn/7z?scale=0.5&amp;country=cn" alt="">，但日本麻将的白板的牌面就是什么图案也没有。<br>中国麻将的三元牌也称作<strong>箭牌</strong>，日本麻将中没有这一称呼；中国麻将中三元牌的顺序为“中发白”，而日本麻将中则恰好相反，为“白发中”。<br>中国麻将中还会有八种花牌“春夏秋冬梅兰竹菊”<img src="https://mj.black-desk.cn/春夏秋冬梅兰竹菊?scale=0.5" alt="">，每种各一张，日本麻将也会附带其中“春夏秋冬”四张，但是在一般的立直麻将规则中我们并不会使用这些花牌。  </p></blockquote><p><img src="https://mj.black-desk.cn/0m0s0p" alt=""><br>以上三张牌称为<strong>赤五万</strong>，<strong>赤五索</strong>，<strong>赤五饼</strong>，亦可称为<strong>红五万</strong>等，统称<strong>赤牌</strong>或<strong>红牌</strong>。依照具体规则的不同，会将一副麻将牌里的0,3,4,6张五万，五索和五饼<strong>替换</strong>为对应的赤牌形式。除计分以外，赤牌与其对应的普通形式的牌无任何区别。<br>赤牌在简写表示的时候使用数字0以及其花色对应的字母。如<img src="https://mj.black-desk.cn/0p?scale=0.5" alt="">表示为<code>0p</code>。<br>如图所示的赤牌是带有一个额外的小圆点的形式，也有不含这个小圆点的赤牌，两种赤牌无任何区别。<br><img src="https://mj.black-desk.cn/19m19s19p" alt=""><br>数牌中每种花色的1和9，总计6种牌，统称为<strong>老头牌</strong>，也称为<strong>端牌</strong>。<br><img src="https://mj.black-desk.cn/19m19s19p1234567z" alt=""><br>老头牌与字牌总计13种牌，统称<strong>幺九牌</strong>。除去幺九牌之后剩余的21种牌则统称为<strong>中张牌</strong>。  </p><h5 id="麻将牌的日语读法"><a href="#麻将牌的日语读法" class="headerlink" title="麻将牌的日语读法"></a>麻将牌的日语读法</h5><h6 id="数牌读法"><a href="#数牌读法" class="headerlink" title="数牌读法"></a>数牌读法</h6><p>数字1~9不使用日语中的训读或音读，而是采用完全模拟现代汉语发音的特有读法。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">数字</th><th style="text-align:center">一</th><th style="text-align:center">二</th><th style="text-align:center">三</th><th style="text-align:center">四</th><th style="text-align:center">五</th><th style="text-align:center">六</th><th style="text-align:center">七</th><th style="text-align:center">八</th><th style="text-align:center">九</th></tr></thead><tbody><tr><td style="text-align:center">读法</td><td style="text-align:center">イー</td><td style="text-align:center">リャン</td><td style="text-align:center">サン</td><td style="text-align:center">スー</td><td style="text-align:center">ウー</td><td style="text-align:center">ロー</td><td style="text-align:center">チー</td><td style="text-align:center">パー</td><td style="text-align:center">キュウ</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">花色</th><th style="text-align:center">万</th><th style="text-align:center">索</th><th style="text-align:center">饼</th></tr></thead><tbody><tr><td style="text-align:center">读法</td><td style="text-align:center">マン</td><td style="text-align:center">ソウ</td><td style="text-align:center">ピン</td></tr></tbody></table></div><blockquote><p>实际上也有很多人直接使用日语中的数字来表示麻将牌的，这种做法完全没有问题，根据喜好即可。<br>年长的雀士在表示万牌的时候也会使用“ワン”这一贴近中文发音的表示，但是这种表示方法似乎越来越少见。  </p></blockquote><h6 id="字牌读法"><a href="#字牌读法" class="headerlink" title="字牌读法"></a>字牌读法</h6><div class="table-container"><table><thead><tr><th style="text-align:center">字牌</th><th style="text-align:center">东</th><th style="text-align:center">南</th><th style="text-align:center">西</th><th style="text-align:center">北</th><th style="text-align:center">白</th><th style="text-align:center">发</th><th style="text-align:center">中</th></tr></thead><tbody><tr><td style="text-align:center">读法</td><td style="text-align:center">トン</td><td style="text-align:center">ナン</td><td style="text-align:center">シャー</td><td style="text-align:center">ペイ</td><td style="text-align:center">ハク</td><td style="text-align:center">ハツ</td><td style="text-align:center">チュン</td></tr></tbody></table></div><h4 id="1-1-2-点棒"><a href="#1-1-2-点棒" class="headerlink" title="1.1.2 点棒"></a>1.1.2 点棒</h4><p>点棒是立直麻将专用的筹码，用于计分。<br>传统的点棒含有以下四种，每种有若干支，同种点棒每一支表达相同的分值。立直麻将分值的单位为“点”，其最小分度为$100.$<br><img src="../../../../images/0.1ks.png" alt=""><br><img src="../../../../images/1ks.png" alt=""><br><img src="../../../../images/5ks.png" alt=""><br><img src="../../../../images/10ks.png" alt=""><br>从上至下分别称为<strong>百点点棒</strong>，<strong>千点点棒</strong>，<strong>五千点点棒</strong>，<strong>万点点棒</strong>，分别表示100点，1000点，5000点和10000点。<br>有些厂家会销售彩色点棒以满足不同用户的外观喜好。目前最常见的彩色点棒的外观如下所示。<br><img src="../../../../images/0.1kcs.png" alt=""><br><img src="../../../../images/1kcs.png" alt=""><br><img src="../../../../images/5kcs.png" alt=""><br><img src="../../../../images/10kcs.png" alt=""><br>为了解决百点点棒数量过多不便存放这一问题，部分麻将机会配有<strong>五百点点棒</strong>，其白色和彩色外观如下图所示。<br><img src="../../../../images/0.5ks.png" alt=""><br><img src="../../../../images/0.5kcs.png" alt=""><br>因为彩色五百点点棒与百点点棒使用了相同的颜色，因此彩色点棒套装中如果含有五百点点棒，则百点点棒使用白色的版本。  </p><h4 id="1-1-3-其他麻将用具"><a href="#1-1-3-其他麻将用具" class="headerlink" title="1.1.3 其他麻将用具"></a>1.1.3 其他麻将用具</h4><h5 id="骰子"><a href="#骰子" class="headerlink" title="骰子"></a>骰子</h5><p>对局中需要使用两枚骰子。  </p><h5 id="起家标志"><a href="#起家标志" class="headerlink" title="起家标志"></a>起家标志</h5><p>也叫起家码或场风表示码，为一块一面写有“东”，一面写有“南”的板子。  </p><p><img src="../../../../images/sus.png" alt=""><br><img src="../../../../images/sds.png" alt="">  </p><h5 id="烧鸡标志"><a href="#烧鸡标志" class="headerlink" title="烧鸡标志"></a>烧鸡标志</h5><p>用来表示一名玩家的“烧鸡状态”。<br><em>“烧鸡状态”会在第二部分进行解释。</em>  </p><h3 id="1-2-和牌型"><a href="#1-2-和牌型" class="headerlink" title="1.2 和牌型"></a>1.2 和牌型</h3><p>如同上文所讲，麻将是一个凑牌游戏，比拼谁能够更快地凑出符合要求的牌。而这种“符合要求的牌型”则称作<strong>和（hú）牌型</strong>，而获得胜利这个动作则称为<strong>和了</strong>。  </p><h4 id="1-2-1-麻将的基本形状"><a href="#1-2-1-麻将的基本形状" class="headerlink" title="1.2.1 麻将的基本形状"></a>1.2.1 麻将的基本形状</h4><p>一副和了的牌通常是由各种基本形状组成的，这些基本形状就如同零件一般组成了和牌型的整体。  </p><h5 id="由三张牌组成的零件"><a href="#由三张牌组成的零件" class="headerlink" title="由三张牌组成的零件"></a>由三张牌组成的零件</h5><h6 id="刻子"><a href="#刻子" class="headerlink" title="刻子"></a>刻子</h6><p>刻子即三张相同的牌，如<img src="https://mj.black-desk.cn/444m?scale=0.5" alt="">或<img src="https://mj.black-desk.cn/333z?scale=0.5" alt="">。<br><img src="https://mj.black-desk.cn/055p?scale=0.5" alt="">也属于一个刻子。  </p><h6 id="顺子"><a href="#顺子" class="headerlink" title="顺子"></a>顺子</h6><p>顺子即三张花色相同，点数依次增加1的序数牌，如<img src="https://mj.black-desk.cn/678m?scale=0.5" alt="">或<img src="https://mj.black-desk.cn/123s?scale=0.5" alt="">。字牌无法组成顺子。<br>需要注意的是，如同<img src="https://mj.black-desk.cn/912p?scale=0.5" alt="">这样的牌并<strong>不</strong>算作顺子。  </p><h6 id="杠子"><a href="#杠子" class="headerlink" title="杠子"></a>杠子</h6><p>杠子是由四张相同的牌组成的，如<img src="https://mj.black-desk.cn/9999m?scale=0.5" alt="">，但只有在完成<strong>开杠</strong>操作后，四张相同的牌才算做一个杠子，否则只算做一个刻子和单独的一张牌。<br>杠子是刻子的一种特殊形式，也就是说原本是四张牌但是视为三张牌。杠子拥有刻子的全部属性，同时也会拥有作为杠子的附加属性。这些属性会在之后的讲解中逐步解释。<br><em>“开杠”操作将在第二部分进行解释。</em>  </p><p>刻子、顺子、杠子统称为<strong>面子</strong>。  </p><h5 id="由两张牌组成的零件"><a href="#由两张牌组成的零件" class="headerlink" title="由两张牌组成的零件"></a>由两张牌组成的零件</h5><h6 id="对子"><a href="#对子" class="headerlink" title="对子"></a>对子</h6><p>对子即两张相同的牌，如<img src="https://mj.black-desk.cn/77p?scale=0.5" alt="">或<img src="https://mj.black-desk.cn/55z?scale=0.5" alt="">。<br><img src="https://mj.black-desk.cn/05s?scale=0.5" alt="">也属于一个对子。  </p><h6 id="搭子"><a href="#搭子" class="headerlink" title="搭子"></a>搭子</h6><p>搭子即顺子去掉三枚中的某一枚后剩下两枚所组成的牌型，根据形状的不同分为三类。<br>形如<img src="https://mj.black-desk.cn/67s?scale=0.5" alt="">这种，添加<img src="https://mj.black-desk.cn/5s?scale=0.5" alt="">或<img src="https://mj.black-desk.cn/8s?scale=0.5" alt="">两种牌均可成为顺子的牌型称作<strong>两面搭子</strong>。<br>形如<img src="https://mj.black-desk.cn/07m?scale=0.5" alt="">这种，只有添加<img src="https://mj.black-desk.cn/6m?scale=0.5" alt="">才可以成为顺子的牌型称作<strong>坎张搭子</strong>，也可以叫<strong>嵌张搭子</strong>或<strong>中洞搭子</strong>。<br>形如<img src="https://mj.black-desk.cn/12p?scale=0.5" alt="">这种看似两面搭子但是由于其中一面是不存在的零饼（这里不是指红五饼），从而使得只有<img src="https://mj.black-desk.cn/3p?scale=0.5" alt="">可以使得其成为一个顺子的牌型称作<strong>边张搭子</strong>。<br>所有的搭子在简称的时候均可以省略“搭子”二字。  </p><h5 id="一张牌"><a href="#一张牌" class="headerlink" title="一张牌"></a>一张牌</h5><p>即不是面子也不是搭子也不是对子的一张牌称作<strong>孤张</strong>或<strong>浮张</strong>。  </p><h4 id="1-2-2-标准和牌型"><a href="#1-2-2-标准和牌型" class="headerlink" title="1.2.2 标准和牌型"></a>1.2.2 标准和牌型</h4><p><strong>标准和牌型</strong>也<strong>叫基本和牌型</strong>，简称<strong>标准型</strong>或<strong>基本型</strong>，是最基本，最常见的和牌形状。<br>一个标准和牌型是由一副136张麻将中凑出四个面子以及一个对子，此时这个对子称作<strong>雀头</strong>。<br>以下是一些标准和牌型的例子。<br><img src="https://mj.black-desk.cn/23488m067s999p222z" alt=""><br><img src="https://mj.black-desk.cn/122334456s56667p" alt=""><br><img src="https://mj.black-desk.cn/678m22234555p555z" alt=""><br><img src="https://mj.black-desk.cn/11122233344466z" alt=""><br><img src="https://mj.black-desk.cn/11122233344455m" alt=""><br><img src="https://mj.black-desk.cn/11123405678999p" alt=""><br>第二个例子的分解方法为<img src="https://mj.black-desk.cn/123s|234s|456s|567p|66p?scale=0.5" alt="">。<br>其中第三、第五个例子有不止一种分解的方法，前者可以看做<img src="https://mj.black-desk.cn/678m|222p|345p|555z|55p?scale=0.5" alt="">，也可以看做<img src="https://mj.black-desk.cn/678m|234p|555p|555z|22p?scale=0.5" alt="">。  </p><h4 id="1-2-3-特殊和牌型"><a href="#1-2-3-特殊和牌型" class="headerlink" title="1.2.3 特殊和牌型"></a>1.2.3 特殊和牌型</h4><p><strong>特殊和牌型</strong>是指不通过4面子+1雀头这种形式组成的和牌型。由于所有的特殊和牌型都不需要面子，所以可以使用<strong>面子手</strong>这一名称来称呼标准和牌型。  </p><h5 id="七对型"><a href="#七对型" class="headerlink" title="七对型"></a>七对型</h5><p>顾名思义，由七个对子组成的和牌型，但是要求这七个对子不能有重复的对子。<br>以下是几个七对型的例子。<br><img src="https://mj.black-desk.cn/3366m22s0599p1177z" alt=""><br><img src="https://mj.black-desk.cn/11334455667799s" alt=""><br><img src="https://mj.black-desk.cn/11223344556677z" alt="">  </p><p>需要注意的是，以下两种不属于七对型。<br><img src="https://mj.black-desk.cn/444488m1133s6699p" alt=""><br>（出现了重复的对子，不属于七对型，实际上这个牌型不属于和牌型）<br><img src="https://mj.black-desk.cn/223344m55s667788p" alt=""><br>（可以按照标准型分解为<img src="https://mj.black-desk.cn/234m|234m|678p|678p|55s?scale=0.5" alt="">，像这种可以分解标准型的“类七对型”，均不属于七对型，其具体原因将在第三部分解释）。  </p><h5 id="国士无双型"><a href="#国士无双型" class="headerlink" title="国士无双型"></a>国士无双型</h5><p>国士无双型是指由全部13种幺九牌各一张，再添加任意一张幺九牌组成的和牌型。<br>以下是国士无双型的例子。<br><img src="https://mj.black-desk.cn/119m19s19p1234567z" alt=""><br><img src="https://mj.black-desk.cn/19m19s19p12334567z" alt="">  </p><h3 id="1-3-听牌"><a href="#1-3-听牌" class="headerlink" title="1.3 听牌"></a>1.3 听牌</h3><p><strong>听（tīng）牌</strong>是指差一张就可以满足和牌型的状态。也就是说，和牌型中去掉任意一张，就形成了<strong>听牌型</strong>。<br>对于一个听牌型，在添加了某张牌之后便可以组成和牌型，则称<strong>听某张牌</strong>。一个听牌型不一定只听一种牌，一个听牌型所听的所有的牌的集合称为这个听牌型的<strong>待牌</strong>。<br>以下是一些听牌型的例子。  </p><ol><li><img src="https://mj.black-desk.cn/2399m123s123789p?scale=0.5" alt=""> 听 <img src="https://mj.black-desk.cn/1m|4m?scale=0.5" alt="">  </li><li><img src="https://mj.black-desk.cn/1399m123s123789p?scale=0.5" alt=""> 听 <img src="https://mj.black-desk.cn/2m?scale=0.5" alt="">  </li><li><img src="https://mj.black-desk.cn/1299m123s123789p?scale=0.5" alt=""> 听 <img src="https://mj.black-desk.cn/3m?scale=0.5" alt="">  </li><li><img src="https://mj.black-desk.cn/1199m123s123789p?scale=0.5" alt=""> 听 <img src="https://mj.black-desk.cn/1m|9m?scale=0.5" alt="">  </li><li><img src="https://mj.black-desk.cn/1239m123s123789p?scale=0.5" alt=""> 听 <img src="https://mj.black-desk.cn/9m?scale=0.5" alt="">  </li><li><img src="https://mj.black-desk.cn/99m23456s123789p?scale=0.5" alt=""> 听 <img src="https://mj.black-desk.cn/1s|4s|7s?scale=0.5" alt="">  </li><li><img src="https://mj.black-desk.cn/2223m123s123789p?scale=0.5" alt=""> 听 <img src="https://mj.black-desk.cn/1m|3m|4m?scale=0.5" alt="">  </li><li><img src="https://mj.black-desk.cn/11123m11s123789p?scale=0.5" alt=""> 听 <img src="https://mj.black-desk.cn/1m|4m|1s?scale=0.5" alt="">  </li><li><img src="https://mj.black-desk.cn/1234m123s123789p?scale=0.5" alt=""> 听 <img src="https://mj.black-desk.cn/1m|4m?scale=0.5" alt="">  </li><li><img src="https://mj.black-desk.cn/1112345678999m?scale=0.5" alt=""> 听 <img src="https://mj.black-desk.cn/1m|2m|3m|4m|5m|6m|7m|8m|9m?scale=0.5" alt="">  </li><li><img src="https://mj.black-desk.cn/1199m1199s119p22z?scale=0.5" alt=""> 听 <img src="https://mj.black-desk.cn/9p?scale=0.5" alt="">  </li><li><img src="https://mj.black-desk.cn/19m199s1p1234567z?scale=0.5" alt=""> 听 <img src="https://mj.black-desk.cn/9p?scale=0.5" alt=""><br><img src="https://mj.black-desk.cn/19m19s19p1234567z?scale=0.5" alt=""> 听 <img src="https://mj.black-desk.cn/1m|9m|1s|9s|1p|9p|1z|2z|3z|4z|5z|6z|7z?scale=0.5" alt=""><br>其中，将会构成标准型的听牌型还可以根据其待牌的方式进一步细分。<br>如果听牌型缺少的是一个顺子，则根据搭子的种类，分为<strong>两面听牌</strong>，<strong>坎张听牌</strong>和<strong>边张听牌</strong>（如前三个例子）；如果缺少一个刻子，则是<strong>双碰听牌</strong>，也叫<strong>对碰听牌</strong>（如第四个例子）；如果缺少雀头，则称为<strong>单骑听牌</strong>（如第五个例子）。<br>同一个听牌型在听不同牌的时候不一定是同一种听牌型，比如第七个例子听<img src="https://mj.black-desk.cn/1m|4m?scale=0.5" alt="">是两面听牌，听<img src="https://mj.black-desk.cn/3m?scale=0.5" alt="">则是单骑听牌。<br>同一个听牌型听同一张牌也不一定是同一种听牌型，比如第八个例子听<img src="https://mj.black-desk.cn/4m?scale=0.5" alt="">是两面听牌，听<img src="https://mj.black-desk.cn/1s?scale=0.5" alt="">是双碰听牌，<img src="https://mj.black-desk.cn/1m?scale=0.5" alt="">则既可以是两面听牌，也可以是双碰听牌。<em>这时就要根据第三部分所讲的内容来判断究竟是哪一种听牌了。</em></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;スタイフン的麻将教室！——立直麻将基础规则（1）&lt;br&gt;スタイフン终于出日麻教程啦，感谢各位的捧场！&lt;br&gt;
    
    </summary>
    
    
    
      <category term="立直麻将" scheme="http://sutai.fun/tags/%E7%AB%8B%E7%9B%B4%E9%BA%BB%E5%B0%86/"/>
    
  </entry>
  
  <entry>
    <title>2019CCBSummary#06</title>
    <link href="http://sutai.fun/2020/05/03/2019CCBSummary-06/"/>
    <id>http://sutai.fun/2020/05/03/2019CCBSummary-06/</id>
    <published>2020-05-03T06:58:37.000Z</published>
    <updated>2020-05-03T07:05:18.215Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Experiment #06<br>北航致真书院19级大学计算机基础第六次上机实验实验总结<br><a id="more"></a></p><h1 id="第六次实验问题汇总"><a href="#第六次实验问题汇总" class="headerlink" title="第六次实验问题汇总"></a>第六次实验问题汇总</h1><hr><h2 id="A-电力分配"><a href="#A-电力分配" class="headerlink" title="A.电力分配"></a><font color=#0033FF>A.电力分配</font></h2><p>这道题目在强调了一一对应之后，不难发现这是一道贪心算法的题目（题目甚至明示了贪心算法）。<br>思路很简单：对于所需功率最小的生产线，总是尝试使用提供功率尽可能小的发电机进行供电；<br>或者对于提供功率最大的发电机，总是尝试对所需功率尽可能大的生产线进行供电。<br>这两个思路虽然最终分配方案不一定一样，但是可供电的生产线数量是相等的。  </p><h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">n = int(input())lnum = []for _ in range(n):    lnum.append(int(input()))lnum.sort()                                 # 注意题目并没有说输入时满足某种次序m = int(input())                            # 所以需要自行.sort()进行排序ln2 = []for _ in range(m):    ln2.append(int(input()))ln2.sort()ans = 0for i in ln2:                               # 使用上述第一种思路    if lnum[0] &lt;= i:        ans += 1        lnum.pop(0)        if lnum == []:                      # 进行特判避免索引越界            breakprint(ans)</code></pre><hr><h2 id="B-我不是盘神"><a href="#B-我不是盘神" class="headerlink" title="B.我不是盘神"></a><font color=#0033FF>B.我不是盘神</font></h2><p>这道题目不难想到先用XXXDownload下载两个最大的文件，然后再用XX网盘下载一个最小的文件，如此循环。<br>本质贪心算法，但是不用去模拟这一过程。我们只需要算出哪些文件需要用XX网盘下载即可。  </p><h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><p>不难算出，需要用XX网盘下载的文件是从小到大排序后前<code>n//3</code>个文件。  </p><pre><code class="lang-python">n = int(input())lnum = [int(input()) for i in range(n)]     # 列表生成式输入数据lnum.sort()                                 # 排序lans = lnum[:n//3]                          # 切片操作取出需要用XX网盘下载的文件print(sum(lans))                            # 输出总大小print(&#39; &#39;.join(list(map(str, lans))))       # 依次输出文件大小</code></pre><hr><h2 id="C-装备选择"><a href="#C-装备选择" class="headerlink" title="C.装备选择"></a><font color=#0033FF>C.装备选择</font></h2><p>通过仔细阅读题目，这道题目就是换了马甲的背包问题。所以这里不做重复的解释了。<br>如果还是有问题，请查阅课件里相应的讲解。  </p><h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">r = int(input())leq = [0]for _ in range(r):    leq.append(tuple(map(int, input().split())))n = int(input())                            # 关于下面value的生成需要注意一下value = [[0 for i in range(n+1)] for j in range(r+1)]for i in range(1, r+1):    for j in range(1, n+1):                 # 状态转移方程，为了避免越界需要分支        if j &gt;= leq[i][0]:            value[i][j] = max(value[i-1][j], value[i-1][j-leq[i][0]]+leq[i][1])        else:            value[i][j] = value[i-1][j]print(value[-1][-1])                        # 状态表格最右下即使答案cnt = 0                                     # 计数器ans = []                                    # 存储答案mon = nfor i in range(r, 0, -1):    if value[i][mon] != value[i-1][mon]:    # 不等于说明选取了当前装备        cnt += 1                            # 计数器加一        ans.append(str(i-1))        mon -= leq[i][0]                    # 注意这一步，要减少相应的金币数print(cnt)print(&#39; &#39;.join(ans))</code></pre><hr><h2 id="D-我不是盘神Pro（选做）"><a href="#D-我不是盘神Pro（选做）" class="headerlink" title="D.我不是盘神Pro（选做）"></a><font color=#0033FF>D.我不是盘神Pro（选做）</font></h2><p>这道题目相比B题，多了一个限制条件，即不能改变下载的顺序，所以原先的下载策略不再适用于这道题目。<br>可以采用动态规划完成这道题目。<br>但是尝试写出状态转移方程时，发现影响状态的参数不仅仅是已下载的文件数量。  </p><h4 id="正确答案-3"><a href="#正确答案-3" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><p>使用一个<code>n*3</code>的列表存储状态，其中<code>l[n][k]</code>指下载<code>n</code>个文件且目前已经连续使用XXXDownload下载了<code>k</code>个文件时的最优解。<br><code>l[n][0]</code>是指第<code>n</code>个文件使用XX网盘下载，需要取<code>l[n-1][k]</code>的最小值加上第<code>n</code>个文件的大小；<br><code>l[n][1]</code>值第<code>n</code>个文件使用XXXDownload下载，第<code>n</code>个文件使用XX网盘下载，所以只需要取<code>l[n-1][0]</code>的值即可；<br><code>l[n][2]</code>值第<code>n</code>个文件和第<code>n-1</code>个文件使用XXXDownload下载，第<code>n-2</code>个文件使用XX网盘下载，所以只需要取<code>l[n-1][1]</code>的值即可。</p><pre><code class="lang-python">n = int(input())lnum = [int(input()) for i in range(n)]lcon = [[0 for i in range(3)] for j in range(n)]for i in range(n):                          # 这里无需进行特判，i=0时，i-1为-1    lcon[i][0] = min(lcon[i-1][0], lcon[i-1][1], lcon[i-1][2]) + lnum[i]    lcon[i][1] = lcon[i-1][0]               # 开始时lcon[-1][k]均为0，不会影响最终结果    lcon[i][2] = lcon[i-1][1]print(min(lcon[-1]))                        # 输出最小的情况</code></pre><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><p>上述解法还有优化空间。因为<code>lcon[i][1] = lcon[i-1][0]</code>，<code>lcon[i][2] = lcon[i-1][1] = lcon[i-2][0]</code>，我们发现完全没有必要使用后两列数据，所以可以把存储状态的列表压缩成一维。<br>此时<code>lcon[i]</code>表示使用XX网盘下载第<code>n</code>个文件时所耗总时间。  </p><pre><code class="lang-python">n = int(input())lnum = [int(input()) for i in range(n)]lcon = [0 for j in range(n)]for i in range(n):    lcon[i] = min(lcon[i-3], lcon[i-2], lcon[i-1]) + lnum[i]print(min(lcon[-3:]))</code></pre><hr><h2 id="关于列表的某些性质"><a href="#关于列表的某些性质" class="headerlink" title="关于列表的某些性质"></a>关于列表的某些性质</h2><p>在生成一个二维0列表时，有的同学使用了下列写法：</p><pre><code class="lang-python">a = []for i in range(n):    a.append(0)l = []for i in range(m):    l.append(a)</code></pre><p>确实生成了二维0列表，但是最终的程序却没有正确输出。这是因为<code>list</code>数据类型在存储时的某些特性导致的。<br>看如下的一个交互式实例：</p><pre><code class="lang-python">&gt;&gt;&gt; a = []&gt;&gt;&gt; b = a&gt;&gt;&gt; a.append(1)&gt;&gt;&gt; b[1]</code></pre><p>实际上程序在执行<code>a = []</code>时，是先创建了一个空列表<code>[]</code>，然后将变量名<code>a</code>指向了这个列表：<br><img src="https://www.z4a.net/images/2020/05/03/img001.png" alt="img001.png"><br>在执行<code>b = a</code>时，是直接将变量名<code>b</code>指向了变量名<code>a</code>所指向的变量：<br><img src="https://www.z4a.net/images/2020/05/03/img002.png" alt="img002.png"><br>然后执行<code>a.append(1)</code>：<br><img src="https://www.z4a.net/images/2020/05/03/img003.png" alt="img003.png"><br>不难看出，此时调用变量<code>b</code>，返回的并不是空列表，而是添加了元素之后的列表。<br>了解了这一点之后，我们再看一下为什么上面那种写法会出现问题。<br>先看一下使用了上述构造的实例，究竟会出现什么问题：  </p><pre><code class="lang-python">&gt;&gt;&gt; a = []&gt;&gt;&gt; for i in range(5):...     a.append(0)... &gt;&gt;&gt; a[0, 0, 0, 0, 0]&gt;&gt;&gt; l = []&gt;&gt;&gt; for i in range(3):...     l.append(a)... &gt;&gt;&gt; l[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]&gt;&gt;&gt; l[0][3] = 1&gt;&gt;&gt; l[[0, 0, 0, 1, 0], [0, 0, 0, 1, 0], [0, 0, 0, 1, 0]]&gt;&gt;&gt; a[0, 0, 0, 1, 0]</code></pre><p>问题就是当改变列表中某一项的值时，发现其他的值也被修改了。<br>我们来分析一下程序是如何执行这些语句的。<br>首先是创建<code>a</code>，没有什么问题：<br><img src="https://www.z4a.net/images/2020/05/03/img004.png" alt="img004.png"><br>然后创建<code>l</code>：<br><img src="https://www.z4a.net/images/2020/05/03/img005.png" alt="img005.png"><br>然后<code>l[0] = a</code>：<br><img src="https://www.z4a.net/images/2020/05/03/img006.png" alt="img006.png"><br>这时候我们发现其实程序内部是将<code>l[0]</code>指向了<code>a</code>所指的列表，所以当第二个循环执行完之后，不难想到其实是这样的：<br><img src="https://www.z4a.net/images/2020/05/03/img007.png" alt="img007.png"><br>于是当执行到<code>l[0][3] = 1</code>的时候，实际上是这样的：<br><img src="https://www.z4a.net/images/2020/05/03/img008.png" alt="img008.png"><br>这也就不难解释一系列的输出值了。<br>需要注意的是，<code>list</code>,<code>set</code>,<code>dict</code>都具有这样的特性，在使用时需要特别注意（其实<code>tuple</code>和<code>str</code>也有这样的特性，只是这两者是不可变的，不涉及更改其中的值的问题）。  </p><h4 id="列表复制"><a href="#列表复制" class="headerlink" title="列表复制"></a>列表复制</h4><p>如果我们想把一个列表赋给另一个变量名，并且希望在更改新的列表时不会影响之前的列表，那么我们可以使用列表的<code>.copy()</code>方法创建列表的复制。  </p><pre><code class="lang-python">&gt;&gt;&gt; a = []&gt;&gt;&gt; b = a.copy()&gt;&gt;&gt; b.append(1)&gt;&gt;&gt; b[1]&gt;&gt;&gt; a[]</code></pre><p>首先创建列表<code>a</code>：<br><img src="https://www.z4a.net/images/2020/05/03/img001.png" alt="img001.png"><br>然后创建列表<code>b</code>，将<code>a</code>的复制赋值给<code>b</code>：<br><img src="https://www.z4a.net/images/2020/05/03/img009.png" alt="img009.png"><br>然后执行<code>b.append(1)</code>：<br><img src="https://www.z4a.net/images/2020/05/03/img010.png" alt="img010.png"><br>这样在改变<code>b</code>的值时，<code>a</code>就不会被影响了；同样的，改变<code>a</code>的值时，<code>b</code>也不会被影响。<br>再来看之前的例子：  </p><pre><code class="lang-python">&gt;&gt;&gt; a = []&gt;&gt;&gt; for i in range(5):...     a.append(0)... &gt;&gt;&gt; l = []&gt;&gt;&gt; for i in range(3):...     l.append(a.copy())... &gt;&gt;&gt; l[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]&gt;&gt;&gt; l[0][3] = 1&gt;&gt;&gt; l[[0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]&gt;&gt;&gt; a[0, 0, 0, 0, 0]</code></pre><p>此时数据的存储方式如下：<br><img src="https://www.z4a.net/images/2020/05/03/img011.png" alt="img011.png">  </p><blockquote><p>其实可以通过更简单的方式创建多维0列表</p><pre><code class="lang-python">l = [[0 for i in range(5)] for j in range(3)]</code></pre></blockquote><p>再来看一个实例：  </p><pre><code class="lang-python">&gt;&gt;&gt; a = [0 for i in range(5)]&gt;&gt;&gt; l = []&gt;&gt;&gt; l.append(a)&gt;&gt;&gt; l.append(0)&gt;&gt;&gt; l[[0, 0, 0, 0, 0], 0]&gt;&gt;&gt; m = l&gt;&gt;&gt; m[1] = 1&gt;&gt;&gt; m[[0, 0, 0, 0, 0], 1]&gt;&gt;&gt; l[[0, 0, 0, 0, 0], 1]&gt;&gt;&gt; n = l.copy()&gt;&gt;&gt; n[1] = 2&gt;&gt;&gt; n[[0, 0, 0, 0, 0], 2]&gt;&gt;&gt; l[[0, 0, 0, 0, 0], 1]&gt;&gt;&gt; n[0][3] = 1&gt;&gt;&gt; n[[0, 0, 0, 1, 0], 2]&gt;&gt;&gt; l[[0, 0, 0, 1, 0], 1]&gt;&gt;&gt; a[0, 0, 0, 1, 0]</code></pre><p>为什么我在创建<code>n</code>的时候明明使用了<code>.copy()</code>，却还是在改变<code>n</code>的时候同时改变了<code>l</code>和<code>a</code>？<br>我们还是来看一下最后的状态下数据存储的方式：<br><img src="https://www.z4a.net/images/2020/05/03/img012.png" alt="img012.png"><br>虽然<code>n</code>确实是复制了<code>l</code>里的所有元素，但是<code>l[0]</code>这一项的值是“指向某一个<code>list</code>”，所以<code>l[0]</code>和<code>n[0]</code>还是指向了同一个<code>list</code>。<br>但是修改<code>n[1]</code>的时候，<code>l[1]</code>并没有一起改变，我们可以将<code>.copy()</code>理解为“只进行了一层复制”。这种复制称为<strong>浅复制</strong>。<br>如果我想创造一个列表，与之前的列表完全一样，但是完全独立，二者互不影响，该怎么办呢？<br>这时我们需要引入<code>copy</code>库来完成这样的操作。<br>（接上述交互式窗口）</p><pre><code class="lang-python">&gt;&gt;&gt; import copy&gt;&gt;&gt; s = copy.deepcopy(l)&gt;&gt;&gt; s[[0, 0, 0, 1, 0], 1]&gt;&gt;&gt; s[0][2] = 3&gt;&gt;&gt; s[[0, 0, 3, 1, 0], 1]&gt;&gt;&gt; l[[0, 0, 0, 1, 0], 1]&gt;&gt;&gt; a[0, 0, 0, 1, 0]</code></pre><p>这时，我们发现改变<code>s</code>的值也不会引起其他变量的变化。<br>存储方式：<br><img src="https://www.z4a.net/images/2020/05/03/img013.png" alt="img013.png"><br>这种复制是对于列表的每一层都进行了复制，所以叫做<strong>深复制</strong>。<br>（更常见的叫法是浅拷贝与深拷贝）  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Experiment #06&lt;br&gt;北航致真书院19级大学计算机基础第六次上机实验实验总结&lt;br&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2019CCBSummary#MT</title>
    <link href="http://sutai.fun/2020/04/26/2019CCBSummary-MT/"/>
    <id>http://sutai.fun/2020/04/26/2019CCBSummary-MT/</id>
    <published>2020-04-25T20:34:00.000Z</published>
    <updated>2020-05-03T07:27:32.974Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Mid-Term Test<br>北航致真书院19级大学计算机基础阶段测试实验总结<br><a id="more"></a></p><h1 id="阶段测试问题汇总"><a href="#阶段测试问题汇总" class="headerlink" title="阶段测试问题汇总"></a>阶段测试问题汇总</h1><hr><h2 id="A-助教机器人"><a href="#A-助教机器人" class="headerlink" title="A.助教机器人"></a><font color=#0033FF>A.助教机器人</font></h2><p>这道题可能有些同学是复制的PDF文件上的句子，导致<code>fi</code>这两个字符被复制成了<code>ﬁ</code>这个奇怪的字符，从而 <strong><font color=#FF0000>WA</font></strong> 掉，着实可惜。<br>在复制文本时，优先复制代码框内部的文本。  </p><h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">s = input()if s == &#39;Why was I right on my machine, but WA on OJ?&#39;:    print(&#39;OJ must be broken!&#39;)elif s == &#39;Why did my code work out the wrong result?&#39;:    print(&#39;Output intermediate variables during running, and find error!&#39;)elif s == &#39;I do not know what data my code would go wrong on!&#39;:    print(&#39;Here may be the data you need!&#39;)else:    print(&#39;Let me have a look.&#39;)</code></pre><p>具体代码部分不需要解释了。如果还有问题请查阅第二次上机实验相关内容。  </p><hr><h2 id="B-自闭程度"><a href="#B-自闭程度" class="headerlink" title="B.自闭程度"></a><font color=#0033FF>B.自闭程度</font></h2><p>同样也是复制的问题，题面上的数字是经过LaTeX渲染后的，里面的字符不一定是我们常用的字符。直接从题面复制的话，会被那个负号坑到。<br>还是上面那句话，优先复制代码框内部的文本。  </p><h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">n, m = map(int, input().split())mark = [0] * n                              # 默认每一道题都没有通过for _ in range(m):    a, b = map(int, input().split())    mark[a-1] = b                           # 直接更新题目状况s = sum(mark)if s == 0:    print(&#39;998244353&#39;)elif s == n:    print(&#39;-998244353&#39;)else:    print(50*n-150*s)</code></pre><p>需要注意的是题目中的前提条件，一道题目在AC后不会再有新的提交记录，所以我们可以直接覆盖更新题目的状况。  </p><hr><h2 id="C-汉诺塔栈"><a href="#C-汉诺塔栈" class="headerlink" title="C.汉诺塔栈"></a><font color=#0033FF>C.汉诺塔栈</font></h2><p>这道题目无论是直接模拟题面的描述还是将其本质问题抽象出来，都是可以完成的。<br>本质问题是冒泡排序，并且输出结果是互换位置的次数。  </p><h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">T = int(input())for _ in range(T):    lnums = list(map(int, input().split()))    count = 0    hanoi = [-1]                            # 防止访问越界，提前添加一个不会混淆的元素，代表汉诺塔底部    stack = []                              # 暂存用的栈，与上面的hanoi均用列表模拟    for plt in lnums:                       # plate，盘子（        while hanoi[-1] != -1 and hanoi[-1] &lt; plt:            stack.append(hanoi.pop())       # 不等于-1是指非底部        hanoi.append(plt)                   # 放入圆盘        while stack != []:                  # 然后把暂存区的圆盘挪回去            hanoi.append(stack.pop())            count += 1                      # 每挪一个都要更新计数器    print(count)</code></pre><p>这个是使用栈直接完成题面的描述，可以看出并不复杂。  </p><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="lang-python">T = int(input())for _ in range(T):    lnums = list(map(int, input().split()))    lenth = len(lnums)    count = 0    flag = True    while flag:                             # 这里就是冒泡排序，注意我们要的是递减序列        flag = False        for i in range(1, lenth):            if lnums[i] &gt; lnums[i-1]:                lnums[i], lnums[i-1] = lnums[i-1], lnums[i]                count += 1                  # 在冒泡排序中加入计数器即可                flag = True    print(count)</code></pre><p>使用冒泡排序的思想。将题面转化为冒泡排序思维量不小，感兴趣的同学可以想一下为什么这道题目是冒泡排序。  </p><hr><h2 id="D-异或序列"><a href="#D-异或序列" class="headerlink" title="D.异或序列"></a><font color=#0033FF>D.异或序列</font></h2><p>本次测试最具有区分度的一道题目，拿<code>0.6</code>分也不用太失落。<br>就像高考数学全国卷必做部分最后一道题一样，这道题的前<code>0.6</code>分就好像第一小问，再往后的<code>0.2</code>分就好像第二小问，最后<code>0.2</code>分就是超难的第三小问。<br>首先再解释一下异或运算。逻辑上的异或运算的法则是<code>A xor B</code>当且仅当<code>A</code>与<code>B</code>逻辑值不同时，运算结果为<code>True</code>，否则为<code>False</code>，可以使用符号<code>⊕</code>表示。真值表如下：<br>A|B|A xor B<br>:-:|:-:|:-:|</p><font color=5ECCFF>True</font>|<font color=5ECCFF>True</font>|<font color=FF5E5E>False</font><font color=5ECCFF>True</font>|<font color=FF5E5E>False</font>|<font color=5ECCFF>True</font><font color=FF5E5E>False</font>|<font color=5ECCFF>True</font>|<font color=5ECCFF>True</font><font color=FF5E5E>False</font>|<font color=FF5E5E>False</font>|<font color=FF5E5E>False</font>  <p>两个正整数间的按位异或则是将两个数转化为二进制，然后<code>0</code>对应<code>False</code>，<code>1</code>对应<code>True</code>，每一位进行异或运算，最后将结果转化为十进制。在<code>python</code>中，按位异或运算符是<code>^</code>，在英文输入法下使用<kbd>Shift</kbd>+<kbd>6</kbd>输入（中文输入法下会输入省略号）。<br>然后是异或运算的一些性质：  </p><blockquote><p>A xor A = 0<br>A xor 0 = A<br>A xor B = B xor A<br>A xor B = 0 iff A = B<br>A xor B = A iff B = 0<br>A xor B = C iff A xor C = B iff B xor C = A<br>(A xor B) xor C = A xor (B xor C)</p></blockquote><p>其中”iff”是”if and only if”的缩写，即“当且仅当”。<br>由于<code>python</code>程序<code>1s</code>内最多运行$10^6$次运算，所以如果想要<font color=#0033FF>AC</font>，则需要将时间复杂度优化为$O(n)$即线性。  </p><h4 id="正确答案（TLE-0-6）"><a href="#正确答案（TLE-0-6）" class="headerlink" title="正确答案（TLE 0.6）"></a><font color=#5ECCFF>正确答案（TLE 0.6）</font></h4><p>这里给出最终得分<code>0.6</code>的暴力解法。  </p><pre><code class="lang-python">def xor(L):    ans = 0    for i in L:        ans ^= i                            # 等价于ans = ans ^ i    return ans                              # 不要换了运算符就不认识了n = int(input())lnums = list(map(int, input().split()))count = 0for i in range(n):    for j in range(i+1, n+1):               # 这里是遍历了每一个可能的区间        if xor(lnums[i:j]) == 0:            count += 1print(count)</code></pre><p>这个时间复杂度是$O(n^3)$，所以对于$100$以内的数据可以在<code>1s</code>内完成。<br>计算时间复杂度时，注意函数的时间复杂度。  </p><h4 id="优化解法（TLE-0-8）"><a href="#优化解法（TLE-0-8）" class="headerlink" title="优化解法（TLE 0.8）"></a><font color=#33EEBB>优化解法（TLE 0.8）</font></h4><p>经过部分优化之后的程序，最终得分<code>0.8</code>.</p><pre><code class="lang-python">n = int(input())lnums = list(map(int, input().split()))count = 0for i in range(n):    xcur = 0    for j in range(i, n):                   # 这样避免重复运算，减少了运算量        xcur ^= lnums[j]        if xcur == 0:            count += 1print(count)</code></pre><p>其实还是直接翻译题面，不过是先固定了区间左端点，然后一次性找出所有满足条件的右端点，再换下一个左端点，避免了很多重复运算。<br><del>实际上并没有用到异或运算的特殊性质。</del><br>这个算法的时间复杂度是$O(n^2)$，所以对于$1000$以内的数据可以在<code>1s</code>内完成。  </p><h4 id="优化解法（AC）"><a href="#优化解法（AC）" class="headerlink" title="优化解法（AC）"></a><font color=#33EEBB>优化解法（AC）</font></h4><p>能够<font color=#0033FF>AC</font>这道题的算法比较难想，我想了半个小时才想出来。要将时间复杂度优化成线性，意味着我们只能够遍历一次序列。由于异或运算良好的性质，我们的运算可以得到很大程度的简化。<br>首先，异或运算同时满足交换律和结合律，这意味着异或运算可以像加法和乘法一样随意交换次序，并且可以从表达式的任何一个地方开始运算。<br>我们将题目给出的序列记为$\left\{ a_{n} \right\}$，如果有$a_i \oplus a_{i+1}\oplus\cdots\oplus a_j=0$，则必有</p><script type="math/tex; mode=display">\forall x,\quad x\oplus a_i\oplus a_{i+1}\oplus\cdots\oplus a_j = x</script><p>则有</p><script type="math/tex; mode=display">a_1\oplus a_2\oplus\cdots\oplus a_j = a_1\oplus a_2\oplus\cdots\oplus a_{i-1}</script><p>所以我们只需要创建出一个序列$\left\{ b_{n} \right\}$,使得$b_i = a_1\oplus a_2 \oplus\cdots\oplus a_i$,那么有如下性质</p><script type="math/tex; mode=display">\exist i,j,\quad b_i=b_j\Rightarrow a_{i+1}\oplus a_{i+2} \oplus\cdots\oplus a_j=0</script><p>为了能够找出使得$b_i=0$的序列，需要规定$b_0=0$,这样就可以将$b_i$与之对应，找到从头开始的满足条件的序列。<br>举两个例子：</p><blockquote><p>有序列<code>1 2 4 5 3 6 4</code><br>我们将$\{a_n\}$和$\{b_n\}$列出来如下<br><code>a: - 1 2 4 5 3 6 4</code><br><code>b: 0 1 3 7 2 1 7 3</code><br>可以注意到$b_1=b_5=1,b_2=b_7=3,b_3=b_6=7$<br>则在$\{a_n\}$中提取对应序列<code>2 4 5 3</code>,<code>4 5 3 6 4</code>和<code>5 3 6</code>，最终找到三个满足条件的序列</p><p>有序列<code>1 2 4 7 3 6 4 2</code><br><code>a: - 1 2 4 7 3 6 4 2</code><br><code>b: 0 1 3 7 0 3 5 1 3</code><br>有$b_0=b_4=0, b_1=b_7=1, b_2=b_5=b_8=3$<br>提取序列<code>1 2 4 7</code>,<code>2 4 7 3 6 4</code>,<code>4 7 3</code>,<code>6 4 2</code>,<code>4 7 3 6 4 2</code>总计五个<br>注意$b_2=b_5=b_8$贡献了$\left(2,5\right],(5,8],(2,8]$三个序列</p></blockquote><p>这样一来，问题就变得简单多了，代码也很短。  </p><pre><code class="lang-python">n = int(input())lnums = list(map(int, input().split()))l = [0] * 100010                            # 创建好足够长的序列，l[i]指数字i在bn中出现过的次数l[0] = 1                                    # b0=0，所以预先添加一个xcur = 0                                    # 用来记录bi的值count = 0for i in lnums:    xcur ^= i                               # 计算bi    count += l[xcur]                        # 这个值出现过几次，则可以匹配到几个新的序列    l[xcur] += 1                            # 出现次数加一print(count)</code></pre><p>对代码的第<code>9</code>行做更详细的说明：<code>count += l[xcur]</code></p><blockquote><p><code>l[x]</code>表示的是目前为止$x$在$\{b_n\}$中出现了几次<br>这时如果再出现一次$x$，则这个$x$可以跟前面每一个$x$都形成一个序列<br>比如上面举的例子中<br><code>a: - 1 2 4 7 3 6 4 2</code><br><code>b: 0 1 3 7 0 3 5 1 3</code><br>在计算到最后一个值时,<code>x=3</code><br>而之前由于<code>3</code>出现了两次，所以<code>l[x]=2</code><br>所以最终结果加<code>2</code>，代表找到了<code>4 7 3 6 4 2</code>和<code>6 4 2</code>两个序列</p></blockquote><p>这个算法的时间复杂度是$O(n)$，所以对于$100000$以内的数据可以在<code>1s</code>内完成。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Mid-Term Test&lt;br&gt;北航致真书院19级大学计算机基础阶段测试实验总结&lt;br&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2019CCBSummary#05</title>
    <link href="http://sutai.fun/2020/04/20/2019CCBSummary-05/"/>
    <id>http://sutai.fun/2020/04/20/2019CCBSummary-05/</id>
    <published>2020-04-19T16:48:12.000Z</published>
    <updated>2020-05-03T07:17:43.263Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Experiment #05<br>北航致真书院19级大学计算机基础第五次上机实验实验总结<br><a id="more"></a></p><h1 id="第五次实验问题汇总"><a href="#第五次实验问题汇总" class="headerlink" title="第五次实验问题汇总"></a>第五次实验问题汇总</h1><hr><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>可能有同学注意到了，后面几次的实验总结少了“错误示范”这个板块。因为现阶段已经很少有能够反映大家共有问题的十分典型的错误代码了，而且哪怕是相同的处理，不同的人写出来的代码也可能大相径庭。所以我删去了这个板块，希望大家在每一道题前面的描述里排除错误。如果出现了典型代码，我还是会放在总结里的。<br>——<em>斯太芬</em></p><hr><h2 id="A-逛超市"><a href="#A-逛超市" class="headerlink" title="A.逛超市"></a><font color=#0033FF>A.逛超市</font></h2><p>这道题目按理来说，不应该使用递归的方法，老老实实迭代才是即好想又好实现还省时省空间的方法。但是递归也可以做，而且不难。<br>常见的问题出在有些同学按照实验指导书上的思路决定递归，但是使用了两个函数分别表示优购和超市发的同学数量。<br>还有一些同学对变量的作用域不太清楚。在这里记住，如果在函数里面要用到函数外的变量，统统<code>global</code>一下就没有问题了，如果想在函数外用到函数里的变量，emmmmmm，尽量不要有这种想法，如果要这样做就作为返回值<code>return</code>给函数外界。  </p><h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">def f(x, y, n):    if n == 1:        return x, y    else:        return f(0.2*x+0.6*y, 0.8*x+0.4*y, n-1)n = int(input())x, y = map(int, input().split())x, y = f(x, y, n)print(int(x), int(y))</code></pre><p>这里，为什么我的函数传了三个参数进去呢？因为事实上，迭代/递归的层数是已知的，而且无法通过去超市发和优购的人数判断递归终止条件，所以传入一个额外的参数来表示递归层数。  </p><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="lang-python">n = int(input())x, y = map(int, input().split())for i in range(n):    x, y = 0.2*x+0.6*y, 0.8*x+0.4*yprint(int(x), int(y))</code></pre><p>大家自行感受一下。  </p><hr><h2 id="B-淡黄的长裙"><a href="#B-淡黄的长裙" class="headerlink" title="B.淡黄的长裙"></a><font color=#0033FF>B.淡黄的长裙</font></h2><p>这道题目是一道比较简单的遍历算法的题目，只需要遍历所有可能的价值取值，然后找出与心理预期差距最小的一个即可。<br>出现的比较多的问题是在一些特殊情况的处理上有一些问题，比如说推到小于4个方块的时候，还有一个问题是题意理解有误。注意题目所说的是那个圈住价格的方框长度为4，你所选的价格不足4位数的情况只可能发生在你把方块推到不足4个，而不是心理预期价位是几位数，方框就能圈住几个方块。  </p><h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">n = int(input())for _ in range(n):    s, p = input().split(&#39;,&#39;)    p = int(p)    s = &#39;0000&#39;+s                        # 提前加4个0避免特判    m = 9999                            # 注意我们要求的是最小值，所以初始值一定要足够大    for j in range(len(s)-4):           # 这里可以看到是从前向后遍历，也就是从推到一个都不剩的时候开始的        t = int(s[j:j+4])               # 字符串切片，对应方框圈住4个方块        if abs(t-p) &lt; m:                # 注意这里不等号的使用            l = j                       # 存储的是找到最小值时的索引            m = abs(t-p)    print(len(s)-l-5)                   # 直接通过先前存储的索引计算输出值，不用再用.index()找索引</code></pre><p>这里不等号的使用主要取决于以下这一点：当你碰到与当前的最大/最小值相等的值的时候，需不需要替换。比如这里，由于我相当于是逆向找解，所以原题要求推方块最多的解，我这里就需要找到的是第一次遇到的解。所以我用的是小于号而不是小于等于号。这样保留的就是第一次遇到的了；如果我是正向找解，也就是模拟游戏过程，从最右边开始4个4个切片，那么我其实是需要保留更靠后的结果的，所以这样的话就需要用小于等于号。<br>关于《Python周报》中提到的一些问题，可以看到Marvolo大佬很喜欢用整型数处理问题，而我给出的代码使用字符串处理问题会多一些。Marvolo是<br>C/C++出身，所以他的代码风格会偏向C/C++一些。这里，我给出的代码，使用的是字符串处理这道题目。但是我并没有任何多余的数据类型转换。我看到很多同学的代码有多余的数据类型转换，这样很费时间，所以转换数据类型的时候，只做必要的部分。而且对于整数进行运算确实比对字符串进行运算要更快，只是目前我们所涉及到的代码还不足以体现这两者的区别。字符串可以帮助我们更直观地理解代码的工作进程，但是在复杂运算的时候，我们还是应该采用整型数据来节约时间。<br>看下面的样例：</p><pre><code class="lang-python">s, p = map(int, input().split(&#39;,&#39;))s = str(s)</code></pre><p>这两行代码可以替换掉我上面的程序的两行代码，效果不变。但是我的代码只进行了一次数据类型转换，而这个代码进行了三次类型转换，而且<code>s</code>这个变量则是先从<code>str</code>转换为<code>int</code>，又转换为了<code>str</code>，明显是多此一举的行为，而且进行一次数据转换的运算量可比进行一次赋值运算要大得多。所以要避免不必要的数据类型转换。  </p><hr><h2 id="C-排列组合"><a href="#C-排列组合" class="headerlink" title="C.排列组合"></a><font color=#0033FF>C.排列组合</font></h2><p>标题是排列组合，其实是组合。典型的深度优先遍历，需要配合全局变量。这里的字典序一定要注意，<code>12</code>作为一个整数元素的时候，是在<code>2</code>之后的。有的同学试图在使用字符串存储结果后用<code>.sort()</code>方法完成排序，但是这样的话<code>&#39;12&#39;</code>按照字符串字典序是在<code>&#39;2&#39;</code>之前的，所以这里不能使用字符串。当然更好的方法就是在遍历的时候就按照字典序一个一个找出来。  </p><h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">def dfs(p):                             # 这里传入的参数p是标记位置的    global mark                         # 定义全局变量    s = sum(mark)                       # 如果选中m个，那么输出这种情况，并结束这个分支    if s == m:        print_()        return    else:        if p &gt;= n:                      # 标记超出边界，结束分支            return        else:            mark[p] = 1                 # 选中标记位置的情况            dfs(p+1)            mark[p] = 0                 # 不选标记位置的情况            dfs(p+1)def print_():    for i in range(n):        if mark[i]:            print(&quot;%d&quot;%(i+1), end=&#39; &#39;)    print()n, m = map(int, input().split())mark = [0 for i in range(n)]            # 0表示没有选，1表示选中dfs(0)                                  # 从第0个位置，也就是1开始选</code></pre><p>单独看代码可能有点难以理解，这里以5选3为例，说明一下过程：  </p><blockquote><p>首先<code>mark</code>是<code>[0, 0, 0, 0, 0]</code>，从左到右分别代表1, 2, 3, 4, 5的选择情况<br>然后看图8<br><img src="https://www.z4a.net/images/2020/04/20/5.jpg" alt="5.jpg"></p></blockquote><pre><code class="lang-python">n, m = map(int, input().split())l = [[i] for i in range(1, n+2-m)]while len(l[0]) &lt; m:    temp = l.pop(0)    s = temp[-1]    for i in range(s+1, n - m + len(temp) + 2):        l.append(temp + [i])for t in l:    for r in t:        print(r, end=&#39; &#39;)    print()</code></pre><p>另一个思路是使用队列，大家可以自行感受一下，比较简单。</p><hr><h2 id="D-买辣条（选做）"><a href="#D-买辣条（选做）" class="headerlink" title="D.买辣条（选做）"></a><font color=#0033FF>D.买辣条（选做）</font></h2><p><del>这道题目是我在吃辣条的时候想出来的</del>，与上一道题目比较相似，不过需要求出全排列。  </p><h4 id="正确答案-3"><a href="#正确答案-3" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">def fp(l):    if len(l) == 1:        return [l]    else:        ans = []        for i in l:            nl = l[:]            nl.remove(i)            xl = fp(nl)            for j in xl:                ans.append([i]+j)        return ansn = int(input())l = list(map(int, input().split()))p = fp([i for i in range(1, n+1)])m = n*nfor i in p:    s = 0    for j in range(n):        s += l[j] % i[j]    if s &lt; m:        m = sprint(m)</code></pre><p>我所给出的方法没有用到全局变量，采用的是一个很容易理解的递归思路，很多同学也是尝试使用这个思路。这样做的话，最后一个数据点的运行时间通常在2000ms以上，内存占用在66000KB以上，是一个对时空要求都比较高的方法。<br>如果使用类似于上一道题目里队列的做法，那么最后一个数据点会<font color=#FF0000>TLE</font>，递归但是常数稍大的也会<font color=#FF0000>TLE</font>，所以最好还是使用类似于上一道题目里的方法。  </p><h4 id="优化解法-1"><a href="#优化解法-1" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="lang-python">def Dfs(x):    global ans,cnt    if (x==n):        ans=min(ans,cnt)        return    for i in range(n):    if (v[i]==0):        v[i]=1        cnt+=a[x]%(i+1)        Dfs(x+1)        cnt-=a[x]%(i+1)        v[i]=0n=int(input())a=list(map(int,input().split()))ans=0x3f3f3f3fcnt=0v=[0 for i in range(n)]Dfs(0)print(ans)</code></pre><p>照抄周报了，大家轻点喷。  </p><h4 id="奇怪的解法"><a href="#奇怪的解法" class="headerlink" title="奇怪的解法"></a><font color=#9966FF>奇怪的解法</font></h4><p>这一部分由于非常超纲，就不放代码了，感兴趣的同学可以自行了解一下。<br>周报中提及的状态压缩动态规划可以解决这道题目，当然整数规划指派问题也可以解决这道题目，这些都是运筹学的内容，不要求大家掌握。  </p><hr><h2 id="E-连锁反应（选做）"><a href="#E-连锁反应（选做）" class="headerlink" title="E.连锁反应（选做）"></a><font color=#0033FF>E.连锁反应（选做）</font></h2><p>我相信很多人看到这道题目的一瞬间，脑袋都有点懵。截止这篇总结编写的时候，只有58个人尝试提交了这道题目，而且这其中还有助教（有可能还有老师）。其实这道题目思路并不难，只是想到这个思路，对于没有软件开发经历的人来说会困难一些。  </p><h4 id="正确答案-4"><a href="#正确答案-4" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><p>先给出思路。题目中叫做消除，我个人更喜欢叫引爆。我们需要做的就是在棋盘上引爆某一个道具，然后看看最终会变成什么样子。<br>既然我们做的只是引爆某一个道具，然后这个道具可能会引爆别的道具，那么我们只需要编写一个可以适用于所有道具的“引爆函数”即可。对于普通的<code>0123456789</code>，引爆就是把它们替换成空格（或者任意一个不会引起歧义的符号均可，便于之后的操作）；对于一个特殊道具，引爆这个道具则不仅仅要把它替换成空格，还要对其他的一些道具进行引爆操作。这样的话，一个递归思路的函数就出来了。  </p><pre><code class="lang-python">a, b = map(int, input().split(&#39;,&#39;))board = []                              # 面板，直白一点的命名多好for i in range(b):    board.append(list(input()))x, y = map(int, input().split(&#39;,&#39;))num = &#39;0123456789&#39;alp = &#39;QWERTYUIOP&#39;                      # 存储消除特定数字的道具def explo(x, y):                        # explose引爆    if x not in range(a) or y not in range(b):        return                          # 对于会越界的操作，终止掉，在引爆X时有可能会越界    global board                        # 注意全局变量    curr = board[y][x]                  # current,用于存放当前值的一个常用变量名    if curr == &#39; &#39;:        return    else:        board[y][x] = &#39; &#39;               # 因为已经存到了curr，而且无论如何这一格都要变成空格    if curr in num:        return    if curr == &#39;v&#39;:        for i in range(b):              # 对这一列所有元素进行引爆            explo(x, i)    if curr == &#39;&gt;&#39;:        for i in range(a):              # 对这一行所有元素进行引爆            explo(i, y)    if curr == &#39;X&#39;:        for i in (y-1, y, y+1):         # 对九宫格进行引爆，因为之前有判断，所以不用担心越界            for j in (x-1, x, x+1):                explo(j, i)    if curr in alp:        t = num[alp.index(curr)]        for i in range(a):              # 遍历面板，对特定数字进行引爆            for j in range(b):                if board[j][i] == t:                    explo(i, j)explo(x-1, y-1)                         # 注意坐标起始值for i in range(a):                      # 这里进行落下的操作，可以写成很多种样子，我这里稍显繁琐    count = 0    temp = []    for j in range(b):        if board[j][i] == &#39; &#39;:            count += 1        else:            temp.append(board[j][i])    temp = [&#39; &#39;]*count + temp    for j in range(b):        board[j][i] = temp[j]for i in range(b):    print(&#39;&#39;.join(board[i]))</code></pre><p>关于引爆<code>X</code>越界，当<code>X</code>在面板边界的时候，会发生越界，所以函数开头需要验证一下。<br>有一点需要注意的地方，这道题目使用的是原点在左上角的xOy坐标轴记录位置信息，与我们平时比较常用的“第x行第y列”有所不同，所以在传参和访问元素的时候一定记得核实变量顺序。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Experiment #05&lt;br&gt;北航致真书院19级大学计算机基础第五次上机实验实验总结&lt;br&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2019CCBSummary#04</title>
    <link href="http://sutai.fun/2020/04/13/2019CCBSummary-04/"/>
    <id>http://sutai.fun/2020/04/13/2019CCBSummary-04/</id>
    <published>2020-04-12T18:44:21.000Z</published>
    <updated>2020-05-03T07:51:30.802Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Experiment #04<br>北航致真书院19级大学计算机基础第四次上机实验实验总结<br><a id="more"></a></p><h1 id="第四次实验问题汇总"><a href="#第四次实验问题汇总" class="headerlink" title="第四次实验问题汇总"></a>第四次实验问题汇总</h1><hr><p>本次试验中需要用到栈和队列这两种数据结构。为了演示自定义类的实际应用，这篇总结的A.C.E三道题均使用了<code>class Stack():</code>的自定义类来存储栈结构。现给出栈的定义。  </p><pre><code class="lang-python">class Stack():    def __init__(self):        self.items = []    def push(self, item):        self.items.append(item)    def pop(self):        if self.is_empty():            raise Exception(&#39;stackIsEmpty&#39;)        else:            return self.items.pop()    def peek(self):        if self.is_empty():            raise Exception(&#39;stackIsEmpty&#39;)        else:            return self.items[-1]    def is_empty(self):        return self.items == []    def size(self):        return len(self.items)</code></pre><hr><h2 id="A-修电脑"><a href="#A-修电脑" class="headerlink" title="A.修电脑"></a><font color=#0033FF>A.修电脑</font></h2><p>经典的使用堆栈处理指令的题目，只需要根据输入决定入栈还是出栈即可。<br>需要注意的是，题目中并没有说指令只有一个字母！所以逐字符读取和使用了<code>.isalpha()</code>的都是思路跑偏了，实际上不复杂。  </p><h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">n = int(input())commands = Stack()                              # 实例化for i in range(n):    com = input()    if com == &#39;Ctrl+Z&#39;:                         # 判断指令是否为撤销        commands.pop()    else:        commands.push(com)print(&quot;/&quot;.join(commands.items))                 # 使用self.items可以直接访问items对象# 最后输出时，可以直接访问类中创建的列表，也可以逐一进行pop操作后逆序输出。</code></pre><p><code>.join()</code>是非常实用的方法，希望大家都可以掌握。  </p><hr><h2 id="B-老千层饼"><a href="#B-老千层饼" class="headerlink" title="B.老千层饼"></a><font color=#0033FF>B.老千层饼</font></h2><p>题目的本意是使用队列来从小到大存储“千层饼”。有的同学在生成新“千层饼”并传入的时候没有将已经用过的千层饼删除，这样有两个问题。其一是如果是删除后再填进去的话，会有很多的重复；第二是即便没有重复，当<code>n</code>值很大的时候，列表会变得非常长，这样在访问靠后的元素的时候会非常浪费时间，从而导致<font color=#FF0000>TLE</font>.<br>有的同学在按数位依次递减的时候，减到了0以下，产生了<code>2100-10</code>这样的奇怪输出。  </p><h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><p>暴力解法，注意不优化的话会<font color=#FF0000>TLE</font>，需要一定程度的优化。  </p><pre><code class="lang-python">n = int(input())if 1&lt;=n&lt;=12:    print(n)else:    n -= 12    i = 20    flag = False    while n:                                    # 这里写成 while n!=0: 更容易理解        if flag:            i += 9            flag = False        else:            i += 1        s = str(i)        if ord(s[-1])-ord(s[-2]) == 1:          # 末两位递增，可以一次排除掉8个非千层饼            flag = True        for j in range(len(s)-1):               # 对每相邻的两位进行判断            if abs(ord(s[j])-ord(s[j+1])) &gt; 1:                break        else:                                   # 找到一个千层饼，n-1            n -= 1    print(i)</code></pre><p>不难看出，如果一个“千层饼”是以“67”这种严格增序列结尾的，那么下一个“千层饼”一定是+9之后的产物，这样可以优化枚举的过程，从而在规定时间内完成输出。  </p><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="lang-python">n = int(input())nums = [i for i in range(1, 10)]                # 模拟队列while n:    a = nums.pop(0)    d = a % 10    if d == 0:                                  # 通过末尾的数字判断添加的数        nums.append(10*a)        nums.append(10*a+1)    elif d == 9:        nums.append(10*a+8)        nums.append(10*a+9)    else:        nums.append(10*a+d-1)        nums.append(10*a+d)        nums.append(10*a+d+1)    n -= 1print(a)# 这道题目的答案应该很好理解，如果实在难以理解不妨仿照这个程序在纸上画一画。</code></pre><p>本题的原意是使用队列完成。<br>在这里画出前几次吧，便于大家理解。  </p><blockquote><p>[1, 2, 3, 4, 5, 6, 7, 8, 9]<br>[<del>1</del>, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]<br>[<del>1</del>, <del>2</del>, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 21, 22, 23]<br>[<del>1</del>, <del>2</del>, <del>3</del>, 4, 5, 6, 7, 8, 9, 10, 11, 12, 21, 22, 23, 32, 33, 34]</p><p><del>这些是看到实验指导书之前写的，没想到指导书直接给出了这个。</del>  </p><h4 id="奇怪的解法"><a href="#奇怪的解法" class="headerlink" title="奇怪的解法"></a><font color=#9966FF>奇怪的解法</font></h4><p>由于我刚开始会错了题意，于是诞生了这个稍显奇怪的使用栈完成的程序。</p><pre><code class="lang-python">n = int(input())S = [-2, 1]                                     # 模拟栈，并提前压入两个数据，其中-2用于标记首位，防止越界digits = 1                                      # 该栈存储的是各个位上的数字for i in range(n-1):                            # 每经过一次循环，栈内存的数字就表示下一个更大的千层饼    dpopped = 1    t = S.pop()                                 # 取末尾数字    while ((t == 9) or (t == S[-1]+1)) and S[-1] != -2:        dpopped += 1                            # 末尾数字达到9或者比次末位大1，则需要进位        t = S.pop()                             # dpopped记录需要进位的位数    if S[-1] == -2:                             # 这里判断是否要改变首位        if t == 9:                              # 首位是9，则变成1000...            S += [1]+[0]*digits            digits += 1        else:                                   # 否则首位加一，后续依次递减            S.append(t+1)            for j in range(digits-1):                S.append(max(t-j,0))            # 注意此处max()函数的使用，不要减到0以下    else:        for j in range(dpopped):                # 从右向左第一个不用进位的数位+1，向后依次递减            S.append(max(t+1-j,0))              # 此处也是S.pop(0)                                        # 把-2删掉for i in S:    print(i, end=&#39;&#39;)</code></pre></blockquote><p>另外，此题可打表，但是打表完全是为了做题而做题，完全不能体现题目价值。  </p><hr><h2 id="C-破解虫洞"><a href="#C-破解虫洞" class="headerlink" title="C.破解虫洞"></a><font color=#0033FF>C.破解虫洞</font></h2><p>这道题目本质上是前缀表达式。由于题目保证所有数字都是一位数，所以可以安心地逐个读取字符。<br>所谓前缀表达式，是将运算符放到数据之前，这样不需要括号来规定运算顺序也不会产生歧义。<br>与之对应的有后缀表达式以及我们常用的中缀表达式。<br>简单来讲，中缀表达式中<code>2 - 1</code>使用前缀表达式表示为<code>- 2 1</code>，使用后缀表达式表示为<code>2 1 -</code>；<br>稍复杂的例子如下：  </p><blockquote><p>举例：<br>中缀表达式：<code>3*(6+4*(5-3))-2</code><br>计算过程：<code>3*(6+4*(5-3))-2 = 3*(6+4*2)-2 = 3*(6+8)-2 = 3*14-2 = 42-2 = 40</code></p><hr><p>前缀表达式：<code>- * 3 + 6 * 4 - 5 3 2</code><br>计算过程： <strong>从后向前</strong> 依次读取入栈，读取到运算符时出栈两次并执行操作， <strong>顺序为（顶元素 操作 次顶元素）</strong> ，然后将结果入栈。<br>（个人喜欢用竖杠表示栈底，意为此处不可进出元素）<br>先依次入栈，得到<code>|2, 3, 5</code><br><code>|2, 3, 5</code>，当前元素<code>-</code>，剩余未读取<code>- * 3 + 6 * 4</code><br>出栈两次，执行<code>- 5 3</code>，结果为<code>2</code>，入栈<br><code>|2, 2</code>，当前元素<code>4</code>，剩余未读取<code>- * 3 + 6 *</code><br>入栈直至读取到运算符，此时<br><code>|2, 2, 4</code>，当前元素<code>*</code>，剩余未读取<code>- * 3 + 6</code><br>出栈两次，执行<code>* 4 2</code>，结果为<code>8</code>，入栈<br><code>|2, 8</code>，当前元素<code>6</code>，入栈，剩余未读取<code>- * 3 +</code><br><code>|2, 8, 6</code>，当前元素<code>+</code>，剩余未读取<code>- * 3</code><br><code>|2, 14</code>，当前元素<code>3</code>，入栈，剩余未读取<code>- *</code><br><code>|2, 14, 3</code>，当前元素<code>*</code>，剩余未读取<code>-</code><br><code>|2, 42</code>，当前元素<code>-</code>，执行最后一次操作，得到最终结果<code>40</code></p><hr><p>后缀表达式：<code>3 6 4 5 3 - * + * 2 -</code><br>计算过程： <strong>从前向后</strong> 依次读取入栈，读取到运算符时出栈两次并执行操作， <strong>顺序为（次顶元素 操作 顶元素）</strong> ，然后将结果入栈。<br>先依次入栈，得到<code>|3, 6, 4, 5, 3</code><br>然后读取到<code>-</code>，出栈两次，执行<code>5 3 -</code>，结果为<code>2</code>，入栈<br><code>|3, 6, 4, 2</code>，当前元素<code>*</code>，剩余未读<code>+ * 2 -</code><br>出栈两次，执行<code>4 2 *</code>，结果为<code>8</code>，入栈<br><code>|3, 6, 8</code>，当前元素<code>+</code>，剩余未读<code>* 2 -</code><br><code>|3, 14</code>，当前元素<code>*</code>，剩余未读<code>2 -</code><br><code>|42</code>，当前元素<code>2</code>，剩余未读<code>-</code><br><code>|42, 2</code>，最后一个操作符<code>-</code>，执行<code>42 2 -</code>，得到最终结果<code>40</code></p><h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><p>当然，如果不了解前缀表达式的话，不容易想到从后向前读取的方法。这里提供一个从前向后读取的方法。<br>思路就是函数符号和数字依次入栈，当栈顶两元素均为数时，运行栈顶三个元素组成的函数并入栈。当数据读完之后，栈内仅剩一个元素，即最终结果。<br>```python<br>def f(x, y):<br>    return (x + 42<em>y) / (42</em>x + y)</p></blockquote><p>def g(x, y):<br>    return (x<em>y) / (42</em>x - 42*y)</p><p>coms = Stack()                                  # 实例化<br>s = input().replace(‘(‘, ‘’).replace(‘)’, ‘’).replace(‘,’, ‘’)<br>for c in s:                                     # 删掉括号和逗号<br>    if c.isdigit():<br>        while coms.peek() not in ‘fg’:          # 判断是否连续两个数字<br>            temp = coms.pop()                   # 因为有可能运算完成之后仍然是连续两个数字<br>            opr = coms.pop()                    # 所以需要用while循环<br>            if opr == ‘f’:<br>                temp = str(f(float(temp), float(c)))<br>            else:<br>                temp = str(g(float(temp), float(c)))<br>            c = temp<br>            if coms.is_empty():                 # 当栈为空说明运算完成了，提前跳出避免报错<br>                break<br>    coms.push(c)<br>print(“%.7f”%float(coms.pop()))</p><pre><code>#### &lt;font color=#33EEBB&gt;优化解法&lt;/font&gt;```pythondef f(x, y):    return (x + 42*y) / (42*x + y)def g(x, y):    return (x*y) / (42*x - 42*y)coms = Stack()                                  # 实例化s = list(input())                               # 使用list是为了后续使用.reverse()方法s.reverse()                                     # 逆序便于完成从后向前读取for c in s:    if c.isdigit():                             # 将数字入栈        coms.push(int(c))    elif c == &#39;f&#39;:                              # 遇到函数符则将栈顶两元素弹出，运算后入栈        coms.push(f(coms.pop(), coms.pop()))    # 要注意出栈顺序    elif c == &#39;g&#39;:        coms.push(g(coms.pop(), coms.pop()))print(&quot;%.7f&quot;%coms.pop())</code></pre><blockquote><p>首先明确一点，括号和逗号并不能影响运算，所以我们将其排除。<br>然后使用样例举例:<code>f(9, g(f(5, 2), 7))</code><br>去掉括号后变成<code>f, 9, g, f, 5, 2, 7</code><br>逆序之后变成<code>7, 2, 5, f, g, 9, f</code><br>然后从前向后读取。首先读到<code>7, 2, 5</code>，均入栈。此时栈内元素为<br><code>|7, 2, 5</code><br>然后读取到<code>f</code>，则出栈两次，依次得到<code>5</code>，<code>2</code>，然后施加<code>f(x, y)</code>函数<br>将函数的返回值<code>f(5, 2)</code>入栈。此时栈内元素为<br><code>|7, f(5, 2)</code><br>然后读到<code>g</code>，出栈两次得到<code>f(5, 2)</code>和<code>7</code>，施加<code>g(x, y)</code>函数，将返回值入栈。此时栈内元素为<br><code>|g(f(5, 2), 7)</code><br>然后读取<code>9</code>，入栈，栈内元素为<br><code>|g(f(5, 2), 7), 9</code><br>最后读到<code>f</code>，出栈两次后运算，结果入栈。此时栈内仅剩一个元素<br><code>|f(9, g(f(5, 2), 7))</code>，即为最终结果。</p><h4 id="奇怪的解法-1"><a href="#奇怪的解法-1" class="headerlink" title="奇怪的解法"></a><font color=#9966FF>奇怪的解法</font></h4><p>```python<br>def f(x, y):<br>    return (x + 42<em>y) / (42</em>x + y)</p></blockquote><p>def g(x, y):<br>    return (x<em>y) / (42</em>x - 42*y)</p><p>print(“%.7f”%eval(input()))</p><pre><code>很不幸，我一直强调的不要使用的`eval()`函数可以轻松解决这道题目（并且使这道题目失去其原有价值）。但是如此这般使用`eval(input())`仅限于OJ题目测评，因为这样的形式会使得代码的强壮程度急剧下降， **非常不建议直接在`input()`外套用`eval()`函数！**   **&lt;font color=#FF0000&gt;实验报告上不要出现这个解法！&lt;/font&gt;**  - - -## &lt;font color=#0033FF&gt;D.合理复习（选做）&lt;/font&gt;这道题又是构造类题目，代码不难，难在思维上。只需要明白可供复习的时间总长大于等于需要的时间总长就一定可以给出一个复习方案。我们只需要证明用$1$到$n$的所有正整数可以从中挑出若干不重复的整数，使之和为$\left[ 1, \frac &#123;n \left( n+1 \right)&#125;&#123;2&#125; \right]$中任意一个整数即可。  具体构造方法如下：  &gt; 对于$\left[1, n\right]$中的整数，直接取自身即可；&gt; 对于接下来的$\left[n+1, n+\left(n-1\right)\right]$中的整数，取$n$，再从剩下的数中取一个即可；&gt; 对于接下来的$\left[n+\left(n-1\right)-1, n+\left(n-1\right)+\left(n-2\right)\right]$中的整数，取$n$和$n-1$，再取剩下的数中的一个；&gt; 以此类推即可证明以上结论。  因此这道题就变成了找到最小的$n$，使得$\sum^&#123;n&#125;_&#123;i=1&#125; i \ge x$.  #### &lt;font color=#5ECCFF&gt;正确答案&lt;/font&gt;```pythona, b = map(int, input().split())s = (a+b)*2i = 1while True:    if (i*(i+1)&gt;=s):        print(i)        break    i += 1# 通过枚举的方法正向找到解，注意压常数</code></pre><h4 id="优化解法-1"><a href="#优化解法-1" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="lang-python">import math as ma, b = map(int, input().split())c = a + bn = (m.sqrt(8 * c + 1) - 1) / 2print(m.ceil(n))# 求公式反向求解</code></pre><script type="math/tex; mode=display">\frac {n(n+1)}{2} \ge x \Rightarrow n = \left\lceil \frac{\sqrt{8x+1}-1}{2} \right\rceil</script><hr><h2 id="E-复杂相对分子质量（选做）"><a href="#E-复杂相对分子质量（选做）" class="headerlink" title="E.复杂相对分子质量（选做）"></a><font color=#0033FF>E.复杂相对分子质量（选做）</font></h2><p>这道题目的答题思路是使用栈进行数据存储和运算。读取到元素符号则将其原子量压入，读取到左括号直接压入，读取到数字则弹出栈顶元素，乘上数字后再压入，读取到右括号则弹出至左括号，将弹出的数据全部相加再压入，最后栈内剩下的唯一元素则是最终结果。<br>有的同学在一开始删除了所有的括号，可能是受到了破解虫洞那道题的影响。 <strong>这道题目的括号会对最终结果产生影响，所以不能删去括号！</strong>  </p><h4 id="正确答案-3"><a href="#正确答案-3" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">c = input() + &#39;/&#39;                               # 为了能够录入最后一个数，在末尾添加一个符号s = Stack()                                     # 实例化temp = &#39;&#39;                                       # 用于存放数字，因为不保证数都是一位，所以需要这个变量Ar=&#123;&#39;H&#39;:1.007, &#39;C&#39;:12.011,                      # 字典，存放原子量    &#39;N&#39;:14.007, &#39;O&#39;:15.999&#125;for ch in c:                                    # 逐字符遍历    if not ch.isdigit():                        # 如果不是数字，这里也可以写 if ch.isdigit() == 0:        if temp != &#39;&#39;:                          # temp非空说明需要将前一个原子的原子量乘以乘数            m = s.pop()            s.push(int(temp) * m)            temp = &#39;&#39;                           # 注意清空temp    else:                                       # 如果是数字，则暂存进temp        temp += ch        continue                                # 并且不用进行后续处理    if ch == &#39;(&#39;:                               # 左括号直接压栈        s.push(ch)        continue                                # 此处不写continue，后续使用elif也是可以的    if ch in Ar.keys():                         # 如果是元素符号        s.push(Ar[ch])                          # 则压入原子量        continue    if ch == &#39;)&#39;:                               # 如果是右括号        sum_ = 0                                # 循环变量赋初值        while s.peek() != &#39;(&#39;:                  # 不断弹出直至遇到左括号            sum_ += s.pop()                     # 累加弹出的值        s.pop()                                 # 弹出左括号        s.push(sum_)                            # 压入总和ans = 0while s.is_empty() == 0:                        # 栈内剩余元素的和即为答案    ans += s.pop()print(&quot;%.2f&quot;%ans)</code></pre><h4 id="优化解法-2"><a href="#优化解法-2" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="lang-python">c = &#39;(&#39; + input() + &#39;)&#39;    &lt;code block&gt;print(&quot;%.2f&quot;%s.pop())# 直接在最外侧加上括号，就可以直接在循环内加和，不需要最后单独加和</code></pre><pre><code class="lang-python">Ar=&#123;&#39;H&#39;:1007, &#39;C&#39;:12011,     &#39;N&#39;:14007, &#39;O&#39;:15999&#125;    &lt;code block&gt;print(&quot;%.2f&quot;%(ans/1000))# 使用整型数运算避免精度问题。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Experiment #04&lt;br&gt;北航致真书院19级大学计算机基础第四次上机实验实验总结&lt;br&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2019CCBSummary#03</title>
    <link href="http://sutai.fun/2020/04/13/2019CCBSummary-03/"/>
    <id>http://sutai.fun/2020/04/13/2019CCBSummary-03/</id>
    <published>2020-04-12T18:44:18.000Z</published>
    <updated>2020-05-03T07:46:13.565Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Experiment #03<br>北航致真书院19级大学计算机基础第三次上机实验实验总结<br><a id="more"></a></p><h1 id="第三次实验问题汇总"><a href="#第三次实验问题汇总" class="headerlink" title="第三次实验问题汇总"></a>第三次实验问题汇总</h1><hr><h3 id="写在前面，并且希望大家认真地读一下"><a href="#写在前面，并且希望大家认真地读一下" class="headerlink" title="写在前面，并且希望大家认真地读一下"></a>写在前面，并且希望大家认真地读一下</h3><p>第二次上机实验，大家的答题情况不甚理想，基于这个情况，第三次上机实验的题目难度相比往届有所下降。但是这一次实验，大家的答题效果仍然不理想。群里面问问题的同学并不算多，而且有很多之前就讲过的问题。其实对于我而言，本次实验题目里出现的易错点多问我几次，我倒也是无所谓，可能同学们没有意识到自己的代码问题出在哪里，掉进了哪个坑，我作为助教还是很乐意去引导同学们走出坑的。但是对于一些应当在第一次实验或者第二次实验就掌握的知识点，我在被反复问到这些问题的时候，难免会觉得有些难受。所以为了提高大家的学习效率和独立解决问题的能力，我写了这段话，希望每位同学都能仔细地读一下这段话。<br>这学期到目前为止都是网上授课，可能对于其他科目而言是比较难受的，但是对于这门课程我认为更加便利。因为在老师讲课的过程中，同学们可以随时在本地进行测试，以便在课堂上掌握新知识。OJ系统上17级的部分题目大家都可以查看到，老师也督促过大家完成那些题目。大家要稍微多做一点题目，旨在熟悉Python的各种操作，包括基本语法，调试技巧等等。如果觉得OJ系统上的题目不够，可以在洛谷等网站上找题目。<br>接下来说的就是跟上机实验关系很紧密的事情。可能这学期没有助教手把手的指导实验，而是单纯在线针对代码进行答疑，所以有一些东西没有传达到。一下说的几点，我希望大家能够谨记于心。  </p><ul><li>虽然目前还没有涉及到较复杂的算法的题目，但是只要没有120%的把握能够十分顺利地写代码，<strong>请把草稿纸和笔放在面前。</strong> 在拿到题目的时候，用自己特有的方式在纸上记录下你的思路。比如需要什么变量，第一步怎么处理变量，怎么分支之类的；  </li><li><strong>仔细读题！</strong> 尤其是加粗的部分。命题人出题的初衷是为了锻炼大家的编程能力，而非特意给大家在题目描述挖坑，所以重要的部分都会<strong>加粗表示！</strong> 而且请读题的时候读完整。所谓读完整，是将题目描述，输入，输出，输入样例，输出样例，样例解释和Hint都仔细阅读。有时输入里面会有“保证输入数据只有数字和字母”的字样，这个的意思是命题人保证用于检测你的程序的数据在他所描述的范围内，大家在编程的时候就不需要考虑不在输入范围内的数据处理了。  </li><li><strong>要养成独立解决问题的能力。</strong> 助教们和老师反复说过一句话，考试的时候没有人答疑。而考试前面的这些上机实验，当然也有培养同学们独立解决问题能力的目的。代码WA了或者报错了之后第一个想到的不能是助教或者老师，也不能是别的同学，而应该是自己。当出现问题时，先检查有没有语法问题。请善用课件、实验指导和错题本，如果之前的知识点忘记了，请翻看之前的实验指导或者自己的实验报告。  </li><li><strong>要学会看程序的报错。</strong> Python在报错的时候，会显示好几行。前面的几行是告诉你问题大概出在哪里，这个是指<strong>编译器在编译到这里的时候发现了问题，而不一定是指问题出在这里，</strong> 所以你有时需要往前面看几行才能发现问题。再往下一行，会显示<code>xxx: xxxxxxxx.</code>之类的一句话。其中前面的是报错的类别，后面的是具体的错误。读懂报错不需要太强的英语能力，最多是几个单词不认识，请善用百度翻译。</li><li><strong>本地测试通过了不能说明代码没有问题！</strong> 本地测试通过了只能说明你的代码没有语法错误，请自行构造其他满足输入条件的数据进行测试。在构造条件时请多构造一些奇怪的数据，要抱着“怎么能让我的代码出错”的心态测试自己的程序。如果OJ上得了接近满分，则一般是特殊情况或者临界值没有考虑到，请加强对临界值或特殊情况的判断。  </li><li><strong><font color=#FF0000>WA=Wrong Answer, TLE=Time Limit Exceed, PE=Presentation Error.</font></strong> PE一般是空白符输出有问题，输出字母大小写有问题。TLE一般是时间复杂度过高或者出现死循环。有关时间复杂度的相关知识请参阅往期由 <strong><font color=0088BB>Marvolo大佬</font></strong> 编撰的《Python周报》。出现死循环则一般是由<code>while</code>循环引起的。如果在本地运行时发生死循环，请使用<kbd>Ctrl</kbd>+<kbd>C</kbd>强制终止程序。一般不会遇到其他OJ报错。如果遇到CE，检查自己提交的语言是否为Python3.  </li><li><strong>写代码要细心，注意检查语法问题。</strong> 很多人在编程的时候漏掉了函数和方法后的括号。<strong>函数和方法只有在加括号之后才表示调用，不加括号表示的是函数本身！</strong> 所以哪怕这个函数或方法不需要传参数，也请务必带上括号。<blockquote><p>举例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="built_in">bin</span>, <span class="built_in">oct</span>, <span class="built_in">hex</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line"><span class="meta">... </span>    print(i(<span class="number">16</span>))</span><br><span class="line">...</span><br><span class="line"><span class="number">0b10000</span></span><br><span class="line"><span class="number">0o20</span></span><br><span class="line"><span class="number">0x10</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">在定义`a`时，函数没有加括号，所以列表`a`里的元素是函数自身！这时循环变量`i`就是函数，所以可以通过`i(<span class="number">16</span>)`来实现`<span class="built_in">bin</span>(<span class="number">16</span>), <span class="built_in">oct</span>(<span class="number">16</span>), <span class="built_in">hex</span>(<span class="number">16</span>)`的计算。  </span><br><span class="line">这就是`isalpha()`的括号丢掉就不能正常运行了的原因。  </span><br><span class="line">+ 如果实在是难以独立解决问题，请向他人求助。优先在小组群和答疑群求助。**求助时请将自己的代码截图发出，行标号截全，说清楚自己的代码目前是什么情况（有报错/无报错但输出不对/样例过了但是没有AC），前两种请把控制台相关输出截图，最后一种附上OJ反馈和得分。** 尽量使用截图功能，避免用手机拍摄屏幕！（Win10系统可以使用&lt;kbd&gt;Win&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;S&lt;/kbd&gt;快速打开自带截图软件，或者使用QQ自带的截图工具）  </span><br><span class="line">+ 最后，在获得别人的帮助之后， **请更新错题本。** 这样大家在遇到同样的问题时就可以通过错题本来解决自己的问题了。  </span><br><span class="line"></span><br><span class="line">时刻谨记，本门课程所教授的不仅仅是如何编写Python程序，更重要的是计算思维以及自我解决问题的能力。  </span><br><span class="line">我十分希望大家能够享受这门课程，我也会尽自己的能力帮助大家学好这门课程。  </span><br><span class="line"></span><br><span class="line">*斯太芬 写于 <span class="number">04</span>/<span class="number">04</span>/<span class="number">2020</span>*</span><br><span class="line">- - -</span><br><span class="line"><span class="comment">## &lt;font color=#0033FF&gt;A.利息计算&lt;/font&gt;</span></span><br><span class="line">需要注意题目并没有提到每期摊还的本金一定是整数，所以不要使用地板除。另外涉及到浮点数的判断时，受精度问题影响，不要直接使用`==`或者`!=`来判断，否则容易无法跳出循环。如果循环次数已知，则使用`<span class="keyword">for</span>...`循环完成；如必须使用`<span class="keyword">while</span>`，则使用诸如`<span class="keyword">while</span> <span class="built_in">abs</span>(x-y)&lt;<span class="number">0.000001</span>:`或者`<span class="keyword">while</span> <span class="built_in">abs</span>(x-y)&gt;<span class="number">0.000001</span>:`这样的形式。  </span><br><span class="line"><span class="comment">#### &lt;font color=#FF5E5E&gt;错误示范&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">while</span> N != <span class="number">0</span>:</span><br><span class="line"><span class="comment"># 在遇到某些数据，比如本金100分17期还的时候，N可能会十分接近但不等于0，从而无法跳出循环</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">#### &lt;font color=#5ECCFF&gt;正确答案&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line">N = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">t = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">i = <span class="built_in">float</span>(<span class="built_in">input</span>()) / <span class="number">100</span>                    <span class="comment"># 不要忘记输入的是百分数</span></span><br><span class="line">M = N</span><br><span class="line">n = N / t                                   <span class="comment"># N/t不一定是整数，不要使用地板除//</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(t):                          <span class="comment"># 循环次数已知时，尽量不要使用while</span></span><br><span class="line">   M += N * i</span><br><span class="line">   N -= n</span><br><span class="line">print(<span class="string">&quot;%.2f&quot;</span>%M)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"><span class="comment">## &lt;font color=#0033FF&gt;B.快速傅里叶变换&lt;/font&gt;</span></span><br><span class="line">考察使用列表处理数据的能力。  </span><br><span class="line">以下是常见问题：  </span><br><span class="line">+ 没有对访问越界的情况进行处理</span><br><span class="line">+ 使用`.join()`方法有误，没有传入正确的参数</span><br><span class="line"></span><br><span class="line"><span class="comment">#### &lt;font color=#FF5E5E&gt;错误示范&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line">m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">lm = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">ln = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">lans = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + n - <span class="number">1</span>):</span><br><span class="line">   s = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>):</span><br><span class="line">       s += lm[j] * ln[i - j]</span><br><span class="line">   lans.append(s)</span><br><span class="line">print(<span class="string">&#x27; &#x27;</span>.join(lans))</span><br><span class="line"><span class="comment"># 访问列表的时候显然会越界</span></span><br><span class="line"><span class="comment"># 最后一行.join()方法传参有误</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">使用`.join()`方法时要注意其参数是一个 **仅包含字符串的列表** ，而本题中我们最终得到的列表元素均是整型数，所以不能直接使用`.join()`，使用`<span class="keyword">for</span>...`语句循环输出反而更容易理解一些。  </span><br><span class="line"><span class="comment">#### &lt;font color=#5ECCFF&gt;正确答案&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line">m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">lm = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">ln = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">lans = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + n - <span class="number">1</span>):</span><br><span class="line">   s = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>):</span><br><span class="line">       <span class="keyword">if</span> j &gt;= m:                          <span class="comment"># 如果有一项超出原列表范围</span></span><br><span class="line">           <span class="keyword">continue</span>                        <span class="comment"># 那么这一项乘积必定是0</span></span><br><span class="line">       <span class="keyword">if</span> i-j &gt;= n:                        <span class="comment"># 所以使用continue跳过这次循环即可</span></span><br><span class="line">           <span class="keyword">continue</span>                        <span class="comment"># 注意这个continue只对最近一层循环奏效</span></span><br><span class="line">       s += lm[j] * ln[i - j]</span><br><span class="line">   lans.append(s)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> lans:                              <span class="comment"># for语句看着很清楚</span></span><br><span class="line">   print(k, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">#### &lt;font color=#33EEBB&gt;优化解法&lt;/font&gt;</span></span><br><span class="line">如果真的想使用`.join()`方法，看这个解法的最后一行。尝试理解这套操作。  </span><br><span class="line">```python</span><br><span class="line">m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">lm = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) + [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>)]</span><br><span class="line">ln = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) + [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>)]</span><br><span class="line">lans = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + n - <span class="number">1</span>):</span><br><span class="line">   s = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>):</span><br><span class="line">       s += lm[j] * ln[i - j]</span><br><span class="line">   lans.append(s)</span><br><span class="line">print(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, lans))))       <span class="comment"># 使用了字符串的.join()方法</span></span><br><span class="line"><span class="comment"># 提前在末尾添上0即可</span></span><br><span class="line"><span class="comment"># 这种写法是保证0正好够用，当然直接添上足够满足测试数据的个数也是可以的</span></span><br><span class="line"><span class="comment"># 比如lm += [0] * 100</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">如果难以理解最后一行，不妨想想一行输入多个数据如何接收。  </span><br><span class="line">这个解法使用了列表生成式。稍微解释一下列表生成式：  </span><br><span class="line">```python</span><br><span class="line">a = [f(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">上面这个赋值语句相当于：</span><br><span class="line">```python</span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">   a.append(f(i))</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">其中`f(i)`是一个关于`i`的（数学层面上的）函数，可以是确切的表达式，也可以包含函数。  </span><br><span class="line">- - -</span><br><span class="line"><span class="comment">## &lt;font color=#0033FF&gt;C.变量命名&lt;/font&gt;</span></span><br><span class="line">这道题目是一道很典型的字符串处理题目，考察大家对于字符串处理的知识点的掌握。需要注意的是题目中有一句话“每一个单词的第一个字母为大写，其他字母为小写”，提到了其他字母为小写，就一定要在自己的程序里将其他字符转换为小写。  </span><br><span class="line">顺带提一下，为了增强代码可读性，这道题目所提到的“驼峰命名法”和我个人常用的“下划线命名法”都是很好的给变量命名的方法。具体就是先用几个英文单词描述这个变量所代表的含义，比如使用“Principal per year”来表示A题中的每年应摊本金，然后将变量命名为`PrincipalPerYear`，`principalPerYear`（这两者都是驼峰命名法，区别是第一个单词的首字母是否大写）或`principal_per_year`（下划线命名法）。这样一来，每个变量表示什么就一清二楚，在变量很多的时候也不会觉得杂乱，不会有“n是什么意思，x是什么变量，a又是什么”这样的混乱。  </span><br><span class="line">以下是常见错误：  </span><br><span class="line">+ 没有读清题目要求，未将每个单词除第一个字母外的其他字母变为小写。</span><br><span class="line">+ 使用索引判断是否为新单词的时候忽略了第一个字符的特殊处理，并且因为Python的索引特性导致了奇怪错误的发生。  </span><br><span class="line"></span><br><span class="line"><span class="comment">#### &lt;font color=#FF5E5E&gt;错误示范&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">   <span class="keyword">if</span> s[i].isalpha():</span><br><span class="line">       <span class="keyword">if</span> s[i<span class="number">-1</span>].isalpha():</span><br><span class="line">           ans += s[i]</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           ans += s[i].upper()</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这一个示范有两处错误。第一是忘记了将非单词首字母转化为小写，第二就是索引问题。当`i=<span class="number">0</span>`也就是第一次进入循环的时候，这时`s[i<span class="number">-1</span>]`代表的是`s[<span class="number">-1</span>]`，也就是最后一个字符。如果最后一个字符也是字母的话，那么第一个字符就没有转化为大写，自然就会PE。</span><br><span class="line"><span class="comment">#### &lt;font color=#5ECCFF&gt;正确答案&lt;/font&gt;</span></span><br><span class="line">要注意的是`.upper()`和`.lower()`方法不会对非字母字符做任何处理，要善用这一特性。  </span><br><span class="line">```python</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">con = <span class="literal">True</span>                                  <span class="comment"># 用于控制程序在判断有无字母后是否需要继续</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:                                 <span class="comment"># 这里使用for...else...语句来判断是否全为特殊符号</span></span><br><span class="line">   <span class="keyword">if</span> i.isalpha():                         <span class="comment"># 只要有一个字母，便无需再判断</span></span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:                                       <span class="comment"># 如果全为特殊符号，则输出并且不继续程序</span></span><br><span class="line">   print(<span class="string">&quot;WaiBiBaBo&quot;</span>)</span><br><span class="line">   con = <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> con:                                     <span class="comment"># con为True则说明需要继续</span></span><br><span class="line">   flag = <span class="literal">True</span>                             <span class="comment"># 使用flag变量来判断是否为词首，初始值为True</span></span><br><span class="line">   ans = <span class="string">&#x27;&#x27;</span>                                <span class="comment"># ans是answer的简写，一般用于存储最终结果，也可以使用res（result）</span></span><br><span class="line">   <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">       <span class="keyword">if</span> c.isalpha():</span><br><span class="line">           <span class="keyword">if</span> flag:                        <span class="comment"># flag为True表示当前位置是词首，应该大写</span></span><br><span class="line">               ans += c.upper()</span><br><span class="line">           <span class="keyword">else</span>:                           <span class="comment"># 否则不是词首，应该小写</span></span><br><span class="line">               ans += c.lower()            <span class="comment"># 此处一定注意要转化为小写</span></span><br><span class="line">           flag = <span class="literal">False</span>                    <span class="comment"># 记得更新flag</span></span><br><span class="line">       <span class="keyword">elif</span> c.isdigit():</span><br><span class="line">           ans += c                        <span class="comment"># 数字要记入，然后更新flag</span></span><br><span class="line">           flag = <span class="literal">True</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           flag = <span class="literal">True</span></span><br><span class="line">   print(ans)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">如果想要使用索引进行处理，那么可以采取以下措施。因为不知道第一个字符是不是字母，所以直接将第一个字符转化为大写存储起来并不保险，需要使用一点小技巧，放到优化解法里了。  </span><br><span class="line"><span class="comment">#### &lt;font color=#33EEBB&gt;优化解法&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">if</span> s.upper() == s.lower():</span><br><span class="line">   print(<span class="string">&quot;WaiBiBaBo&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 判断是否全为特殊符号，只需要一点小技巧。这样可以省下不少代码。</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">if</span> ans == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">   print(<span class="string">&quot;WaiBiBaBo&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   print(ans)</span><br><span class="line"><span class="comment"># 也可以前面不做处理，最后判断。</span></span><br><span class="line"><span class="comment"># 因为题目保证了有数字必有字母，所以这样很安心。</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># 前面提到的使用索引处理字符的方法</span></span><br><span class="line">s = s + <span class="string">&#x27;/&#x27;</span>                                 <span class="comment"># 此处添加任意不是数字或字母符号均可</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">   <span class="keyword">if</span> s[i].isalpha():</span><br><span class="line">       <span class="keyword">if</span> s[i<span class="number">-1</span>].isalpha():</span><br><span class="line">           ans += s[i].lower()</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           ans += s[i].upper()</span><br><span class="line"><span class="comment"># 因为在最后添了一个特殊符号，所以第一个字符一定会被认为是词首。而且特殊符号会在这样的处理中被删除掉，所以不用添加额外处理。</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"><span class="comment">## &lt;font color=#0033FF&gt;D.仿二进制数密文系统&lt;/font&gt;</span></span><br><span class="line">考察字典的运用，当然不使用字典也可以完成。  </span><br><span class="line">以下是常见问题：  </span><br><span class="line">+ 将一个字符串分为n个一组的操作不熟练  </span><br><span class="line">+ 转换二进制和添<span class="number">0</span>的操作不熟练，`<span class="built_in">bin</span>()`函数添加的`<span class="string">&#x27;0b&#x27;</span>`没有处理</span><br><span class="line">+ 有好多同学把<span class="number">3</span>写进了代码！题目并没有说一定是<span class="number">3</span>个一组</span><br><span class="line">+ 在判断密文是否合法时出现了各种问题  </span><br><span class="line"></span><br><span class="line"><span class="comment">#### &lt;font color=#FF5E5E&gt;错误示范&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">set</span>(w) != &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;:</span><br><span class="line">   print(<span class="string">&#x27;Type Error,Please Check!&#x27;</span>)</span><br><span class="line"><span class="comment"># 密文只有0或只有1也是合法的哦，这样会排除掉正确的密文</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">m = <span class="built_in">len</span>(w) // n</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">   w[i:i+n]</span><br><span class="line"><span class="comment"># 想到了要n个一组，但是这样并没有完成n个一组的操作</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">对于上面这个代码，比如说有一个序列`[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]`</span><br><span class="line">需要三个一组分组，然后此时`L`为<span class="number">3</span>，再执行`<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):`</span><br><span class="line">本来想得到的是`[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]`，`[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]`，`[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]`，</span><br><span class="line">却得到了`[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]`，`[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]`，`[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]`，</span><br><span class="line">思考一下为什么。</span><br><span class="line"><span class="comment">#### &lt;font color=#5ECCFF&gt;正确答案&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> ** n):</span><br><span class="line">   k = <span class="built_in">bin</span>(i)[<span class="number">2</span>:]                          <span class="comment"># 切片操作删除&#x27;0b&#x27;</span></span><br><span class="line">   d[<span class="string">&#x27;0&#x27;</span>*(n-<span class="built_in">len</span>(k)) + k] = <span class="built_in">input</span>()         <span class="comment"># 补0，输入数据</span></span><br><span class="line">w = <span class="built_in">input</span>()</span><br><span class="line">L = <span class="built_in">len</span>(w)</span><br><span class="line"><span class="keyword">if</span> L % n:</span><br><span class="line">   print(<span class="string">&quot;Type Error,Please Check!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> w:</span><br><span class="line">       <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>):             <span class="comment"># 这里是逐一判断，下面的解法是统一判断</span></span><br><span class="line">           print(<span class="string">&quot;Type Error,Please Check!&quot;</span>)</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">   <span class="keyword">else</span>:                                   <span class="comment"># for...else...语句，希望大家都能掌握这个用法</span></span><br><span class="line">       p = []</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, L, n):            <span class="comment"># 带有三个参数的range()函数，第三个参数是步长</span></span><br><span class="line">           p.append(d[w[i:i+n]])</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">           print(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">#### &lt;font color=#33EEBB&gt;优化解法&lt;/font&gt;</span></span><br><span class="line">首先来看一个十分熟悉的函数`<span class="built_in">int</span>()`，实际上这个函数可以传两个参数。`<span class="built_in">int</span>(x, n)`的返回值是将`x`当做n进制的数，然后转化为十进制整型返回，其中`x`应传如字符串。  </span><br><span class="line">举几个例子：  </span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;100&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;0b100&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;100&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">在了解到这个用法之后，这道题目的某些复杂的数据处理就可以省掉了</span><br><span class="line">```python</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">k = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> ** n)]              <span class="comment"># 列表生成式，生成了从0到2**n-1的整数序列</span></span><br><span class="line">v = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> ** n):</span><br><span class="line">   v.append(<span class="built_in">input</span>())</span><br><span class="line">d = <span class="built_in">dict</span>(<span class="built_in">zip</span>(k, v))                         <span class="comment"># 其实不用zip()函数更简单一些，参考正确答案的做法</span></span><br><span class="line">w = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(w) % n:</span><br><span class="line">   print(<span class="string">&quot;Type Error,Please Check!&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> w.replace(<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;&#x27;</span>):   <span class="comment"># 判断是否全为01，如果不是，则在替换后字符串非空</span></span><br><span class="line"><span class="comment"># elif not (set(w) &lt;= &#123;&#x27;0&#x27;, &#x27;1&#x27;&#125;):          # 判断不是真子集也可</span></span><br><span class="line">   print(<span class="string">&quot;Type Error,Please Check!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   w += <span class="string">&#x27;/&#x27;</span>                                <span class="comment"># 消除伏笔</span></span><br><span class="line">   p = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   <span class="keyword">while</span> w != <span class="string">&#x27;/&#x27;</span>:                         <span class="comment"># 读完所有密文后w将剩下一个&#x27;/&#x27;</span></span><br><span class="line">       c = w[:n]                           <span class="comment"># 将前n个字符切片</span></span><br><span class="line">       w = w[n:]                           <span class="comment"># 删去前n个字符</span></span><br><span class="line">       p += d[<span class="built_in">int</span>(c, <span class="number">2</span>)] + <span class="string">&#x27; &#x27;</span></span><br><span class="line">   print(p)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">注意到这个解法与上一个解法的最大的区别，在于所建立的字典不一样。上一种解法的字典的键是`<span class="string">&#x27;0000&#x27;</span>,<span class="string">&#x27;0001&#x27;</span>,<span class="string">&#x27;0010&#x27;</span>,...`这样形如二进制数的字符串，而这种解法的字典的键则是`<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,...`这样的十进制整型。通过`<span class="built_in">int</span>(c,<span class="number">2</span>)`这样的操作可以简单地将二进制化为十进制并且不用考虑前缀或者位数这样的限制。  </span><br><span class="line">注释里有一句“消除伏笔”，这个伏笔来源于后面`w=w[n:]`的操作。因为最后一次切片时，字符串`w`只剩下了n个字符，则`w[n:]`这样会访问越界，所以在其最后任意添加一个字符防止越界，并且`<span class="keyword">while</span>`循环的判断条件也随之变化。  </span><br><span class="line">- - -</span><br><span class="line"><span class="comment">## &lt;font color=#0033FF&gt;E.构造（选做）&lt;/font&gt;</span></span><br><span class="line">本题的题目叫做构造，旨在锻炼大家的构造能力。一般像这种存在多个解，要求输出任一解的，先要考虑能否构造出通解。  </span><br><span class="line">常见问题就是没有理解题目的意图，尝试使用遍历求解。在$<span class="number">10</span>^&#123;<span class="number">100000</span>&#125;$这样大的运算量下必定会TLE。  </span><br><span class="line"><span class="comment">#### &lt;font color=#5ECCFF&gt;正确答案&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line">print(<span class="string">&#x27;2&#x27;</span>+<span class="string">&#x27;3&#x27;</span>*(<span class="built_in">int</span>(<span class="built_in">input</span>())<span class="number">-1</span>))</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这里给出的是一行解，如果拆成更便于理解的形式，将会是下面这样：  </span><br><span class="line">```python</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s = <span class="string">&#x27;2&#x27;</span> + <span class="string">&#x27;3&#x27;</span> * (n<span class="number">-1</span>)</span><br><span class="line">print(s)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这道题目通解有很多，比如</span><br><span class="line"><span class="number">233333333333333</span></span><br><span class="line"><span class="number">299999999999999</span></span><br><span class="line"><span class="number">533333333333333</span></span><br><span class="line"><span class="number">599999999999999</span></span><br><span class="line"><span class="number">833333333333333</span></span><br><span class="line"><span class="number">899999999999999</span></span><br><span class="line"><span class="number">263939639633939</span>（开头是<span class="number">258</span>，中间是<span class="number">369</span>随意，末尾是<span class="number">3</span>或者<span class="number">9</span>）</span><br><span class="line"><span class="number">555555555555558</span></span><br><span class="line"><span class="number">333333333333334</span></span><br><span class="line"><span class="number">566666666666666</span></span><br><span class="line"><span class="number">777777777777778</span></span><br><span class="line">等等等等，感兴趣的可以再研究研究</span><br><span class="line">- - -</span><br><span class="line"><span class="comment">## &lt;font color=#0033FF&gt;F.技能加点（选做）&lt;/font&gt;</span></span><br><span class="line">这道题做的人实在是太少了（悲），直接给出我的AC代码了。  </span><br><span class="line">这道题的思路在于将每一个技能的最优点数化为k进制数，然后如果每一个数都只含有<span class="number">0</span>或<span class="number">1</span>，且不存在两个数的同一位都是<span class="number">1</span>，那么就可以满足条件。  </span><br><span class="line">这道题有两个临界值（一般也叫“坑”），一个是所有技能的最优点数全为<span class="number">0</span>， ~~可惜样例给出了，坑不到了，~~ 另一个则是k=<span class="number">1</span>的情况。想想“一进制”有没有实际意义。  </span><br><span class="line"><span class="comment">#### &lt;font color=#5ECCFF&gt;正确答案&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> m</span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">   n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">   req = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">   top = <span class="built_in">max</span>(req)                          <span class="comment"># top是最大的最优点数</span></span><br><span class="line">   <span class="keyword">if</span> top == <span class="number">0</span> <span class="keyword">or</span> k == <span class="number">1</span>:                  <span class="comment"># 对两个坑的特判</span></span><br><span class="line">       print(<span class="string">&quot;YES&quot;</span>)</span><br><span class="line">       <span class="keyword">continue</span></span><br><span class="line">   ds = m.ceil(m.log(top, k))              <span class="comment"># 这里是计算k进制的最大位数，直接给一个足够大的数也可以</span></span><br><span class="line">   dis = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ds+<span class="number">1</span>)]          <span class="comment"># 创建0列表用于存放总和每个位数的值</span></span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> req:</span><br><span class="line">       tdis = []                           <span class="comment"># 对于每一个最优点数创建列表</span></span><br><span class="line">       <span class="keyword">while</span> j != <span class="number">0</span>:                       <span class="comment"># 熟悉的进制转换</span></span><br><span class="line">           tdis.append(j % k)</span><br><span class="line">           j = j // k</span><br><span class="line">       <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tdis)):          <span class="comment"># 将当前数加到总和上</span></span><br><span class="line">           dis[l] += tdis[l]</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> dis:</span><br><span class="line">       <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>]:                 <span class="comment"># 只要有一个不是0或1就说明某一秒需要多次加点才可以满足要求</span></span><br><span class="line">           print(<span class="string">&#x27;NO&#x27;</span>)</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       print(<span class="string">&quot;YES&quot;</span>)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">~~给出的`n`其实没有用到~~</span><br><span class="line">关于上面代码的`dis`和`tdis`，`dis`存储的是总值，`tdis`存储的是每一个最优点数的值，第<span class="number">0</span>个元素存放个位，第<span class="number">1</span>个元素存放<span class="number">1</span>次位，以此类推。  </span><br><span class="line">举例：输入</span><br></pre></td></tr></table></figure><p>3 4<br>1 4 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对于三个最优点数，转化为四进制，分别存放，然后加和到&#96;dis&#96;上</span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">1 : [1]</span><br><span class="line">4 : [0, 1]</span><br><span class="line">1 : [1]</span><br><span class="line">dis:[2, 1, 0]</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">&#96;dis&#96;存在非01的数，输出&#96;&#39;NO&#39;&#96;</span><br><span class="line">再比如输入</span><br></pre></td></tr></table></figure><p>3 9<br>0 59049 810</p><pre><code>```python0     : []59049 : [0, 0, 0, 0, 0, 1]810   : [0, 0, 1, 1]dis   : [0, 0, 1, 1, 0, 1, 0]</code></pre><p><code>dis</code>只有01，满足要求，输出<code>&#39;YES&#39;</code></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Experiment #03&lt;br&gt;北航致真书院19级大学计算机基础第三次上机实验实验总结&lt;br&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2019CCBSummary#02</title>
    <link href="http://sutai.fun/2020/04/13/2019CCBSummary-02/"/>
    <id>http://sutai.fun/2020/04/13/2019CCBSummary-02/</id>
    <published>2020-04-12T18:43:21.000Z</published>
    <updated>2020-05-03T07:51:27.576Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Experiment #02<br>北航致真书院19级大学计算机基础第二次上机实验实验总结<br><a id="more"></a></p><h1 id="第二次实验问题汇总"><a href="#第二次实验问题汇总" class="headerlink" title="第二次实验问题汇总"></a>第二次实验问题汇总</h1><hr><h2 id="A-FizzBuzz"><a href="#A-FizzBuzz" class="headerlink" title="A.FizzBuzz"></a><font color=0033FF>A.FizzBuzz</font></h2><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>分支条件不充分（这个是假想问题。本地可以排除，所以OJ上不会体现）  </li></ul><h4 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="lang-python">n = int(input())data = []for i in range(n):    x = int(input())    data.append(x)for a in data:    if a%3 == 0:        print(&#39;fizz&#39;)    elif a%5 == 0:        print(&#39;buzz&#39;)    elif a%15 == 0:        print(&#39;fizzbuzz&#39;)    else:        print(a)#这样的话可以被15整除的都会输出fizz而不是fizzbuzz</code></pre><h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">n = int(input())data = []for i in range(n):    x = int(input())    data.append(x)for a in data:    if a%3 == 0 and a%5 != 0:        print(&#39;fizz&#39;)    elif a%5 == 0 and a%3 != 0:        print(&#39;buzz&#39;)    elif a%15 == 0:        print(&#39;fizzbuzz&#39;)    else:        print(a)#判断条件要更充分</code></pre><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="lang-python">n = int(input())data = []for i in range(n):    x = int(input())    data.append(x)for a in data:    if a%15 == 0:        print(&#39;fizzbuzz&#39;)    elif a%5 == 0:        print(&#39;buzz&#39;)    elif a%3 == 0:        print(&#39;fizz&#39;)    else:        print(a)#先判断15就没有任何问题啦！不妨想想为什么</code></pre><h4 id="奇怪的解法"><a href="#奇怪的解法" class="headerlink" title="奇怪的解法"></a><font color=#9966FF>奇怪的解法</font></h4><pre><code class="lang-python">n = int(input())for i in range(n):    x = int(input())    flag = True    if x%3 == 0:        print(&#39;fizz&#39;, end=&#39;&#39;)        flag = False    if x%5 == 0:        print(&#39;buzz&#39;, end=&#39;&#39;)        flag = False    if flag:        print(x, end=&#39;&#39;)    print()#这个是我写的解法啦，有点小奇妙但是并没有简化多少，所以专门开了一栏#顺带提一下，OJ系统上检测输出数据的时候是不受输入数据影响的#所以输出输入穿插进行是可以的</code></pre><hr><h2 id="B-对话过滤"><a href="#B-对话过滤" class="headerlink" title="B.对话过滤"></a><font color=0033FF>B.对话过滤</font></h2><h3 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>使用ASCII码完成大小写字母匹配，但忽略了其他符号的影响</li><li>对字母和符号一视同仁，顺便删去了重复的符号</li><li>对字符串通过下标访问时访问越界  </li></ul><h4 id="错误示范-1"><a href="#错误示范-1" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="lang-python">s=str(input())ns=&#39;&#39;for i in range(0,len(s)):        if s[i].isalpha()==True:        if ord(s[i])==ord(s[i-1]) or ord(s[i])==ord(s[i-1])+32 or ord(s[i])==ord(s[i-1])-32:            pass        else:            ns+=s[i]    else:        ns+=s[i]print(ns)#注意到最长的一行使用了ASCII码来判断字母是否重复#并且使用+-32的方式将大小写字母全部考虑到了#但是需要注意的是&#39;!&#39;和&#39;A&#39;,&#39;#&#39;和&#39;C&#39;等字符也是ASCII码相差32的#因此会删除一些跟在某一些特定符号后的特定字母</code></pre><pre><code class="lang-python">s=input()ns=s[0]for i in range(1,len(s)):    if str.upper(s[i])!=str.upper(s[i-1]):        ns=ns+s[i]print(ns)#思路很好，但是这样不仅删去了重复的字母，还删去了重复的非字母字符</code></pre><h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">s=input()ns=s[0]for i in range(1,len(s)):    if (not str.isalpha(s[i])) or (str.upper(s[i])!=str.upper(s[i-1])):        ns=ns+s[i]print(ns)</code></pre><h4 id="优化解法-1"><a href="#优化解法-1" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="lang-python">#按理说也不算优化解法，只是提供另一个思路#同学们基本上都是通过下标将一个字符与上一个字符比较#其实也可以创建一个变量用于存储上一个字符s = input()ans = &#39;&#39;pre = &#39;&#39;for i in s:    if i.isalpha():        if i.lower() == pre.lower():            continue    pre = i    ans = ans + iprint(ans)#注意这里pre就是用来存储上一字符的变量#注意这里continue的用法</code></pre><hr><h2 id="C-Cantor表"><a href="#C-Cantor表" class="headerlink" title="C.Cantor表"></a><font color=0033FF>C.Cantor表</font></h2><h3 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>题目要求适用空格，却使用了制表符<code>\t</code>隔开</li><li>换行的时候使用了<code>print(&#39;\n&#39;)</code>  </li></ul><h4 id="错误示范-2"><a href="#错误示范-2" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="lang-python">n=int(input())for i in range(1,n+1):    for j in range(1,n+2-i):         print(&#39;%d/%d&#39;%(i,j),end=&#39;\t&#39;)     print()#题目要求空格但是使用了制表符&#39;\t&#39;</code></pre><pre><code class="lang-python">n=int(input())for i in range(1,n+1):    for j in range(1,n+2-i):         print(&#39;%d/%d&#39;%(i,j),end=&#39; &#39;)     print(&#39;\n&#39;)#要注意print()函数自带一个end=&#39;\n&#39;，需要仅换行的时候使用不带参数的print()即可</code></pre><h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">n=int(input())for i in range(1,n+1):    for j in range(1,n+2-i):         print(&#39;%d/%d&#39;%(i,j),end=&#39; &#39;)     print()#OJ在检验输出结果的时候一般情况下会自动忽略掉行末的空格和段落末尾的换行符#我给命题组提意见要求删掉行尾没有多余空格那句话但是最后没改</code></pre><hr><h2 id="D-新数根的计算"><a href="#D-新数根的计算" class="headerlink" title="D.新数根的计算"></a><font color=0033FF>D.新数根的计算</font></h2><h3 id="常见问题-3"><a href="#常见问题-3" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>边界条件设置有问题，会输出10</li><li>循环变量的赋值时机（包括赋初始值和循环过程中赋值）把握不清楚</li><li>在比较的时候没有把握好变量类型  </li></ul><h4 id="错误示范-3"><a href="#错误示范-3" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="lang-python">n = str(input())while int(n) &gt; 10:    b = 1    for i in n :        if i != &#39;0&#39;:            b = b * int(i)        else:            continue    n = str(b)print(n)#如果中间计算出了10这个数字，会直接跳出循环，导致结果出错</code></pre><pre><code class="lang-python">n = str(input())while int(n) &gt;= 10:    b = 1    for i in n :        if i != 0:            b = b * int(i)        else:            continue    n = str(b)print(n)#if判断的时候，i是一个字符串，所以一定不会和0相等</code></pre><pre><code class="lang-python">a=input()m=1while len(a)&gt;1:    for i in a:        if i == &#39;0&#39;:            continue        m=m*int(i)    a=str(m)print(a)#m作为for循环的循环变量，应在for前初始化#所以应该写在while里</code></pre><h4 id="正确答案-3"><a href="#正确答案-3" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">num = input()while int(num) &gt;= 10:#while len(num) &gt; 1:    product = 1    for i in num:        if i != &#39;0&#39;:            product *= int(i)    num = str(product)print(num)#通过数值大小或者字符串长度判断是否跳出循环都是正确思路</code></pre><hr><h2 id="E-第k对角线（选做）"><a href="#E-第k对角线（选做）" class="headerlink" title="E.第k对角线（选做）"></a><font color=0033FF>E.第k对角线（选做）</font></h2><ul><li>做的人实在太少了</li><li>一个比较常见的问题是题意理解不清</li><li>所以直接给AC代码了  </li></ul><h4 id="正确答案-4"><a href="#正确答案-4" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">n = int(input())k = int(input())vice = int(input())for i in range(1, n+1):    for j in range(1, n+1):        if vice:                    #如果要画副对角线            if k==abs(j+i-n-1):     #这里是判断(i,j)在不在n阶方阵的第k副对角线上                print(&#39;x&#39;, end=&#39;&#39;)            else:                print(&#39;*&#39;, end=&#39;&#39;)        else:                       #如果要画主对角线            if k==abs(i-j):         #这里是判断(i,j)在不在n阶方阵的第k主对角线上                print(&#39;x&#39;, end=&#39;&#39;)            else:                print(&#39;*&#39;, end=&#39;&#39;)    print()                         #使用print()换行</code></pre><hr><h2 id="F-中国剩余定理（选做）"><a href="#F-中国剩余定理（选做）" class="headerlink" title="F.中国剩余定理（选做）"></a><font color=0033FF>F.中国剩余定理（选做）</font></h2><h3 id="常见问题-4"><a href="#常见问题-4" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>忽略了输出正整数的条件</li><li>没有注意到除法会将数据转换为浮点数，而浮点数精度可能出现问题  </li></ul><h4 id="正确答案-5"><a href="#正确答案-5" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">n = int(input())con = []prod = 1                                #记录所有除数的乘积for i in range(n):    x, y = map(int, input().split())    prod *= x    con.append((x, y))                  #每一个元素是一个元组，第一项是除数，第二项是余数rev = []                                #存储每个除数的“逆”for item in con:    i = 1                               #while循环变量赋初值    att = prod // item[0]               #注意此处使用地板除来消除python浮点数运算精度不高的问题    while att * i % item[0] != 1:        i += 1                          #逐一寻找“逆”    rev.append(att * i)                 #将“逆”存起来ans = 0                                 #下面求和用的for循环变量赋初值for i in range(n):    ans += con[i][1] * rev[i]           #根据公式把ak+b形式算出来ans = ans % prod                        #取最小的可能值if ans == 0:                            #确保输出正整数    ans = prodprint(ans)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Experiment #02&lt;br&gt;北航致真书院19级大学计算机基础第二次上机实验实验总结&lt;br&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2019CCBSummary#01</title>
    <link href="http://sutai.fun/2020/04/11/2019CCBSummary-01/"/>
    <id>http://sutai.fun/2020/04/11/2019CCBSummary-01/</id>
    <published>2020-04-10T17:15:09.000Z</published>
    <updated>2020-05-03T07:50:54.049Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Experiment #01<br>北航致真书院19级大学计算机基础第一次上机实验实验总结<br><a id="more"></a></p><h1 id="第一次实验问题汇总"><a href="#第一次实验问题汇总" class="headerlink" title="第一次实验问题汇总"></a>第一次实验问题汇总</h1><hr><h2 id="A-命题生成器"><a href="#A-命题生成器" class="headerlink" title="A.命题生成器"></a><font color=0033FF>A.命题生成器</font></h2><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><code>print()</code>函数中<code>+</code>运算符和<code>,</code>分割参数使用不够熟练，导致输出的空格数不符合要求。  </li></ul><h4 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="lang-python">print(&#39;If&#39;+a+&#39;,&#39;+&#39;then&#39;+b+&#39;.&#39;)#少了空格，所有输出会全部贴在一起</code></pre><pre><code class="lang-python">print(&#39;If&#39;,a,&#39;,&#39;,&#39;then&#39;,b,&#39;.&#39;)#多了空格，标点符号会跟前面的单词分开</code></pre><h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">print(&#39;If&#39;,a+&#39;,&#39;,&#39;then&#39;,b+&#39;.&#39;)#在需要空格的时候使用逗号，在不需要空格的时候使用加号</code></pre><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="lang-python">print(&#39;If &#39;+a+&#39;, then&#39;+b+&#39;.&#39;)#将空格全部放在字符串里再全部使用加号，直观感受空格位置</code></pre><pre><code class="lang-python">print(&#39;If &#39;,a,&#39;, then&#39;,b,&#39;.&#39;, sep=&#39;&#39;)#传入sep参数来消除逗号分割对于空格的影响</code></pre><pre><code class="lang-python">print(&#39;If %s, then %s.&#39;%(a,b))#使用格式控制符来非常直观地感受输出格式，是最为推荐的方法#以后在使用print()函数时应首选这种方法</code></pre><pre><code class="lang-python">print(&#39;If &#123;&#125;, then &#123;&#125;.&#39;.format(a,b))#使用.format()方法来非常直观地感受输出格式，同样也是最为推荐的方法#同样也是使用print()函数时的首选方法</code></pre><hr><h2 id="B-奖状密码"><a href="#B-奖状密码" class="headerlink" title="B.奖状密码"></a><font color=0033FF>B.奖状密码</font></h2><h3 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>三引号使用不熟练，导致多输出空白符  </li><li>对位运算符不熟练，没有想到<code>&amp;</code>的用法  </li></ul><h4 id="错误示范-1"><a href="#错误示范-1" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="lang-python">print(&quot;&quot;&quot;--------------------------------------               ---       &#123;&#125;        ---               ----              ------            ----------------------------&quot;&quot;&quot;.format(grade))#可能因为有强迫症，令所有行对齐，这样第一行会多出一个换行符</code></pre><pre><code class="lang-python">print(&quot;&quot;&quot;--------------------         --------         ------         ----               -         --       &#123;&#125;        --         -               ----                       ------                     --------         --------------------&quot;&quot;&quot;.format(grade))#和上面相似，这种写法在从第二行开始每行开头会多出空格</code></pre><h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">a = int(input())b = int(input())c = a &amp; b#注意&amp;运算符可以将十进制数转换为二进制#所以无需手动转换，直接使用十进制数运算即可#注意此时结果c也是十进制grade = chr(c)print(&quot;&quot;&quot;--------------------------------------               ---       &#123;&#125;        ---               ----              ------            ----------------------------&quot;&quot;&quot;.format(grade))</code></pre><pre><code class="lang-python">print(&quot;-&quot;*20)print(&quot;-&quot;*8)print(&quot;-&quot;*6)print(&quot;-&quot;*4+&quot; &quot;*15+&quot;-&quot;)print(&quot;--&quot;+&quot; &quot;*7+grade+&quot; &quot;*8+&quot;--&quot;)print(&quot;-&quot;+&quot; &quot;*15+&quot;-&quot;*4)print(&quot; &quot;*14+&quot;-&quot;*6)print(&quot; &quot;*12+&quot;-&quot;*8)print(&quot;-&quot;*20)#当然这样写也是可行的，但是代码稍显杂乱</code></pre><h4 id="优化解法-1"><a href="#优化解法-1" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="lang-python">print(&#39;--------------------&#39;)print(&#39;--------            &#39;)print(&#39;------              &#39;)print(&#39;----               -&#39;)print(&#39;--       %s        --&#39;%grade)print(&#39;-               ----&#39;)print(&#39;              ------&#39;)print(&#39;            --------&#39;)print(&#39;--------------------&#39;)#不如使用多个print()，一行一个，这样可以增大代码的美观性#虽说OJ一般不会管行末的空格，但是补全之后不是更好看吗？</code></pre><hr><h2 id="C-估算自然常数e"><a href="#C-估算自然常数e" class="headerlink" title="C.估算自然常数e"></a><font color=0033FF>C.估算自然常数e</font></h2><h3 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><strong><font color=FF5E5E>不够仔细！</font></strong></li></ul><h4 id="错误示范-2"><a href="#错误示范-2" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="lang-python">n = int(input())</code></pre><h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">n = float(input())#自行感受一下</code></pre><hr><h2 id="D-四元数乘法"><a href="#D-四元数乘法" class="headerlink" title="D.四元数乘法"></a><font color=0033FF>D.四元数乘法</font></h2><h3 id="常见问题-3"><a href="#常见问题-3" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><code>print()</code>函数使用不熟练</li><li><strong><font color=FF5E5E>不够仔细！</font></strong></li></ul><h4 id="错误示范-3"><a href="#错误示范-3" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="lang-python">a,b,c,d=input().split(&#39;,&#39;)e,f,g,h=input().split(&#39;,&#39;)#此时所有变量都是字符串</code></pre><pre><code class="lang-python">a,b,c,d=map(int,input().split(&#39;,&#39;))e,f,g,h=map(int,input().split(&#39;,&#39;))</code></pre><pre><code class="lang-python">i = a*e - b*f - c*g - d*hj = b*e + a*f + c*h - d*gk = c*e + c*e + d*f - b*hl = d*e + a*h + b*g - c*f</code></pre><h4 id="正确答案-3"><a href="#正确答案-3" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">a,b,c,d=map(float,input().split(&#39;,&#39;))e,f,g,h=map(float,input().split(&#39;,&#39;))i = a*e - b*f - c*g - d*hj = b*e + a*f + c*h - d*gk = c*e + a*g + d*f - b*hl = d*e + a*h + b*g - c*f#自行感受一下print(&#39;%.2f&#39;%i,&#39;%.2f&#39;%j,&#39;%.2f&#39;%k,&#39;%.2f&#39;%l,sep=&#39;,&#39;)</code></pre><h4 id="优化解法-2"><a href="#优化解法-2" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="lang-python">print(&#39;%.2f,%.2f,%.2f,%.2f&#39;%(i, j, k, l))#这样的写法是非常清楚的，.format()方法同理#如果可以通过格式控制输出的话，还是格式控制输出更清楚#使用加号和逗号配合sep参数也可以完成，但是会稍显杂乱</code></pre><hr><h2 id="E-净化网络环境（选做）"><a href="#E-净化网络环境（选做）" class="headerlink" title="E.净化网络环境（选做）"></a><font color=0033FF>E.净化网络环境（选做）</font></h2><h3 id="常见问题-4"><a href="#常见问题-4" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>选做题也请尝试做啊！助教出题很辛苦的！</li></ul><h4 id="优化解法-3"><a href="#优化解法-3" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="lang-python">print(chr(m+65))#有一部分同学使用了列表或者分支语句来完成0对应A，1对应B这样的操作#实际上将m的值加上&#39;A&#39;的ASCII码的值就可以转化为密文的ASCII码</code></pre><pre><code class="lang-python">print(chr(m+ord(&#39;A&#39;)))#如果记不起来&#39;A&#39;的ASCII码是65的话，使用这种方式也是可以的</code></pre><hr><h2 id="F-求平方根（选做）"><a href="#F-求平方根（选做）" class="headerlink" title="F.求平方根（选做）"></a><font color=0033FF>F.求平方根（选做）</font></h2><ul><li>本题大家做的都不错，没有什么常见问题</li><li>个别问题在于进入循环前的准备不够充分，循环内的工作不到位</li></ul><h4 id="错误示范-4"><a href="#错误示范-4" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="lang-python">a = int(input())x = 1.0count = 0while abs(x-b)&gt;=0.00001:    x = b    b = (x+a/x)/2    count += 1#在进入while循环时b还没有定义，会导致程序报错#虽然说b在第一次循环之后就会工作正常，但是为了顺利进入循环，还是需要给b赋一个初始值</code></pre><pre><code class="lang-python">a = int(input())x = 1.0b = (x+a/x)/2count = 1while abs(x-b)&gt;=0.00001:    x = b    b = (x+a/x)/2#这个则是忘记了在循环中增加计数用循环变量count的值</code></pre><pre><code class="lang-python">a = int(input())x = 1.0b = (x+a/x)/2count = 1while abs(x-b)&gt;=0.00001:    b = (x+a/x)/2    count += 1#这个则是忘了在循环中更新x的值#因为这一次循环计算出的b在下一次循环中是作为x出现的，所以一定要在合适的地方添上赋值语句</code></pre><h4 id="正确答案-4"><a href="#正确答案-4" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="lang-python">a = int(input())x = 1.0b = (x+a/x)/2count = 1while abs(x-b)&gt;=0.00001:    x = b    b = (x+a/x)/2    count += 1print(&#39;%.3f&#39;%b)print(count)#count=1的原因是在循环外就已经进行了一次迭代了</code></pre><pre><code class="lang-python">a = int(input())d = 1x = 1.0count = 0while d &gt;= 0.00001:    b = (x+a/x)/2    d = abs(x-b)    x = b    count += 1print(&#39;%.3f&#39;%b)print(count)#引入表示前后两次迭代结果的差的变量d也是一种思路</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Experiment #01&lt;br&gt;北航致真书院19级大学计算机基础第一次上机实验实验总结&lt;br&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
</feed>
