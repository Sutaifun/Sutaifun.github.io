<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Styphon&#39;s Site</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sutai.fun/"/>
  <updated>2020-05-03T07:05:18.215Z</updated>
  <id>http://sutai.fun/</id>
  
  <author>
    <name>Styphon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019CCBSummary#06</title>
    <link href="http://sutai.fun/2020/05/03/2019CCBSummary-06/"/>
    <id>http://sutai.fun/2020/05/03/2019CCBSummary-06/</id>
    <published>2020-05-03T06:58:37.000Z</published>
    <updated>2020-05-03T07:05:18.215Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Experiment #06<br>北航致真书院19级大学计算机基础第六次上机实验实验总结</p><a id="more"></a><h1 id="第六次实验问题汇总"><a href="#第六次实验问题汇总" class="headerlink" title="第六次实验问题汇总"></a>第六次实验问题汇总</h1><hr><h2 id="A-电力分配"><a href="#A-电力分配" class="headerlink" title="A.电力分配"></a><font color=#0033FF>A.电力分配</font></h2><p>这道题目在强调了一一对应之后，不难发现这是一道贪心算法的题目（题目甚至明示了贪心算法）。<br>思路很简单：对于所需功率最小的生产线，总是尝试使用提供功率尽可能小的发电机进行供电；<br>或者对于提供功率最大的发电机，总是尝试对所需功率尽可能大的生产线进行供电。<br>这两个思路虽然最终分配方案不一定一样，但是可供电的生产线数量是相等的。  </p><h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">n = int(input())lnum = []<span class="keyword">for</span> _ <span class="keyword">in</span> range(n):    lnum.append(int(input()))lnum.sort()                                 <span class="comment"># 注意题目并没有说输入时满足某种次序</span>m = int(input())                            <span class="comment"># 所以需要自行.sort()进行排序</span>ln2 = []<span class="keyword">for</span> _ <span class="keyword">in</span> range(m):    ln2.append(int(input()))ln2.sort()ans = <span class="number">0</span><span class="keyword">for</span> i <span class="keyword">in</span> ln2:                               <span class="comment"># 使用上述第一种思路</span>    <span class="keyword">if</span> lnum[<span class="number">0</span>] &lt;= i:        ans += <span class="number">1</span>        lnum.pop(<span class="number">0</span>)        <span class="keyword">if</span> lnum == []:                      <span class="comment"># 进行特判避免索引越界</span>            <span class="keyword">break</span>print(ans)</code></pre><hr><h2 id="B-我不是盘神"><a href="#B-我不是盘神" class="headerlink" title="B.我不是盘神"></a><font color=#0033FF>B.我不是盘神</font></h2><p>这道题目不难想到先用XXXDownload下载两个最大的文件，然后再用XX网盘下载一个最小的文件，如此循环。<br>本质贪心算法，但是不用去模拟这一过程。我们只需要算出哪些文件需要用XX网盘下载即可。  </p><h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><p>不难算出，需要用XX网盘下载的文件是从小到大排序后前<code>n//3</code>个文件。  </p><pre><code class="python">n = int(input())lnum = [int(input()) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]     <span class="comment"># 列表生成式输入数据</span>lnum.sort()                                 <span class="comment"># 排序</span>lans = lnum[:n//<span class="number">3</span>]                          <span class="comment"># 切片操作取出需要用XX网盘下载的文件</span>print(sum(lans))                            <span class="comment"># 输出总大小</span>print(<span class="string">' '</span>.join(list(map(str, lans))))       <span class="comment"># 依次输出文件大小</span></code></pre><hr><h2 id="C-装备选择"><a href="#C-装备选择" class="headerlink" title="C.装备选择"></a><font color=#0033FF>C.装备选择</font></h2><p>通过仔细阅读题目，这道题目就是换了马甲的背包问题。所以这里不做重复的解释了。<br>如果还是有问题，请查阅课件里相应的讲解。  </p><h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">r = int(input())leq = [<span class="number">0</span>]<span class="keyword">for</span> _ <span class="keyword">in</span> range(r):    leq.append(tuple(map(int, input().split())))n = int(input())                            <span class="comment"># 关于下面value的生成需要注意一下</span>value = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(r+<span class="number">1</span>)]<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, r+<span class="number">1</span>):    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):                 <span class="comment"># 状态转移方程，为了避免越界需要分支</span>        <span class="keyword">if</span> j &gt;= leq[i][<span class="number">0</span>]:            value[i][j] = max(value[i<span class="number">-1</span>][j], value[i<span class="number">-1</span>][j-leq[i][<span class="number">0</span>]]+leq[i][<span class="number">1</span>])        <span class="keyword">else</span>:            value[i][j] = value[i<span class="number">-1</span>][j]print(value[<span class="number">-1</span>][<span class="number">-1</span>])                        <span class="comment"># 状态表格最右下即使答案</span>cnt = <span class="number">0</span>                                     <span class="comment"># 计数器</span>ans = []                                    <span class="comment"># 存储答案</span>mon = n<span class="keyword">for</span> i <span class="keyword">in</span> range(r, <span class="number">0</span>, <span class="number">-1</span>):    <span class="keyword">if</span> value[i][mon] != value[i<span class="number">-1</span>][mon]:    <span class="comment"># 不等于说明选取了当前装备</span>        cnt += <span class="number">1</span>                            <span class="comment"># 计数器加一</span>        ans.append(str(i<span class="number">-1</span>))        mon -= leq[i][<span class="number">0</span>]                    <span class="comment"># 注意这一步，要减少相应的金币数</span>print(cnt)print(<span class="string">' '</span>.join(ans))</code></pre><hr><h2 id="D-我不是盘神Pro（选做）"><a href="#D-我不是盘神Pro（选做）" class="headerlink" title="D.我不是盘神Pro（选做）"></a><font color=#0033FF>D.我不是盘神Pro（选做）</font></h2><p>这道题目相比B题，多了一个限制条件，即不能改变下载的顺序，所以原先的下载策略不再适用于这道题目。<br>可以采用动态规划完成这道题目。<br>但是尝试写出状态转移方程时，发现影响状态的参数不仅仅是已下载的文件数量。  </p><h4 id="正确答案-3"><a href="#正确答案-3" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><p>使用一个<code>n*3</code>的列表存储状态，其中<code>l[n][k]</code>指下载<code>n</code>个文件且目前已经连续使用XXXDownload下载了<code>k</code>个文件时的最优解。<br><code>l[n][0]</code>是指第<code>n</code>个文件使用XX网盘下载，需要取<code>l[n-1][k]</code>的最小值加上第<code>n</code>个文件的大小；<br><code>l[n][1]</code>值第<code>n</code>个文件使用XXXDownload下载，第<code>n</code>个文件使用XX网盘下载，所以只需要取<code>l[n-1][0]</code>的值即可；<br><code>l[n][2]</code>值第<code>n</code>个文件和第<code>n-1</code>个文件使用XXXDownload下载，第<code>n-2</code>个文件使用XX网盘下载，所以只需要取<code>l[n-1][1]</code>的值即可。</p><pre><code class="python">n = int(input())lnum = [int(input()) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]lcon = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]<span class="keyword">for</span> i <span class="keyword">in</span> range(n):                          <span class="comment"># 这里无需进行特判，i=0时，i-1为-1</span>    lcon[i][<span class="number">0</span>] = min(lcon[i<span class="number">-1</span>][<span class="number">0</span>], lcon[i<span class="number">-1</span>][<span class="number">1</span>], lcon[i<span class="number">-1</span>][<span class="number">2</span>]) + lnum[i]    lcon[i][<span class="number">1</span>] = lcon[i<span class="number">-1</span>][<span class="number">0</span>]               <span class="comment"># 开始时lcon[-1][k]均为0，不会影响最终结果</span>    lcon[i][<span class="number">2</span>] = lcon[i<span class="number">-1</span>][<span class="number">1</span>]print(min(lcon[<span class="number">-1</span>]))                        <span class="comment"># 输出最小的情况</span></code></pre><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><p>上述解法还有优化空间。因为<code>lcon[i][1] = lcon[i-1][0]</code>，<code>lcon[i][2] = lcon[i-1][1] = lcon[i-2][0]</code>，我们发现完全没有必要使用后两列数据，所以可以把存储状态的列表压缩成一维。<br>此时<code>lcon[i]</code>表示使用XX网盘下载第<code>n</code>个文件时所耗总时间。  </p><pre><code class="python">n = int(input())lnum = [int(input()) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]lcon = [<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]<span class="keyword">for</span> i <span class="keyword">in</span> range(n):    lcon[i] = min(lcon[i<span class="number">-3</span>], lcon[i<span class="number">-2</span>], lcon[i<span class="number">-1</span>]) + lnum[i]print(min(lcon[<span class="number">-3</span>:]))</code></pre><hr><h2 id="关于列表的某些性质"><a href="#关于列表的某些性质" class="headerlink" title="关于列表的某些性质"></a>关于列表的某些性质</h2><p>在生成一个二维0列表时，有的同学使用了下列写法：</p><pre><code class="python">a = []<span class="keyword">for</span> i <span class="keyword">in</span> range(n):    a.append(<span class="number">0</span>)l = []<span class="keyword">for</span> i <span class="keyword">in</span> range(m):    l.append(a)</code></pre><p>确实生成了二维0列表，但是最终的程序却没有正确输出。这是因为<code>list</code>数据类型在存储时的某些特性导致的。<br>看如下的一个交互式实例：</p><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span>a = []<span class="meta">&gt;&gt;&gt; </span>b = a<span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">1</span>)<span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>]</code></pre><p>实际上程序在执行<code>a = []</code>时，是先创建了一个空列表<code>[]</code>，然后将变量名<code>a</code>指向了这个列表：<br><img src="https://www.z4a.net/images/2020/05/03/img001.png" alt="img001.png"><br>在执行<code>b = a</code>时，是直接将变量名<code>b</code>指向了变量名<code>a</code>所指向的变量：<br><img src="https://www.z4a.net/images/2020/05/03/img002.png" alt="img002.png"><br>然后执行<code>a.append(1)</code>：<br><img src="https://www.z4a.net/images/2020/05/03/img003.png" alt="img003.png"><br>不难看出，此时调用变量<code>b</code>，返回的并不是空列表，而是添加了元素之后的列表。<br>了解了这一点之后，我们再看一下为什么上面那种写法会出现问题。<br>先看一下使用了上述构造的实例，究竟会出现什么问题：  </p><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span>a = []<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):<span class="meta">... </span>    a.append(<span class="number">0</span>)<span class="meta">... </span><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]<span class="meta">&gt;&gt;&gt; </span>l = []<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):<span class="meta">... </span>    l.append(a)<span class="meta">... </span><span class="meta">&gt;&gt;&gt; </span>l[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]<span class="meta">&gt;&gt;&gt; </span>l[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">1</span><span class="meta">&gt;&gt;&gt; </span>l[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]]<span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</code></pre><p>问题就是当改变列表中某一项的值时，发现其他的值也被修改了。<br>我们来分析一下程序是如何执行这些语句的。<br>首先是创建<code>a</code>，没有什么问题：<br><img src="https://www.z4a.net/images/2020/05/03/img004.png" alt="img004.png"><br>然后创建<code>l</code>：<br><img src="https://www.z4a.net/images/2020/05/03/img005.png" alt="img005.png"><br>然后<code>l[0] = a</code>：<br><img src="https://www.z4a.net/images/2020/05/03/img006.png" alt="img006.png"><br>这时候我们发现其实程序内部是将<code>l[0]</code>指向了<code>a</code>所指的列表，所以当第二个循环执行完之后，不难想到其实是这样的：<br><img src="https://www.z4a.net/images/2020/05/03/img007.png" alt="img007.png"><br>于是当执行到<code>l[0][3] = 1</code>的时候，实际上是这样的：<br><img src="https://www.z4a.net/images/2020/05/03/img008.png" alt="img008.png"><br>这也就不难解释一系列的输出值了。<br>需要注意的是，<code>list</code>,<code>set</code>,<code>dict</code>都具有这样的特性，在使用时需要特别注意（其实<code>tuple</code>和<code>str</code>也有这样的特性，只是这两者是不可变的，不涉及更改其中的值的问题）。  </p><h4 id="列表复制"><a href="#列表复制" class="headerlink" title="列表复制"></a>列表复制</h4><p>如果我们想把一个列表赋给另一个变量名，并且希望在更改新的列表时不会影响之前的列表，那么我们可以使用列表的<code>.copy()</code>方法创建列表的复制。  </p><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span>a = []<span class="meta">&gt;&gt;&gt; </span>b = a.copy()<span class="meta">&gt;&gt;&gt; </span>b.append(<span class="number">1</span>)<span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>]<span class="meta">&gt;&gt;&gt; </span>a[]</code></pre><p>首先创建列表<code>a</code>：<br><img src="https://www.z4a.net/images/2020/05/03/img001.png" alt="img001.png"><br>然后创建列表<code>b</code>，将<code>a</code>的复制赋值给<code>b</code>：<br><img src="https://www.z4a.net/images/2020/05/03/img009.png" alt="img009.png"><br>然后执行<code>b.append(1)</code>：<br><img src="https://www.z4a.net/images/2020/05/03/img010.png" alt="img010.png"><br>这样在改变<code>b</code>的值时，<code>a</code>就不会被影响了；同样的，改变<code>a</code>的值时，<code>b</code>也不会被影响。<br>再来看之前的例子：  </p><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span>a = []<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):<span class="meta">... </span>    a.append(<span class="number">0</span>)<span class="meta">... </span><span class="meta">&gt;&gt;&gt; </span>l = []<span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):<span class="meta">... </span>    l.append(a.copy())<span class="meta">... </span><span class="meta">&gt;&gt;&gt; </span>l[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]<span class="meta">&gt;&gt;&gt; </span>l[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">1</span><span class="meta">&gt;&gt;&gt; </span>l[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]<span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</code></pre><p>此时数据的存储方式如下：<br><img src="https://www.z4a.net/images/2020/05/03/img011.png" alt="img011.png">  </p><blockquote><p>其实可以通过更简单的方式创建多维0列表</p><pre><code class="python">l = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>)]</code></pre></blockquote><p>再来看一个实例：  </p><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]<span class="meta">&gt;&gt;&gt; </span>l = []<span class="meta">&gt;&gt;&gt; </span>l.append(a)<span class="meta">&gt;&gt;&gt; </span>l.append(<span class="number">0</span>)<span class="meta">&gt;&gt;&gt; </span>l[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="number">0</span>]<span class="meta">&gt;&gt;&gt; </span>m = l<span class="meta">&gt;&gt;&gt; </span>m[<span class="number">1</span>] = <span class="number">1</span><span class="meta">&gt;&gt;&gt; </span>m[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="number">1</span>]<span class="meta">&gt;&gt;&gt; </span>l[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="number">1</span>]<span class="meta">&gt;&gt;&gt; </span>n = l.copy()<span class="meta">&gt;&gt;&gt; </span>n[<span class="number">1</span>] = <span class="number">2</span><span class="meta">&gt;&gt;&gt; </span>n[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="number">2</span>]<span class="meta">&gt;&gt;&gt; </span>l[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="number">1</span>]<span class="meta">&gt;&gt;&gt; </span>n[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">1</span><span class="meta">&gt;&gt;&gt; </span>n[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], <span class="number">2</span>]<span class="meta">&gt;&gt;&gt; </span>l[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], <span class="number">1</span>]<span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</code></pre><p>为什么我在创建<code>n</code>的时候明明使用了<code>.copy()</code>，却还是在改变<code>n</code>的时候同时改变了<code>l</code>和<code>a</code>？<br>我们还是来看一下最后的状态下数据存储的方式：<br><img src="https://www.z4a.net/images/2020/05/03/img012.png" alt="img012.png"><br>虽然<code>n</code>确实是复制了<code>l</code>里的所有元素，但是<code>l[0]</code>这一项的值是“指向某一个<code>list</code>”，所以<code>l[0]</code>和<code>n[0]</code>还是指向了同一个<code>list</code>。<br>但是修改<code>n[1]</code>的时候，<code>l[1]</code>并没有一起改变，我们可以将<code>.copy()</code>理解为“只进行了一层复制”。这种复制称为<strong>浅复制</strong>。<br>如果我想创造一个列表，与之前的列表完全一样，但是完全独立，二者互不影响，该怎么办呢？<br>这时我们需要引入<code>copy</code>库来完成这样的操作。<br>（接上述交互式窗口）</p><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy<span class="meta">&gt;&gt;&gt; </span>s = copy.deepcopy(l)<span class="meta">&gt;&gt;&gt; </span>s[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], <span class="number">1</span>]<span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span><span class="meta">&gt;&gt;&gt; </span>s[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>], <span class="number">1</span>]<span class="meta">&gt;&gt;&gt; </span>l[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], <span class="number">1</span>]<span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</code></pre><p>这时，我们发现改变<code>s</code>的值也不会引起其他变量的变化。<br>存储方式：<br><img src="https://www.z4a.net/images/2020/05/03/img013.png" alt="img013.png"><br>这种复制是对于列表的每一层都进行了复制，所以叫做<strong>深复制</strong>。<br>（更常见的叫法是浅拷贝与深拷贝）  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Experiment #06&lt;br&gt;北航致真书院19级大学计算机基础第六次上机实验实验总结&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2019CCBSummary#MT</title>
    <link href="http://sutai.fun/2020/04/26/2019CCBSummary-MT/"/>
    <id>http://sutai.fun/2020/04/26/2019CCBSummary-MT/</id>
    <published>2020-04-25T20:34:00.000Z</published>
    <updated>2020-05-03T07:27:32.974Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Mid-Term Test<br>北航致真书院19级大学计算机基础阶段测试实验总结</p><a id="more"></a><h1 id="阶段测试问题汇总"><a href="#阶段测试问题汇总" class="headerlink" title="阶段测试问题汇总"></a>阶段测试问题汇总</h1><hr><h2 id="A-助教机器人"><a href="#A-助教机器人" class="headerlink" title="A.助教机器人"></a><font color=#0033FF>A.助教机器人</font></h2><p>这道题可能有些同学是复制的PDF文件上的句子，导致<code>fi</code>这两个字符被复制成了<code>ﬁ</code>这个奇怪的字符，从而 <strong><font color=#FF0000>WA</font></strong> 掉，着实可惜。<br>在复制文本时，优先复制代码框内部的文本。  </p><h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">s = input()<span class="keyword">if</span> s == <span class="string">'Why was I right on my machine, but WA on OJ?'</span>:    print(<span class="string">'OJ must be broken!'</span>)<span class="keyword">elif</span> s == <span class="string">'Why did my code work out the wrong result?'</span>:    print(<span class="string">'Output intermediate variables during running, and find error!'</span>)<span class="keyword">elif</span> s == <span class="string">'I do not know what data my code would go wrong on!'</span>:    print(<span class="string">'Here may be the data you need!'</span>)<span class="keyword">else</span>:    print(<span class="string">'Let me have a look.'</span>)</code></pre><p>具体代码部分不需要解释了。如果还有问题请查阅第二次上机实验相关内容。  </p><hr><h2 id="B-自闭程度"><a href="#B-自闭程度" class="headerlink" title="B.自闭程度"></a><font color=#0033FF>B.自闭程度</font></h2><p>同样也是复制的问题，题面上的数字是经过LaTeX渲染后的，里面的字符不一定是我们常用的字符。直接从题面复制的话，会被那个负号坑到。<br>还是上面那句话，优先复制代码框内部的文本。  </p><h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">n, m = map(int, input().split())mark = [<span class="number">0</span>] * n                              <span class="comment"># 默认每一道题都没有通过</span><span class="keyword">for</span> _ <span class="keyword">in</span> range(m):    a, b = map(int, input().split())    mark[a<span class="number">-1</span>] = b                           <span class="comment"># 直接更新题目状况</span>s = sum(mark)<span class="keyword">if</span> s == <span class="number">0</span>:    print(<span class="string">'998244353'</span>)<span class="keyword">elif</span> s == n:    print(<span class="string">'-998244353'</span>)<span class="keyword">else</span>:    print(<span class="number">50</span>*n<span class="number">-150</span>*s)</code></pre><p>需要注意的是题目中的前提条件，一道题目在AC后不会再有新的提交记录，所以我们可以直接覆盖更新题目的状况。  </p><hr><h2 id="C-汉诺塔栈"><a href="#C-汉诺塔栈" class="headerlink" title="C.汉诺塔栈"></a><font color=#0033FF>C.汉诺塔栈</font></h2><p>这道题目无论是直接模拟题面的描述还是将其本质问题抽象出来，都是可以完成的。<br>本质问题是冒泡排序，并且输出结果是互换位置的次数。  </p><h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">T = int(input())<span class="keyword">for</span> _ <span class="keyword">in</span> range(T):    lnums = list(map(int, input().split()))    count = <span class="number">0</span>    hanoi = [<span class="number">-1</span>]                            <span class="comment"># 防止访问越界，提前添加一个不会混淆的元素，代表汉诺塔底部</span>    stack = []                              <span class="comment"># 暂存用的栈，与上面的hanoi均用列表模拟</span>    <span class="keyword">for</span> plt <span class="keyword">in</span> lnums:                       <span class="comment"># plate，盘子（</span>        <span class="keyword">while</span> hanoi[<span class="number">-1</span>] != <span class="number">-1</span> <span class="keyword">and</span> hanoi[<span class="number">-1</span>] &lt; plt:            stack.append(hanoi.pop())       <span class="comment"># 不等于-1是指非底部</span>        hanoi.append(plt)                   <span class="comment"># 放入圆盘</span>        <span class="keyword">while</span> stack != []:                  <span class="comment"># 然后把暂存区的圆盘挪回去</span>            hanoi.append(stack.pop())            count += <span class="number">1</span>                      <span class="comment"># 每挪一个都要更新计数器</span>    print(count)</code></pre><p>这个是使用栈直接完成题面的描述，可以看出并不复杂。  </p><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="python">T = int(input())<span class="keyword">for</span> _ <span class="keyword">in</span> range(T):    lnums = list(map(int, input().split()))    lenth = len(lnums)    count = <span class="number">0</span>    flag = <span class="literal">True</span>    <span class="keyword">while</span> flag:                             <span class="comment"># 这里就是冒泡排序，注意我们要的是递减序列</span>        flag = <span class="literal">False</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, lenth):            <span class="keyword">if</span> lnums[i] &gt; lnums[i<span class="number">-1</span>]:                lnums[i], lnums[i<span class="number">-1</span>] = lnums[i<span class="number">-1</span>], lnums[i]                count += <span class="number">1</span>                  <span class="comment"># 在冒泡排序中加入计数器即可</span>                flag = <span class="literal">True</span>    print(count)</code></pre><p>使用冒泡排序的思想。将题面转化为冒泡排序思维量不小，感兴趣的同学可以想一下为什么这道题目是冒泡排序。  </p><hr><h2 id="D-异或序列"><a href="#D-异或序列" class="headerlink" title="D.异或序列"></a><font color=#0033FF>D.异或序列</font></h2><p>本次测试最具有区分度的一道题目，拿<code>0.6</code>分也不用太失落。<br>就像高考数学全国卷必做部分最后一道题一样，这道题的前<code>0.6</code>分就好像第一小问，再往后的<code>0.2</code>分就好像第二小问，最后<code>0.2</code>分就是超难的第三小问。<br>首先再解释一下异或运算。逻辑上的异或运算的法则是<code>A xor B</code>当且仅当<code>A</code>与<code>B</code>逻辑值不同时，运算结果为<code>True</code>，否则为<code>False</code>，可以使用符号<code>⊕</code>表示。真值表如下：<br>A|B|A xor B<br>:-:|:-:|:-:|<br><font color=5ECCFF>True</font>|<font color=5ECCFF>True</font>|<font color=FF5E5E>False</font><br><font color=5ECCFF>True</font>|<font color=FF5E5E>False</font>|<font color=5ECCFF>True</font><br><font color=FF5E5E>False</font>|<font color=5ECCFF>True</font>|<font color=5ECCFF>True</font><br><font color=FF5E5E>False</font>|<font color=FF5E5E>False</font>|<font color=FF5E5E>False</font>  </p><p>两个正整数间的按位异或则是将两个数转化为二进制，然后<code>0</code>对应<code>False</code>，<code>1</code>对应<code>True</code>，每一位进行异或运算，最后将结果转化为十进制。在<code>python</code>中，按位异或运算符是<code>^</code>，在英文输入法下使用<kbd>Shift</kbd>+<kbd>6</kbd>输入（中文输入法下会输入省略号）。<br>然后是异或运算的一些性质：  </p><blockquote><p>A xor A = 0<br>A xor 0 = A<br>A xor B = B xor A<br>A xor B = 0 iff A = B<br>A xor B = A iff B = 0<br>A xor B = C iff A xor C = B iff B xor C = A<br>(A xor B) xor C = A xor (B xor C)</p></blockquote><p>其中”iff”是”if and only if”的缩写，即“当且仅当”。<br>由于<code>python</code>程序<code>1s</code>内最多运行$10^6$次运算，所以如果想要<font color=#0033FF>AC</font>，则需要将时间复杂度优化为$O(n)$即线性。  </p><h4 id="正确答案（TLE-0-6）"><a href="#正确答案（TLE-0-6）" class="headerlink" title="正确答案（TLE 0.6）"></a><font color=#5ECCFF>正确答案（TLE 0.6）</font></h4><p>这里给出最终得分<code>0.6</code>的暴力解法。  </p><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(L)</span>:</span>    ans = <span class="number">0</span>    <span class="keyword">for</span> i <span class="keyword">in</span> L:        ans ^= i                            <span class="comment"># 等价于ans = ans ^ i</span>    <span class="keyword">return</span> ans                              <span class="comment"># 不要换了运算符就不认识了</span>n = int(input())lnums = list(map(int, input().split()))count = <span class="number">0</span><span class="keyword">for</span> i <span class="keyword">in</span> range(n):    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n+<span class="number">1</span>):               <span class="comment"># 这里是遍历了每一个可能的区间</span>        <span class="keyword">if</span> xor(lnums[i:j]) == <span class="number">0</span>:            count += <span class="number">1</span>print(count)</code></pre><p>这个时间复杂度是$O(n^3)$，所以对于$100$以内的数据可以在<code>1s</code>内完成。<br>计算时间复杂度时，注意函数的时间复杂度。  </p><h4 id="优化解法（TLE-0-8）"><a href="#优化解法（TLE-0-8）" class="headerlink" title="优化解法（TLE 0.8）"></a><font color=#33EEBB>优化解法（TLE 0.8）</font></h4><p>经过部分优化之后的程序，最终得分<code>0.8</code>.</p><pre><code class="python">n = int(input())lnums = list(map(int, input().split()))count = <span class="number">0</span><span class="keyword">for</span> i <span class="keyword">in</span> range(n):    xcur = <span class="number">0</span>    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):                   <span class="comment"># 这样避免重复运算，减少了运算量</span>        xcur ^= lnums[j]        <span class="keyword">if</span> xcur == <span class="number">0</span>:            count += <span class="number">1</span>print(count)</code></pre><p>其实还是直接翻译题面，不过是先固定了区间左端点，然后一次性找出所有满足条件的右端点，再换下一个左端点，避免了很多重复运算。<br><del>实际上并没有用到异或运算的特殊性质。</del><br>这个算法的时间复杂度是$O(n^2)$，所以对于$1000$以内的数据可以在<code>1s</code>内完成。  </p><h4 id="优化解法（AC）"><a href="#优化解法（AC）" class="headerlink" title="优化解法（AC）"></a><font color=#33EEBB>优化解法（AC）</font></h4><p>能够<font color=#0033FF>AC</font>这道题的算法比较难想，我想了半个小时才想出来。要将时间复杂度优化成线性，意味着我们只能够遍历一次序列。由于异或运算良好的性质，我们的运算可以得到很大程度的简化。<br>首先，异或运算同时满足交换律和结合律，这意味着异或运算可以像加法和乘法一样随意交换次序，并且可以从表达式的任何一个地方开始运算。<br>我们将题目给出的序列记为$\left{ a_{n} \right}$，如果有$a_i \oplus a_{i+1}\oplus\cdots\oplus a_j=0$，则必有<br>$$<br>\forall x,\quad x\oplus a_i\oplus a_{i+1}\oplus\cdots\oplus a_j = x<br>$$<br>则有<br>$$<br>a_1\oplus a_2\oplus\cdots\oplus a_j = a_1\oplus a_2\oplus\cdots\oplus a_{i-1}<br>$$<br>所以我们只需要创建出一个序列$\left{ b_{n} \right}$,使得$b_i = a_1\oplus a_2 \oplus\cdots\oplus a_i$,那么有如下性质<br>$$<br>\exist i,j,\quad b_i=b_j\Rightarrow a_{i+1}\oplus a_{i+2} \oplus\cdots\oplus a_j=0<br>$$<br>为了能够找出使得$b_i=0$的序列，需要规定$b_0=0$,这样就可以将$b_i$与之对应，找到从头开始的满足条件的序列。<br>举两个例子：</p><blockquote><p>有序列<code>1 2 4 5 3 6 4</code><br>我们将${a_n}$和${b_n}$列出来如下<br><code>a: - 1 2 4 5 3 6 4</code><br><code>b: 0 1 3 7 2 1 7 3</code><br>可以注意到$b_1=b_5=1,b_2=b_7=3,b_3=b_6=7$<br>则在${a_n}$中提取对应序列<code>2 4 5 3</code>,<code>4 5 3 6 4</code>和<code>5 3 6</code>，最终找到三个满足条件的序列</p></blockquote><blockquote><p>有序列<code>1 2 4 7 3 6 4 2</code><br><code>a: - 1 2 4 7 3 6 4 2</code><br><code>b: 0 1 3 7 0 3 5 1 3</code><br>有$b_0=b_4=0, b_1=b_7=1, b_2=b_5=b_8=3$<br>提取序列<code>1 2 4 7</code>,<code>2 4 7 3 6 4</code>,<code>4 7 3</code>,<code>6 4 2</code>,<code>4 7 3 6 4 2</code>总计五个<br>注意$b_2=b_5=b_8$贡献了$\left(2,5\right],(5,8],(2,8]$三个序列</p></blockquote><p>这样一来，问题就变得简单多了，代码也很短。  </p><pre><code class="python">n = int(input())lnums = list(map(int, input().split()))l = [<span class="number">0</span>] * <span class="number">100010</span>                            <span class="comment"># 创建好足够长的序列，l[i]指数字i在bn中出现过的次数</span>l[<span class="number">0</span>] = <span class="number">1</span>                                    <span class="comment"># b0=0，所以预先添加一个</span>xcur = <span class="number">0</span>                                    <span class="comment"># 用来记录bi的值</span>count = <span class="number">0</span><span class="keyword">for</span> i <span class="keyword">in</span> lnums:    xcur ^= i                               <span class="comment"># 计算bi</span>    count += l[xcur]                        <span class="comment"># 这个值出现过几次，则可以匹配到几个新的序列</span>    l[xcur] += <span class="number">1</span>                            <span class="comment"># 出现次数加一</span>print(count)</code></pre><p>对代码的第<code>9</code>行做更详细的说明：<code>count += l[xcur]</code></p><blockquote><p><code>l[x]</code>表示的是目前为止$x$在${b_n}$中出现了几次<br>这时如果再出现一次$x$，则这个$x$可以跟前面每一个$x$都形成一个序列<br>比如上面举的例子中<br><code>a: - 1 2 4 7 3 6 4 2</code><br><code>b: 0 1 3 7 0 3 5 1 3</code><br>在计算到最后一个值时,<code>x=3</code><br>而之前由于<code>3</code>出现了两次，所以<code>l[x]=2</code><br>所以最终结果加<code>2</code>，代表找到了<code>4 7 3 6 4 2</code>和<code>6 4 2</code>两个序列</p></blockquote><p>这个算法的时间复杂度是$O(n)$，所以对于$100000$以内的数据可以在<code>1s</code>内完成。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Mid-Term Test&lt;br&gt;北航致真书院19级大学计算机基础阶段测试实验总结&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2019CCBSummary#05</title>
    <link href="http://sutai.fun/2020/04/20/2019CCBSummary-05/"/>
    <id>http://sutai.fun/2020/04/20/2019CCBSummary-05/</id>
    <published>2020-04-19T16:48:12.000Z</published>
    <updated>2020-05-03T07:17:43.263Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Experiment #05<br>北航致真书院19级大学计算机基础第五次上机实验实验总结</p><a id="more"></a><h1 id="第五次实验问题汇总"><a href="#第五次实验问题汇总" class="headerlink" title="第五次实验问题汇总"></a>第五次实验问题汇总</h1><hr><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>可能有同学注意到了，后面几次的实验总结少了“错误示范”这个板块。因为现阶段已经很少有能够反映大家共有问题的十分典型的错误代码了，而且哪怕是相同的处理，不同的人写出来的代码也可能大相径庭。所以我删去了这个板块，希望大家在每一道题前面的描述里排除错误。如果出现了典型代码，我还是会放在总结里的。<br>——<em>斯太芬</em></p><hr><h2 id="A-逛超市"><a href="#A-逛超市" class="headerlink" title="A.逛超市"></a><font color=#0033FF>A.逛超市</font></h2><p>这道题目按理来说，不应该使用递归的方法，老老实实迭代才是即好想又好实现还省时省空间的方法。但是递归也可以做，而且不难。<br>常见的问题出在有些同学按照实验指导书上的思路决定递归，但是使用了两个函数分别表示优购和超市发的同学数量。<br>还有一些同学对变量的作用域不太清楚。在这里记住，如果在函数里面要用到函数外的变量，统统<code>global</code>一下就没有问题了，如果想在函数外用到函数里的变量，emmmmmm，尽量不要有这种想法，如果要这样做就作为返回值<code>return</code>给函数外界。  </p><h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y, n)</span>:</span>    <span class="keyword">if</span> n == <span class="number">1</span>:        <span class="keyword">return</span> x, y    <span class="keyword">else</span>:        <span class="keyword">return</span> f(<span class="number">0.2</span>*x+<span class="number">0.6</span>*y, <span class="number">0.8</span>*x+<span class="number">0.4</span>*y, n<span class="number">-1</span>)n = int(input())x, y = map(int, input().split())x, y = f(x, y, n)print(int(x), int(y))</code></pre><p>这里，为什么我的函数传了三个参数进去呢？因为事实上，迭代/递归的层数是已知的，而且无法通过去超市发和优购的人数判断递归终止条件，所以传入一个额外的参数来表示递归层数。  </p><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="python">n = int(input())x, y = map(int, input().split())<span class="keyword">for</span> i <span class="keyword">in</span> range(n):    x, y = <span class="number">0.2</span>*x+<span class="number">0.6</span>*y, <span class="number">0.8</span>*x+<span class="number">0.4</span>*yprint(int(x), int(y))</code></pre><p>大家自行感受一下。  </p><hr><h2 id="B-淡黄的长裙"><a href="#B-淡黄的长裙" class="headerlink" title="B.淡黄的长裙"></a><font color=#0033FF>B.淡黄的长裙</font></h2><p>这道题目是一道比较简单的遍历算法的题目，只需要遍历所有可能的价值取值，然后找出与心理预期差距最小的一个即可。<br>出现的比较多的问题是在一些特殊情况的处理上有一些问题，比如说推到小于4个方块的时候，还有一个问题是题意理解有误。注意题目所说的是那个圈住价格的方框长度为4，你所选的价格不足4位数的情况只可能发生在你把方块推到不足4个，而不是心理预期价位是几位数，方框就能圈住几个方块。  </p><h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">n = int(input())<span class="keyword">for</span> _ <span class="keyword">in</span> range(n):    s, p = input().split(<span class="string">','</span>)    p = int(p)    s = <span class="string">'0000'</span>+s                        <span class="comment"># 提前加4个0避免特判</span>    m = <span class="number">9999</span>                            <span class="comment"># 注意我们要求的是最小值，所以初始值一定要足够大</span>    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)<span class="number">-4</span>):           <span class="comment"># 这里可以看到是从前向后遍历，也就是从推到一个都不剩的时候开始的</span>        t = int(s[j:j+<span class="number">4</span>])               <span class="comment"># 字符串切片，对应方框圈住4个方块</span>        <span class="keyword">if</span> abs(t-p) &lt; m:                <span class="comment"># 注意这里不等号的使用</span>            l = j                       <span class="comment"># 存储的是找到最小值时的索引</span>            m = abs(t-p)    print(len(s)-l<span class="number">-5</span>)                   <span class="comment"># 直接通过先前存储的索引计算输出值，不用再用.index()找索引</span></code></pre><p>这里不等号的使用主要取决于以下这一点：当你碰到与当前的最大/最小值相等的值的时候，需不需要替换。比如这里，由于我相当于是逆向找解，所以原题要求推方块最多的解，我这里就需要找到的是第一次遇到的解。所以我用的是小于号而不是小于等于号。这样保留的就是第一次遇到的了；如果我是正向找解，也就是模拟游戏过程，从最右边开始4个4个切片，那么我其实是需要保留更靠后的结果的，所以这样的话就需要用小于等于号。<br>关于《Python周报》中提到的一些问题，可以看到Marvolo大佬很喜欢用整型数处理问题，而我给出的代码使用字符串处理问题会多一些。Marvolo是<br>C/C++出身，所以他的代码风格会偏向C/C++一些。这里，我给出的代码，使用的是字符串处理这道题目。但是我并没有任何多余的数据类型转换。我看到很多同学的代码有多余的数据类型转换，这样很费时间，所以转换数据类型的时候，只做必要的部分。而且对于整数进行运算确实比对字符串进行运算要更快，只是目前我们所涉及到的代码还不足以体现这两者的区别。字符串可以帮助我们更直观地理解代码的工作进程，但是在复杂运算的时候，我们还是应该采用整型数据来节约时间。<br>看下面的样例：</p><pre><code class="python">s, p = map(int, input().split(<span class="string">','</span>))s = str(s)</code></pre><p>这两行代码可以替换掉我上面的程序的两行代码，效果不变。但是我的代码只进行了一次数据类型转换，而这个代码进行了三次类型转换，而且<code>s</code>这个变量则是先从<code>str</code>转换为<code>int</code>，又转换为了<code>str</code>，明显是多此一举的行为，而且进行一次数据转换的运算量可比进行一次赋值运算要大得多。所以要避免不必要的数据类型转换。  </p><hr><h2 id="C-排列组合"><a href="#C-排列组合" class="headerlink" title="C.排列组合"></a><font color=#0033FF>C.排列组合</font></h2><p>标题是排列组合，其实是组合。典型的深度优先遍历，需要配合全局变量。这里的字典序一定要注意，<code>12</code>作为一个整数元素的时候，是在<code>2</code>之后的。有的同学试图在使用字符串存储结果后用<code>.sort()</code>方法完成排序，但是这样的话<code>&#39;12&#39;</code>按照字符串字典序是在<code>&#39;2&#39;</code>之前的，所以这里不能使用字符串。当然更好的方法就是在遍历的时候就按照字典序一个一个找出来。  </p><h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(p)</span>:</span>                             <span class="comment"># 这里传入的参数p是标记位置的</span>    <span class="keyword">global</span> mark                         <span class="comment"># 定义全局变量</span>    s = sum(mark)                       <span class="comment"># 如果选中m个，那么输出这种情况，并结束这个分支</span>    <span class="keyword">if</span> s == m:        print_()        <span class="keyword">return</span>    <span class="keyword">else</span>:        <span class="keyword">if</span> p &gt;= n:                      <span class="comment"># 标记超出边界，结束分支</span>            <span class="keyword">return</span>        <span class="keyword">else</span>:            mark[p] = <span class="number">1</span>                 <span class="comment"># 选中标记位置的情况</span>            dfs(p+<span class="number">1</span>)            mark[p] = <span class="number">0</span>                 <span class="comment"># 不选标记位置的情况</span>            dfs(p+<span class="number">1</span>)<span class="function"><span class="keyword">def</span> <span class="title">print_</span><span class="params">()</span>:</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):        <span class="keyword">if</span> mark[i]:            print(<span class="string">"%d"</span>%(i+<span class="number">1</span>), end=<span class="string">' '</span>)    print()n, m = map(int, input().split())mark = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]            <span class="comment"># 0表示没有选，1表示选中</span>dfs(<span class="number">0</span>)                                  <span class="comment"># 从第0个位置，也就是1开始选</span></code></pre><p>单独看代码可能有点难以理解，这里以5选3为例，说明一下过程：  </p><blockquote><p>首先<code>mark</code>是<code>[0, 0, 0, 0, 0]</code>，从左到右分别代表1, 2, 3, 4, 5的选择情况<br>然后看图8<br><img src="https://www.z4a.net/images/2020/04/20/5.jpg" alt="5.jpg"></p></blockquote><pre><code class="python">n, m = map(int, input().split())l = [[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">2</span>-m)]<span class="keyword">while</span> len(l[<span class="number">0</span>]) &lt; m:    temp = l.pop(<span class="number">0</span>)    s = temp[<span class="number">-1</span>]    <span class="keyword">for</span> i <span class="keyword">in</span> range(s+<span class="number">1</span>, n - m + len(temp) + <span class="number">2</span>):        l.append(temp + [i])<span class="keyword">for</span> t <span class="keyword">in</span> l:    <span class="keyword">for</span> r <span class="keyword">in</span> t:        print(r, end=<span class="string">' '</span>)    print()</code></pre><p>另一个思路是使用队列，大家可以自行感受一下，比较简单。</p><hr><h2 id="D-买辣条（选做）"><a href="#D-买辣条（选做）" class="headerlink" title="D.买辣条（选做）"></a><font color=#0033FF>D.买辣条（选做）</font></h2><p><del>这道题目是我在吃辣条的时候想出来的</del>，与上一道题目比较相似，不过需要求出全排列。  </p><h4 id="正确答案-3"><a href="#正确答案-3" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">fp</span><span class="params">(l)</span>:</span>    <span class="keyword">if</span> len(l) == <span class="number">1</span>:        <span class="keyword">return</span> [l]    <span class="keyword">else</span>:        ans = []        <span class="keyword">for</span> i <span class="keyword">in</span> l:            nl = l[:]            nl.remove(i)            xl = fp(nl)            <span class="keyword">for</span> j <span class="keyword">in</span> xl:                ans.append([i]+j)        <span class="keyword">return</span> ansn = int(input())l = list(map(int, input().split()))p = fp([i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)])m = n*n<span class="keyword">for</span> i <span class="keyword">in</span> p:    s = <span class="number">0</span>    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):        s += l[j] % i[j]    <span class="keyword">if</span> s &lt; m:        m = sprint(m)</code></pre><p>我所给出的方法没有用到全局变量，采用的是一个很容易理解的递归思路，很多同学也是尝试使用这个思路。这样做的话，最后一个数据点的运行时间通常在2000ms以上，内存占用在66000KB以上，是一个对时空要求都比较高的方法。<br>如果使用类似于上一道题目里队列的做法，那么最后一个数据点会<font color=#FF0000>TLE</font>，递归但是常数稍大的也会<font color=#FF0000>TLE</font>，所以最好还是使用类似于上一道题目里的方法。  </p><h4 id="优化解法-1"><a href="#优化解法-1" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">Dfs</span><span class="params">(x)</span>:</span>    <span class="keyword">global</span> ans,cnt    <span class="keyword">if</span> (x==n):        ans=min(ans,cnt)        <span class="keyword">return</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):    <span class="keyword">if</span> (v[i]==<span class="number">0</span>):        v[i]=<span class="number">1</span>        cnt+=a[x]%(i+<span class="number">1</span>)        Dfs(x+<span class="number">1</span>)        cnt-=a[x]%(i+<span class="number">1</span>)        v[i]=<span class="number">0</span>n=int(input())a=list(map(int,input().split()))ans=<span class="number">0x3f3f3f3f</span>cnt=<span class="number">0</span>v=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]Dfs(<span class="number">0</span>)print(ans)</code></pre><p>照抄周报了，大家轻点喷。  </p><h4 id="奇怪的解法"><a href="#奇怪的解法" class="headerlink" title="奇怪的解法"></a><font color=#9966FF>奇怪的解法</font></h4><p>这一部分由于非常超纲，就不放代码了，感兴趣的同学可以自行了解一下。<br>周报中提及的状态压缩动态规划可以解决这道题目，当然整数规划指派问题也可以解决这道题目，这些都是运筹学的内容，不要求大家掌握。  </p><hr><h2 id="E-连锁反应（选做）"><a href="#E-连锁反应（选做）" class="headerlink" title="E.连锁反应（选做）"></a><font color=#0033FF>E.连锁反应（选做）</font></h2><p>我相信很多人看到这道题目的一瞬间，脑袋都有点懵。截止这篇总结编写的时候，只有58个人尝试提交了这道题目，而且这其中还有助教（有可能还有老师）。其实这道题目思路并不难，只是想到这个思路，对于没有软件开发经历的人来说会困难一些。  </p><h4 id="正确答案-4"><a href="#正确答案-4" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><p>先给出思路。题目中叫做消除，我个人更喜欢叫引爆。我们需要做的就是在棋盘上引爆某一个道具，然后看看最终会变成什么样子。<br>既然我们做的只是引爆某一个道具，然后这个道具可能会引爆别的道具，那么我们只需要编写一个可以适用于所有道具的“引爆函数”即可。对于普通的<code>0123456789</code>，引爆就是把它们替换成空格（或者任意一个不会引起歧义的符号均可，便于之后的操作）；对于一个特殊道具，引爆这个道具则不仅仅要把它替换成空格，还要对其他的一些道具进行引爆操作。这样的话，一个递归思路的函数就出来了。  </p><pre><code class="python">a, b = map(int, input().split(<span class="string">','</span>))board = []                              <span class="comment"># 面板，直白一点的命名多好</span><span class="keyword">for</span> i <span class="keyword">in</span> range(b):    board.append(list(input()))x, y = map(int, input().split(<span class="string">','</span>))num = <span class="string">'0123456789'</span>alp = <span class="string">'QWERTYUIOP'</span>                      <span class="comment"># 存储消除特定数字的道具</span><span class="function"><span class="keyword">def</span> <span class="title">explo</span><span class="params">(x, y)</span>:</span>                        <span class="comment"># explose引爆</span>    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> range(a) <span class="keyword">or</span> y <span class="keyword">not</span> <span class="keyword">in</span> range(b):        <span class="keyword">return</span>                          <span class="comment"># 对于会越界的操作，终止掉，在引爆X时有可能会越界</span>    <span class="keyword">global</span> board                        <span class="comment"># 注意全局变量</span>    curr = board[y][x]                  <span class="comment"># current,用于存放当前值的一个常用变量名</span>    <span class="keyword">if</span> curr == <span class="string">' '</span>:        <span class="keyword">return</span>    <span class="keyword">else</span>:        board[y][x] = <span class="string">' '</span>               <span class="comment"># 因为已经存到了curr，而且无论如何这一格都要变成空格</span>    <span class="keyword">if</span> curr <span class="keyword">in</span> num:        <span class="keyword">return</span>    <span class="keyword">if</span> curr == <span class="string">'v'</span>:        <span class="keyword">for</span> i <span class="keyword">in</span> range(b):              <span class="comment"># 对这一列所有元素进行引爆</span>            explo(x, i)    <span class="keyword">if</span> curr == <span class="string">'&gt;'</span>:        <span class="keyword">for</span> i <span class="keyword">in</span> range(a):              <span class="comment"># 对这一行所有元素进行引爆</span>            explo(i, y)    <span class="keyword">if</span> curr == <span class="string">'X'</span>:        <span class="keyword">for</span> i <span class="keyword">in</span> (y<span class="number">-1</span>, y, y+<span class="number">1</span>):         <span class="comment"># 对九宫格进行引爆，因为之前有判断，所以不用担心越界</span>            <span class="keyword">for</span> j <span class="keyword">in</span> (x<span class="number">-1</span>, x, x+<span class="number">1</span>):                explo(j, i)    <span class="keyword">if</span> curr <span class="keyword">in</span> alp:        t = num[alp.index(curr)]        <span class="keyword">for</span> i <span class="keyword">in</span> range(a):              <span class="comment"># 遍历面板，对特定数字进行引爆</span>            <span class="keyword">for</span> j <span class="keyword">in</span> range(b):                <span class="keyword">if</span> board[j][i] == t:                    explo(i, j)explo(x<span class="number">-1</span>, y<span class="number">-1</span>)                         <span class="comment"># 注意坐标起始值</span><span class="keyword">for</span> i <span class="keyword">in</span> range(a):                      <span class="comment"># 这里进行落下的操作，可以写成很多种样子，我这里稍显繁琐</span>    count = <span class="number">0</span>    temp = []    <span class="keyword">for</span> j <span class="keyword">in</span> range(b):        <span class="keyword">if</span> board[j][i] == <span class="string">' '</span>:            count += <span class="number">1</span>        <span class="keyword">else</span>:            temp.append(board[j][i])    temp = [<span class="string">' '</span>]*count + temp    <span class="keyword">for</span> j <span class="keyword">in</span> range(b):        board[j][i] = temp[j]<span class="keyword">for</span> i <span class="keyword">in</span> range(b):    print(<span class="string">''</span>.join(board[i]))</code></pre><p>关于引爆<code>X</code>越界，当<code>X</code>在面板边界的时候，会发生越界，所以函数开头需要验证一下。<br>有一点需要注意的地方，这道题目使用的是原点在左上角的xOy坐标轴记录位置信息，与我们平时比较常用的“第x行第y列”有所不同，所以在传参和访问元素的时候一定记得核实变量顺序。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Experiment #05&lt;br&gt;北航致真书院19级大学计算机基础第五次上机实验实验总结&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2019CCBSummary#04</title>
    <link href="http://sutai.fun/2020/04/13/2019CCBSummary-04/"/>
    <id>http://sutai.fun/2020/04/13/2019CCBSummary-04/</id>
    <published>2020-04-12T18:44:21.000Z</published>
    <updated>2020-05-03T07:51:30.802Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Experiment #04<br>北航致真书院19级大学计算机基础第四次上机实验实验总结</p><a id="more"></a><h1 id="第四次实验问题汇总"><a href="#第四次实验问题汇总" class="headerlink" title="第四次实验问题汇总"></a>第四次实验问题汇总</h1><hr><p>本次试验中需要用到栈和队列这两种数据结构。为了演示自定义类的实际应用，这篇总结的A.C.E三道题均使用了<code>class Stack():</code>的自定义类来存储栈结构。现给出栈的定义。  </p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">()</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>        self.items = []    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span>        self.items.append(item)    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span>        <span class="keyword">if</span> self.is_empty():            <span class="keyword">raise</span> Exception(<span class="string">'stackIsEmpty'</span>)        <span class="keyword">else</span>:            <span class="keyword">return</span> self.items.pop()    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span>        <span class="keyword">if</span> self.is_empty():            <span class="keyword">raise</span> Exception(<span class="string">'stackIsEmpty'</span>)        <span class="keyword">else</span>:            <span class="keyword">return</span> self.items[<span class="number">-1</span>]    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span>        <span class="keyword">return</span> self.items == []    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span>        <span class="keyword">return</span> len(self.items)</code></pre><hr><h2 id="A-修电脑"><a href="#A-修电脑" class="headerlink" title="A.修电脑"></a><font color=#0033FF>A.修电脑</font></h2><p>经典的使用堆栈处理指令的题目，只需要根据输入决定入栈还是出栈即可。<br>需要注意的是，题目中并没有说指令只有一个字母！所以逐字符读取和使用了<code>.isalpha()</code>的都是思路跑偏了，实际上不复杂。  </p><h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">n = int(input())commands = Stack()                              <span class="comment"># 实例化</span><span class="keyword">for</span> i <span class="keyword">in</span> range(n):    com = input()    <span class="keyword">if</span> com == <span class="string">'Ctrl+Z'</span>:                         <span class="comment"># 判断指令是否为撤销</span>        commands.pop()    <span class="keyword">else</span>:        commands.push(com)print(<span class="string">"/"</span>.join(commands.items))                 <span class="comment"># 使用self.items可以直接访问items对象</span><span class="comment"># 最后输出时，可以直接访问类中创建的列表，也可以逐一进行pop操作后逆序输出。</span></code></pre><p><code>.join()</code>是非常实用的方法，希望大家都可以掌握。  </p><hr><h2 id="B-老千层饼"><a href="#B-老千层饼" class="headerlink" title="B.老千层饼"></a><font color=#0033FF>B.老千层饼</font></h2><p>题目的本意是使用队列来从小到大存储“千层饼”。有的同学在生成新“千层饼”并传入的时候没有将已经用过的千层饼删除，这样有两个问题。其一是如果是删除后再填进去的话，会有很多的重复；第二是即便没有重复，当<code>n</code>值很大的时候，列表会变得非常长，这样在访问靠后的元素的时候会非常浪费时间，从而导致<font color=#FF0000>TLE</font>.<br>有的同学在按数位依次递减的时候，减到了0以下，产生了<code>2100-10</code>这样的奇怪输出。  </p><h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><p>暴力解法，注意不优化的话会<font color=#FF0000>TLE</font>，需要一定程度的优化。  </p><pre><code class="python">n = int(input())<span class="keyword">if</span> <span class="number">1</span>&lt;=n&lt;=<span class="number">12</span>:    print(n)<span class="keyword">else</span>:    n -= <span class="number">12</span>    i = <span class="number">20</span>    flag = <span class="literal">False</span>    <span class="keyword">while</span> n:                                    <span class="comment"># 这里写成 while n!=0: 更容易理解</span>        <span class="keyword">if</span> flag:            i += <span class="number">9</span>            flag = <span class="literal">False</span>        <span class="keyword">else</span>:            i += <span class="number">1</span>        s = str(i)        <span class="keyword">if</span> ord(s[<span class="number">-1</span>])-ord(s[<span class="number">-2</span>]) == <span class="number">1</span>:          <span class="comment"># 末两位递增，可以一次排除掉8个非千层饼</span>            flag = <span class="literal">True</span>        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):               <span class="comment"># 对每相邻的两位进行判断</span>            <span class="keyword">if</span> abs(ord(s[j])-ord(s[j+<span class="number">1</span>])) &gt; <span class="number">1</span>:                <span class="keyword">break</span>        <span class="keyword">else</span>:                                   <span class="comment"># 找到一个千层饼，n-1</span>            n -= <span class="number">1</span>    print(i)</code></pre><p>不难看出，如果一个“千层饼”是以“67”这种严格增序列结尾的，那么下一个“千层饼”一定是+9之后的产物，这样可以优化枚举的过程，从而在规定时间内完成输出。  </p><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="python">n = int(input())nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)]                <span class="comment"># 模拟队列</span><span class="keyword">while</span> n:    a = nums.pop(<span class="number">0</span>)    d = a % <span class="number">10</span>    <span class="keyword">if</span> d == <span class="number">0</span>:                                  <span class="comment"># 通过末尾的数字判断添加的数</span>        nums.append(<span class="number">10</span>*a)        nums.append(<span class="number">10</span>*a+<span class="number">1</span>)    <span class="keyword">elif</span> d == <span class="number">9</span>:        nums.append(<span class="number">10</span>*a+<span class="number">8</span>)        nums.append(<span class="number">10</span>*a+<span class="number">9</span>)    <span class="keyword">else</span>:        nums.append(<span class="number">10</span>*a+d<span class="number">-1</span>)        nums.append(<span class="number">10</span>*a+d)        nums.append(<span class="number">10</span>*a+d+<span class="number">1</span>)    n -= <span class="number">1</span>print(a)<span class="comment"># 这道题目的答案应该很好理解，如果实在难以理解不妨仿照这个程序在纸上画一画。</span></code></pre><p>本题的原意是使用队列完成。<br>在这里画出前几次吧，便于大家理解。  </p><blockquote><p>[1, 2, 3, 4, 5, 6, 7, 8, 9]<br>[<del>1</del>, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]<br>[<del>1</del>, <del>2</del>, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 21, 22, 23]<br>[<del>1</del>, <del>2</del>, <del>3</del>, 4, 5, 6, 7, 8, 9, 10, 11, 12, 21, 22, 23, 32, 33, 34]</p><p><del>这些是看到实验指导书之前写的，没想到指导书直接给出了这个。</del>  </p></blockquote><h4 id="奇怪的解法"><a href="#奇怪的解法" class="headerlink" title="奇怪的解法"></a><font color=#9966FF>奇怪的解法</font></h4><p>由于我刚开始会错了题意，于是诞生了这个稍显奇怪的使用栈完成的程序。</p><pre><code class="python">n = int(input())S = [<span class="number">-2</span>, <span class="number">1</span>]                                     <span class="comment"># 模拟栈，并提前压入两个数据，其中-2用于标记首位，防止越界</span>digits = <span class="number">1</span>                                      <span class="comment"># 该栈存储的是各个位上的数字</span><span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):                            <span class="comment"># 每经过一次循环，栈内存的数字就表示下一个更大的千层饼</span>    dpopped = <span class="number">1</span>    t = S.pop()                                 <span class="comment"># 取末尾数字</span>    <span class="keyword">while</span> ((t == <span class="number">9</span>) <span class="keyword">or</span> (t == S[<span class="number">-1</span>]+<span class="number">1</span>)) <span class="keyword">and</span> S[<span class="number">-1</span>] != <span class="number">-2</span>:        dpopped += <span class="number">1</span>                            <span class="comment"># 末尾数字达到9或者比次末位大1，则需要进位</span>        t = S.pop()                             <span class="comment"># dpopped记录需要进位的位数</span>    <span class="keyword">if</span> S[<span class="number">-1</span>] == <span class="number">-2</span>:                             <span class="comment"># 这里判断是否要改变首位</span>        <span class="keyword">if</span> t == <span class="number">9</span>:                              <span class="comment"># 首位是9，则变成1000...</span>            S += [<span class="number">1</span>]+[<span class="number">0</span>]*digits            digits += <span class="number">1</span>        <span class="keyword">else</span>:                                   <span class="comment"># 否则首位加一，后续依次递减</span>            S.append(t+<span class="number">1</span>)            <span class="keyword">for</span> j <span class="keyword">in</span> range(digits<span class="number">-1</span>):                S.append(max(t-j,<span class="number">0</span>))            <span class="comment"># 注意此处max()函数的使用，不要减到0以下</span>    <span class="keyword">else</span>:        <span class="keyword">for</span> j <span class="keyword">in</span> range(dpopped):                <span class="comment"># 从右向左第一个不用进位的数位+1，向后依次递减</span>            S.append(max(t+<span class="number">1</span>-j,<span class="number">0</span>))              <span class="comment"># 此处也是</span>S.pop(<span class="number">0</span>)                                        <span class="comment"># 把-2删掉</span><span class="keyword">for</span> i <span class="keyword">in</span> S:    print(i, end=<span class="string">''</span>)</code></pre><p>另外，此题可打表，但是打表完全是为了做题而做题，完全不能体现题目价值。  </p><hr><h2 id="C-破解虫洞"><a href="#C-破解虫洞" class="headerlink" title="C.破解虫洞"></a><font color=#0033FF>C.破解虫洞</font></h2><p>这道题目本质上是前缀表达式。由于题目保证所有数字都是一位数，所以可以安心地逐个读取字符。<br>所谓前缀表达式，是将运算符放到数据之前，这样不需要括号来规定运算顺序也不会产生歧义。<br>与之对应的有后缀表达式以及我们常用的中缀表达式。<br>简单来讲，中缀表达式中<code>2 - 1</code>使用前缀表达式表示为<code>- 2 1</code>，使用后缀表达式表示为<code>2 1 -</code>；<br>稍复杂的例子如下：  </p><blockquote><p>举例：<br>中缀表达式：<code>3*(6+4*(5-3))-2</code><br>计算过程：<code>3*(6+4*(5-3))-2 = 3*(6+4*2)-2 = 3*(6+8)-2 = 3*14-2 = 42-2 = 40</code></p><hr><p>前缀表达式：<code>- * 3 + 6 * 4 - 5 3 2</code><br>计算过程： <strong>从后向前</strong> 依次读取入栈，读取到运算符时出栈两次并执行操作， <strong>顺序为（顶元素 操作 次顶元素）</strong> ，然后将结果入栈。<br>（个人喜欢用竖杠表示栈底，意为此处不可进出元素）<br>先依次入栈，得到<code>|2, 3, 5</code><br><code>|2, 3, 5</code>，当前元素<code>-</code>，剩余未读取<code>- * 3 + 6 * 4</code><br>出栈两次，执行<code>- 5 3</code>，结果为<code>2</code>，入栈<br><code>|2, 2</code>，当前元素<code>4</code>，剩余未读取<code>- * 3 + 6 *</code><br>入栈直至读取到运算符，此时<br><code>|2, 2, 4</code>，当前元素<code>*</code>，剩余未读取<code>- * 3 + 6</code><br>出栈两次，执行<code>* 4 2</code>，结果为<code>8</code>，入栈<br><code>|2, 8</code>，当前元素<code>6</code>，入栈，剩余未读取<code>- * 3 +</code><br><code>|2, 8, 6</code>，当前元素<code>+</code>，剩余未读取<code>- * 3</code><br><code>|2, 14</code>，当前元素<code>3</code>，入栈，剩余未读取<code>- *</code><br><code>|2, 14, 3</code>，当前元素<code>*</code>，剩余未读取<code>-</code><br><code>|2, 42</code>，当前元素<code>-</code>，执行最后一次操作，得到最终结果<code>40</code></p><hr><p>后缀表达式：<code>3 6 4 5 3 - * + * 2 -</code><br>计算过程： <strong>从前向后</strong> 依次读取入栈，读取到运算符时出栈两次并执行操作， <strong>顺序为（次顶元素 操作 顶元素）</strong> ，然后将结果入栈。<br>先依次入栈，得到<code>|3, 6, 4, 5, 3</code><br>然后读取到<code>-</code>，出栈两次，执行<code>5 3 -</code>，结果为<code>2</code>，入栈<br><code>|3, 6, 4, 2</code>，当前元素<code>*</code>，剩余未读<code>+ * 2 -</code><br>出栈两次，执行<code>4 2 *</code>，结果为<code>8</code>，入栈<br><code>|3, 6, 8</code>，当前元素<code>+</code>，剩余未读<code>* 2 -</code><br><code>|3, 14</code>，当前元素<code>*</code>，剩余未读<code>2 -</code><br><code>|42</code>，当前元素<code>2</code>，剩余未读<code>-</code><br><code>|42, 2</code>，最后一个操作符<code>-</code>，执行<code>42 2 -</code>，得到最终结果<code>40</code></p></blockquote><h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><p>当然，如果不了解前缀表达式的话，不容易想到从后向前读取的方法。这里提供一个从前向后读取的方法。<br>思路就是函数符号和数字依次入栈，当栈顶两元素均为数时，运行栈顶三个元素组成的函数并入栈。当数据读完之后，栈内仅剩一个元素，即最终结果。  </p><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span>    <span class="keyword">return</span> (x + <span class="number">42</span>*y) / (<span class="number">42</span>*x + y)<span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x, y)</span>:</span>    <span class="keyword">return</span> (x*y) / (<span class="number">42</span>*x - <span class="number">42</span>*y)coms = Stack()                                  <span class="comment"># 实例化</span>s = input().replace(<span class="string">'('</span>, <span class="string">''</span>).replace(<span class="string">')'</span>, <span class="string">''</span>).replace(<span class="string">','</span>, <span class="string">''</span>)<span class="keyword">for</span> c <span class="keyword">in</span> s:                                     <span class="comment"># 删掉括号和逗号</span>    <span class="keyword">if</span> c.isdigit():        <span class="keyword">while</span> coms.peek() <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'fg'</span>:          <span class="comment"># 判断是否连续两个数字</span>            temp = coms.pop()                   <span class="comment"># 因为有可能运算完成之后仍然是连续两个数字</span>            opr = coms.pop()                    <span class="comment"># 所以需要用while循环</span>            <span class="keyword">if</span> opr == <span class="string">'f'</span>:                temp = str(f(float(temp), float(c)))            <span class="keyword">else</span>:                temp = str(g(float(temp), float(c)))            c = temp            <span class="keyword">if</span> coms.is_empty():                 <span class="comment"># 当栈为空说明运算完成了，提前跳出避免报错</span>                <span class="keyword">break</span>    coms.push(c)print(<span class="string">"%.7f"</span>%float(coms.pop()))</code></pre><h4 id="优化解法-1"><a href="#优化解法-1" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span>    <span class="keyword">return</span> (x + <span class="number">42</span>*y) / (<span class="number">42</span>*x + y)<span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x, y)</span>:</span>    <span class="keyword">return</span> (x*y) / (<span class="number">42</span>*x - <span class="number">42</span>*y)coms = Stack()                                  <span class="comment"># 实例化</span>s = list(input())                               <span class="comment"># 使用list是为了后续使用.reverse()方法</span>s.reverse()                                     <span class="comment"># 逆序便于完成从后向前读取</span><span class="keyword">for</span> c <span class="keyword">in</span> s:    <span class="keyword">if</span> c.isdigit():                             <span class="comment"># 将数字入栈</span>        coms.push(int(c))    <span class="keyword">elif</span> c == <span class="string">'f'</span>:                              <span class="comment"># 遇到函数符则将栈顶两元素弹出，运算后入栈</span>        coms.push(f(coms.pop(), coms.pop()))    <span class="comment"># 要注意出栈顺序</span>    <span class="keyword">elif</span> c == <span class="string">'g'</span>:        coms.push(g(coms.pop(), coms.pop()))print(<span class="string">"%.7f"</span>%coms.pop())</code></pre><blockquote><p>首先明确一点，括号和逗号并不能影响运算，所以我们将其排除。<br>然后使用样例举例:<code>f(9, g(f(5, 2), 7))</code><br>去掉括号后变成<code>f, 9, g, f, 5, 2, 7</code><br>逆序之后变成<code>7, 2, 5, f, g, 9, f</code><br>然后从前向后读取。首先读到<code>7, 2, 5</code>，均入栈。此时栈内元素为<br><code>|7, 2, 5</code><br>然后读取到<code>f</code>，则出栈两次，依次得到<code>5</code>，<code>2</code>，然后施加<code>f(x, y)</code>函数<br>将函数的返回值<code>f(5, 2)</code>入栈。此时栈内元素为<br><code>|7, f(5, 2)</code><br>然后读到<code>g</code>，出栈两次得到<code>f(5, 2)</code>和<code>7</code>，施加<code>g(x, y)</code>函数，将返回值入栈。此时栈内元素为<br><code>|g(f(5, 2), 7)</code><br>然后读取<code>9</code>，入栈，栈内元素为<br><code>|g(f(5, 2), 7), 9</code><br>最后读到<code>f</code>，出栈两次后运算，结果入栈。此时栈内仅剩一个元素<br><code>|f(9, g(f(5, 2), 7))</code>，即为最终结果。</p></blockquote><h4 id="奇怪的解法-1"><a href="#奇怪的解法-1" class="headerlink" title="奇怪的解法"></a><font color=#9966FF>奇怪的解法</font></h4><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span>    <span class="keyword">return</span> (x + <span class="number">42</span>*y) / (<span class="number">42</span>*x + y)<span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x, y)</span>:</span>    <span class="keyword">return</span> (x*y) / (<span class="number">42</span>*x - <span class="number">42</span>*y)print(<span class="string">"%.7f"</span>%eval(input()))</code></pre><p>很不幸，我一直强调的不要使用的<code>eval()</code>函数可以轻松解决这道题目（并且使这道题目失去其原有价值）。但是如此这般使用<code>eval(input())</code>仅限于OJ题目测评，因为这样的形式会使得代码的强壮程度急剧下降， <strong>非常不建议直接在<code>input()</code>外套用<code>eval()</code>函数！</strong><br><strong><font color=#FF0000>实验报告上不要出现这个解法！</font></strong>  </p><hr><h2 id="D-合理复习（选做）"><a href="#D-合理复习（选做）" class="headerlink" title="D.合理复习（选做）"></a><font color=#0033FF>D.合理复习（选做）</font></h2><p>这道题又是构造类题目，代码不难，难在思维上。只需要明白可供复习的时间总长大于等于需要的时间总长就一定可以给出一个复习方案。我们只需要证明用$1$到$n$的所有正整数可以从中挑出若干不重复的整数，使之和为$\left[ 1, \frac {n \left( n+1 \right)}{2} \right]$中任意一个整数即可。<br>具体构造方法如下：  </p><blockquote><p>对于$\left[1, n\right]$中的整数，直接取自身即可；<br>对于接下来的$\left[n+1, n+\left(n-1\right)\right]$中的整数，取$n$，再从剩下的数中取一个即可；<br>对于接下来的$\left[n+\left(n-1\right)-1, n+\left(n-1\right)+\left(n-2\right)\right]$中的整数，取$n$和$n-1$，再取剩下的数中的一个；<br>以此类推即可证明以上结论。  </p></blockquote><p>因此这道题就变成了找到最小的$n$，使得$\sum^{n}_{i=1} i \ge x$.  </p><h4 id="正确答案-3"><a href="#正确答案-3" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">a, b = map(int, input().split())s = (a+b)*<span class="number">2</span>i = <span class="number">1</span><span class="keyword">while</span> <span class="literal">True</span>:    <span class="keyword">if</span> (i*(i+<span class="number">1</span>)&gt;=s):        print(i)        <span class="keyword">break</span>    i += <span class="number">1</span><span class="comment"># 通过枚举的方法正向找到解，注意压常数</span></code></pre><h4 id="优化解法-2"><a href="#优化解法-2" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="python"><span class="keyword">import</span> math <span class="keyword">as</span> ma, b = map(int, input().split())c = a + bn = (m.sqrt(<span class="number">8</span> * c + <span class="number">1</span>) - <span class="number">1</span>) / <span class="number">2</span>print(m.ceil(n))<span class="comment"># 求公式反向求解</span></code></pre><p>$$<br>\frac {n(n+1)}{2} \ge x \Rightarrow n = \left\lceil \frac{\sqrt{8x+1}-1}{2} \right\rceil<br>$$</p><hr><h2 id="E-复杂相对分子质量（选做）"><a href="#E-复杂相对分子质量（选做）" class="headerlink" title="E.复杂相对分子质量（选做）"></a><font color=#0033FF>E.复杂相对分子质量（选做）</font></h2><p>这道题目的答题思路是使用栈进行数据存储和运算。读取到元素符号则将其原子量压入，读取到左括号直接压入，读取到数字则弹出栈顶元素，乘上数字后再压入，读取到右括号则弹出至左括号，将弹出的数据全部相加再压入，最后栈内剩下的唯一元素则是最终结果。<br>有的同学在一开始删除了所有的括号，可能是受到了破解虫洞那道题的影响。 <strong>这道题目的括号会对最终结果产生影响，所以不能删去括号！</strong>  </p><h4 id="正确答案-4"><a href="#正确答案-4" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">c = input() + <span class="string">'/'</span>                               <span class="comment"># 为了能够录入最后一个数，在末尾添加一个符号</span>s = Stack()                                     <span class="comment"># 实例化</span>temp = <span class="string">''</span>                                       <span class="comment"># 用于存放数字，因为不保证数都是一位，所以需要这个变量</span>Ar={<span class="string">'H'</span>:<span class="number">1.007</span>, <span class="string">'C'</span>:<span class="number">12.011</span>,                      <span class="comment"># 字典，存放原子量</span>    <span class="string">'N'</span>:<span class="number">14.007</span>, <span class="string">'O'</span>:<span class="number">15.999</span>}<span class="keyword">for</span> ch <span class="keyword">in</span> c:                                    <span class="comment"># 逐字符遍历</span>    <span class="keyword">if</span> <span class="keyword">not</span> ch.isdigit():                        <span class="comment"># 如果不是数字，这里也可以写 if ch.isdigit() == 0:</span>        <span class="keyword">if</span> temp != <span class="string">''</span>:                          <span class="comment"># temp非空说明需要将前一个原子的原子量乘以乘数</span>            m = s.pop()            s.push(int(temp) * m)            temp = <span class="string">''</span>                           <span class="comment"># 注意清空temp</span>    <span class="keyword">else</span>:                                       <span class="comment"># 如果是数字，则暂存进temp</span>        temp += ch        <span class="keyword">continue</span>                                <span class="comment"># 并且不用进行后续处理</span>    <span class="keyword">if</span> ch == <span class="string">'('</span>:                               <span class="comment"># 左括号直接压栈</span>        s.push(ch)        <span class="keyword">continue</span>                                <span class="comment"># 此处不写continue，后续使用elif也是可以的</span>    <span class="keyword">if</span> ch <span class="keyword">in</span> Ar.keys():                         <span class="comment"># 如果是元素符号</span>        s.push(Ar[ch])                          <span class="comment"># 则压入原子量</span>        <span class="keyword">continue</span>    <span class="keyword">if</span> ch == <span class="string">')'</span>:                               <span class="comment"># 如果是右括号</span>        sum_ = <span class="number">0</span>                                <span class="comment"># 循环变量赋初值</span>        <span class="keyword">while</span> s.peek() != <span class="string">'('</span>:                  <span class="comment"># 不断弹出直至遇到左括号</span>            sum_ += s.pop()                     <span class="comment"># 累加弹出的值</span>        s.pop()                                 <span class="comment"># 弹出左括号</span>        s.push(sum_)                            <span class="comment"># 压入总和</span>ans = <span class="number">0</span><span class="keyword">while</span> s.is_empty() == <span class="number">0</span>:                        <span class="comment"># 栈内剩余元素的和即为答案</span>    ans += s.pop()print(<span class="string">"%.2f"</span>%ans)</code></pre><h4 id="优化解法-3"><a href="#优化解法-3" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="python">c = <span class="string">'('</span> + input() + <span class="string">')'</span>    &lt;code block&gt;print(<span class="string">"%.2f"</span>%s.pop())<span class="comment"># 直接在最外侧加上括号，就可以直接在循环内加和，不需要最后单独加和</span></code></pre><pre><code class="python">Ar={<span class="string">'H'</span>:<span class="number">1007</span>, <span class="string">'C'</span>:<span class="number">12011</span>,     <span class="string">'N'</span>:<span class="number">14007</span>, <span class="string">'O'</span>:<span class="number">15999</span>}    &lt;code block&gt;print(<span class="string">"%.2f"</span>%(ans/<span class="number">1000</span>))<span class="comment"># 使用整型数运算避免精度问题。  </span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Experiment #04&lt;br&gt;北航致真书院19级大学计算机基础第四次上机实验实验总结&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2019CCBSummary#03</title>
    <link href="http://sutai.fun/2020/04/13/2019CCBSummary-03/"/>
    <id>http://sutai.fun/2020/04/13/2019CCBSummary-03/</id>
    <published>2020-04-12T18:44:18.000Z</published>
    <updated>2020-05-03T07:46:13.565Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Experiment #03<br>北航致真书院19级大学计算机基础第三次上机实验实验总结</p><a id="more"></a><h1 id="第三次实验问题汇总"><a href="#第三次实验问题汇总" class="headerlink" title="第三次实验问题汇总"></a>第三次实验问题汇总</h1><hr><h3 id="写在前面，并且希望大家认真地读一下"><a href="#写在前面，并且希望大家认真地读一下" class="headerlink" title="写在前面，并且希望大家认真地读一下"></a>写在前面，并且希望大家认真地读一下</h3><p>第二次上机实验，大家的答题情况不甚理想，基于这个情况，第三次上机实验的题目难度相比往届有所下降。但是这一次实验，大家的答题效果仍然不理想。群里面问问题的同学并不算多，而且有很多之前就讲过的问题。其实对于我而言，本次实验题目里出现的易错点多问我几次，我倒也是无所谓，可能同学们没有意识到自己的代码问题出在哪里，掉进了哪个坑，我作为助教还是很乐意去引导同学们走出坑的。但是对于一些应当在第一次实验或者第二次实验就掌握的知识点，我在被反复问到这些问题的时候，难免会觉得有些难受。所以为了提高大家的学习效率和独立解决问题的能力，我写了这段话，希望每位同学都能仔细地读一下这段话。<br>这学期到目前为止都是网上授课，可能对于其他科目而言是比较难受的，但是对于这门课程我认为更加便利。因为在老师讲课的过程中，同学们可以随时在本地进行测试，以便在课堂上掌握新知识。OJ系统上17级的部分题目大家都可以查看到，老师也督促过大家完成那些题目。大家要稍微多做一点题目，旨在熟悉Python的各种操作，包括基本语法，调试技巧等等。如果觉得OJ系统上的题目不够，可以在洛谷等网站上找题目。<br>接下来说的就是跟上机实验关系很紧密的事情。可能这学期没有助教手把手的指导实验，而是单纯在线针对代码进行答疑，所以有一些东西没有传达到。一下说的几点，我希望大家能够谨记于心。  </p><ul><li>虽然目前还没有涉及到较复杂的算法的题目，但是只要没有120%的把握能够十分顺利地写代码，<strong>请把草稿纸和笔放在面前。</strong> 在拿到题目的时候，用自己特有的方式在纸上记录下你的思路。比如需要什么变量，第一步怎么处理变量，怎么分支之类的；  </li><li><strong>仔细读题！</strong> 尤其是加粗的部分。命题人出题的初衷是为了锻炼大家的编程能力，而非特意给大家在题目描述挖坑，所以重要的部分都会<strong>加粗表示！</strong> 而且请读题的时候读完整。所谓读完整，是将题目描述，输入，输出，输入样例，输出样例，样例解释和Hint都仔细阅读。有时输入里面会有“保证输入数据只有数字和字母”的字样，这个的意思是命题人保证用于检测你的程序的数据在他所描述的范围内，大家在编程的时候就不需要考虑不在输入范围内的数据处理了。  </li><li><strong>要养成独立解决问题的能力。</strong> 助教们和老师反复说过一句话，考试的时候没有人答疑。而考试前面的这些上机实验，当然也有培养同学们独立解决问题能力的目的。代码WA了或者报错了之后第一个想到的不能是助教或者老师，也不能是别的同学，而应该是自己。当出现问题时，先检查有没有语法问题。请善用课件、实验指导和错题本，如果之前的知识点忘记了，请翻看之前的实验指导或者自己的实验报告。  </li><li><strong>要学会看程序的报错。</strong> Python在报错的时候，会显示好几行。前面的几行是告诉你问题大概出在哪里，这个是指<strong>编译器在编译到这里的时候发现了问题，而不一定是指问题出在这里，</strong> 所以你有时需要往前面看几行才能发现问题。再往下一行，会显示<code>xxx: xxxxxxxx.</code>之类的一句话。其中前面的是报错的类别，后面的是具体的错误。读懂报错不需要太强的英语能力，最多是几个单词不认识，请善用百度翻译。</li><li><strong>本地测试通过了不能说明代码没有问题！</strong> 本地测试通过了只能说明你的代码没有语法错误，请自行构造其他满足输入条件的数据进行测试。在构造条件时请多构造一些奇怪的数据，要抱着“怎么能让我的代码出错”的心态测试自己的程序。如果OJ上得了接近满分，则一般是特殊情况或者临界值没有考虑到，请加强对临界值或特殊情况的判断。  </li><li><strong><font color=#FF0000>WA=Wrong Answer, TLE=Time Limit Exceed, PE=Presentation Error.</font></strong> PE一般是空白符输出有问题，输出字母大小写有问题。TLE一般是时间复杂度过高或者出现死循环。有关时间复杂度的相关知识请参阅往期由 <strong><font color=0088BB>Marvolo大佬</font></strong> 编撰的《Python周报》。出现死循环则一般是由<code>while</code>循环引起的。如果在本地运行时发生死循环，请使用<kbd>Ctrl</kbd>+<kbd>C</kbd>强制终止程序。一般不会遇到其他OJ报错。如果遇到CE，检查自己提交的语言是否为Python3.  </li><li><strong>写代码要细心，注意检查语法问题。</strong> 很多人在编程的时候漏掉了函数和方法后的括号。<strong>函数和方法只有在加括号之后才表示调用，不加括号表示的是函数本身！</strong> 所以哪怕这个函数或方法不需要传参数，也请务必带上括号。<blockquote><p>举例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [bin, oct, hex]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line"><span class="meta">... </span>    print(i(<span class="number">16</span>))</span><br><span class="line">...</span><br><span class="line"><span class="number">0b10000</span></span><br><span class="line"><span class="number">0o20</span></span><br><span class="line"><span class="number">0x10</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">在定义`a`时，函数没有加括号，所以列表`a`里的元素是函数自身！这时循环变量`i`就是函数，所以可以通过`i(<span class="number">16</span>)`来实现`bin(<span class="number">16</span>), oct(<span class="number">16</span>), hex(<span class="number">16</span>)`的计算。  </span><br><span class="line">这就是`isalpha()`的括号丢掉就不能正常运行了的原因。  </span><br><span class="line">+ 如果实在是难以独立解决问题，请向他人求助。优先在小组群和答疑群求助。**求助时请将自己的代码截图发出，行标号截全，说清楚自己的代码目前是什么情况（有报错/无报错但输出不对/样例过了但是没有AC），前两种请把控制台相关输出截图，最后一种附上OJ反馈和得分。** 尽量使用截图功能，避免用手机拍摄屏幕！（Win10系统可以使用&lt;kbd&gt;Win&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;S&lt;/kbd&gt;快速打开自带截图软件，或者使用QQ自带的截图工具）  </span><br><span class="line">+ 最后，在获得别人的帮助之后， **请更新错题本。** 这样大家在遇到同样的问题时就可以通过错题本来解决自己的问题了。  </span><br><span class="line"></span><br><span class="line">时刻谨记，本门课程所教授的不仅仅是如何编写Python程序，更重要的是计算思维以及自我解决问题的能力。  </span><br><span class="line">我十分希望大家能够享受这门课程，我也会尽自己的能力帮助大家学好这门课程。  </span><br><span class="line"></span><br><span class="line">*斯太芬 写于 <span class="number">04</span>/<span class="number">04</span>/<span class="number">2020</span>*</span><br><span class="line">- - -</span><br><span class="line"><span class="comment">## &lt;font color=#0033FF&gt;A.利息计算&lt;/font&gt;</span></span><br><span class="line">需要注意题目并没有提到每期摊还的本金一定是整数，所以不要使用地板除。另外涉及到浮点数的判断时，受精度问题影响，不要直接使用`==`或者`!=`来判断，否则容易无法跳出循环。如果循环次数已知，则使用`<span class="keyword">for</span>...`循环完成；如必须使用`<span class="keyword">while</span>`，则使用诸如`<span class="keyword">while</span> abs(x-y)&lt;<span class="number">0.000001</span>:`或者`<span class="keyword">while</span> abs(x-y)&gt;<span class="number">0.000001</span>:`这样的形式。  </span><br><span class="line"><span class="comment">#### &lt;font color=#FF5E5E&gt;错误示范&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">while</span> N != <span class="number">0</span>:</span><br><span class="line"><span class="comment"># 在遇到某些数据，比如本金100分17期还的时候，N可能会十分接近但不等于0，从而无法跳出循环</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">#### &lt;font color=#5ECCFF&gt;正确答案&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line">N = int(input())</span><br><span class="line">t = int(input())</span><br><span class="line">i = float(input()) / <span class="number">100</span>                    <span class="comment"># 不要忘记输入的是百分数</span></span><br><span class="line">M = N</span><br><span class="line">n = N / t                                   <span class="comment"># N/t不一定是整数，不要使用地板除//</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(t):                          <span class="comment"># 循环次数已知时，尽量不要使用while</span></span><br><span class="line">   M += N * i</span><br><span class="line">   N -= n</span><br><span class="line">print(<span class="string">"%.2f"</span>%M)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"><span class="comment">## &lt;font color=#0033FF&gt;B.快速傅里叶变换&lt;/font&gt;</span></span><br><span class="line">考察使用列表处理数据的能力。  </span><br><span class="line">以下是常见问题：  </span><br><span class="line">+ 没有对访问越界的情况进行处理</span><br><span class="line">+ 使用`.join()`方法有误，没有传入正确的参数</span><br><span class="line"></span><br><span class="line"><span class="comment">#### &lt;font color=#FF5E5E&gt;错误示范&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line">m, n = map(int, input().split())</span><br><span class="line">lm = list(map(int, input().split()))</span><br><span class="line">ln = list(map(int, input().split()))</span><br><span class="line">lans = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m + n - <span class="number">1</span>):</span><br><span class="line">   s = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>):</span><br><span class="line">       s += lm[j] * ln[i - j]</span><br><span class="line">   lans.append(s)</span><br><span class="line">print(<span class="string">' '</span>.join(lans))</span><br><span class="line"><span class="comment"># 访问列表的时候显然会越界</span></span><br><span class="line"><span class="comment"># 最后一行.join()方法传参有误</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">使用`.join()`方法时要注意其参数是一个 **仅包含字符串的列表** ，而本题中我们最终得到的列表元素均是整型数，所以不能直接使用`.join()`，使用`<span class="keyword">for</span>...`语句循环输出反而更容易理解一些。  </span><br><span class="line"><span class="comment">#### &lt;font color=#5ECCFF&gt;正确答案&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line">m, n = map(int, input().split())</span><br><span class="line">lm = list(map(int, input().split()))</span><br><span class="line">ln = list(map(int, input().split()))</span><br><span class="line">lans = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m + n - <span class="number">1</span>):</span><br><span class="line">   s = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>):</span><br><span class="line">       <span class="keyword">if</span> j &gt;= m:                          <span class="comment"># 如果有一项超出原列表范围</span></span><br><span class="line">           <span class="keyword">continue</span>                        <span class="comment"># 那么这一项乘积必定是0</span></span><br><span class="line">       <span class="keyword">if</span> i-j &gt;= n:                        <span class="comment"># 所以使用continue跳过这次循环即可</span></span><br><span class="line">           <span class="keyword">continue</span>                        <span class="comment"># 注意这个continue只对最近一层循环奏效</span></span><br><span class="line">       s += lm[j] * ln[i - j]</span><br><span class="line">   lans.append(s)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> lans:                              <span class="comment"># for语句看着很清楚</span></span><br><span class="line">   print(k, end=<span class="string">' '</span>)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">#### &lt;font color=#33EEBB&gt;优化解法&lt;/font&gt;</span></span><br><span class="line">如果真的想使用`.join()`方法，看这个解法的最后一行。尝试理解这套操作。  </span><br><span class="line">```python</span><br><span class="line">m, n = map(int, input().split())</span><br><span class="line">lm = list(map(int, input().split())) + [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>)]</span><br><span class="line">ln = list(map(int, input().split())) + [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>)]</span><br><span class="line">lans = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m + n - <span class="number">1</span>):</span><br><span class="line">   s = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>):</span><br><span class="line">       s += lm[j] * ln[i - j]</span><br><span class="line">   lans.append(s)</span><br><span class="line">print(<span class="string">' '</span>.join(list(map(str, lans))))       <span class="comment"># 使用了字符串的.join()方法</span></span><br><span class="line"><span class="comment"># 提前在末尾添上0即可</span></span><br><span class="line"><span class="comment"># 这种写法是保证0正好够用，当然直接添上足够满足测试数据的个数也是可以的</span></span><br><span class="line"><span class="comment"># 比如lm += [0] * 100</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">如果难以理解最后一行，不妨想想一行输入多个数据如何接收。  </span><br><span class="line">这个解法使用了列表生成式。稍微解释一下列表生成式：  </span><br><span class="line">```python</span><br><span class="line">a = [f(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">上面这个赋值语句相当于：</span><br><span class="line">```python</span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">   a.append(f(i))</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">其中`f(i)`是一个关于`i`的（数学层面上的）函数，可以是确切的表达式，也可以包含函数。  </span><br><span class="line">- - -</span><br><span class="line"><span class="comment">## &lt;font color=#0033FF&gt;C.变量命名&lt;/font&gt;</span></span><br><span class="line">这道题目是一道很典型的字符串处理题目，考察大家对于字符串处理的知识点的掌握。需要注意的是题目中有一句话“每一个单词的第一个字母为大写，其他字母为小写”，提到了其他字母为小写，就一定要在自己的程序里将其他字符转换为小写。  </span><br><span class="line">顺带提一下，为了增强代码可读性，这道题目所提到的“驼峰命名法”和我个人常用的“下划线命名法”都是很好的给变量命名的方法。具体就是先用几个英文单词描述这个变量所代表的含义，比如使用“Principal per year”来表示A题中的每年应摊本金，然后将变量命名为`PrincipalPerYear`，`principalPerYear`（这两者都是驼峰命名法，区别是第一个单词的首字母是否大写）或`principal_per_year`（下划线命名法）。这样一来，每个变量表示什么就一清二楚，在变量很多的时候也不会觉得杂乱，不会有“n是什么意思，x是什么变量，a又是什么”这样的混乱。  </span><br><span class="line">以下是常见错误：  </span><br><span class="line">+ 没有读清题目要求，未将每个单词除第一个字母外的其他字母变为小写。</span><br><span class="line">+ 使用索引判断是否为新单词的时候忽略了第一个字符的特殊处理，并且因为Python的索引特性导致了奇怪错误的发生。  </span><br><span class="line"></span><br><span class="line"><span class="comment">#### &lt;font color=#FF5E5E&gt;错误示范&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">   <span class="keyword">if</span> s[i].isalpha():</span><br><span class="line">       <span class="keyword">if</span> s[i<span class="number">-1</span>].isalpha():</span><br><span class="line">           ans += s[i]</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           ans += s[i].upper()</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这一个示范有两处错误。第一是忘记了将非单词首字母转化为小写，第二就是索引问题。当`i=<span class="number">0</span>`也就是第一次进入循环的时候，这时`s[i<span class="number">-1</span>]`代表的是`s[<span class="number">-1</span>]`，也就是最后一个字符。如果最后一个字符也是字母的话，那么第一个字符就没有转化为大写，自然就会PE。</span><br><span class="line"><span class="comment">#### &lt;font color=#5ECCFF&gt;正确答案&lt;/font&gt;</span></span><br><span class="line">要注意的是`.upper()`和`.lower()`方法不会对非字母字符做任何处理，要善用这一特性。  </span><br><span class="line">```python</span><br><span class="line">s = input()</span><br><span class="line">con = <span class="literal">True</span>                                  <span class="comment"># 用于控制程序在判断有无字母后是否需要继续</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:                                 <span class="comment"># 这里使用for...else...语句来判断是否全为特殊符号</span></span><br><span class="line">   <span class="keyword">if</span> i.isalpha():                         <span class="comment"># 只要有一个字母，便无需再判断</span></span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:                                       <span class="comment"># 如果全为特殊符号，则输出并且不继续程序</span></span><br><span class="line">   print(<span class="string">"WaiBiBaBo"</span>)</span><br><span class="line">   con = <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> con:                                     <span class="comment"># con为True则说明需要继续</span></span><br><span class="line">   flag = <span class="literal">True</span>                             <span class="comment"># 使用flag变量来判断是否为词首，初始值为True</span></span><br><span class="line">   ans = <span class="string">''</span>                                <span class="comment"># ans是answer的简写，一般用于存储最终结果，也可以使用res（result）</span></span><br><span class="line">   <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">       <span class="keyword">if</span> c.isalpha():</span><br><span class="line">           <span class="keyword">if</span> flag:                        <span class="comment"># flag为True表示当前位置是词首，应该大写</span></span><br><span class="line">               ans += c.upper()</span><br><span class="line">           <span class="keyword">else</span>:                           <span class="comment"># 否则不是词首，应该小写</span></span><br><span class="line">               ans += c.lower()            <span class="comment"># 此处一定注意要转化为小写</span></span><br><span class="line">           flag = <span class="literal">False</span>                    <span class="comment"># 记得更新flag</span></span><br><span class="line">       <span class="keyword">elif</span> c.isdigit():</span><br><span class="line">           ans += c                        <span class="comment"># 数字要记入，然后更新flag</span></span><br><span class="line">           flag = <span class="literal">True</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           flag = <span class="literal">True</span></span><br><span class="line">   print(ans)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">如果想要使用索引进行处理，那么可以采取以下措施。因为不知道第一个字符是不是字母，所以直接将第一个字符转化为大写存储起来并不保险，需要使用一点小技巧，放到优化解法里了。  </span><br><span class="line"><span class="comment">#### &lt;font color=#33EEBB&gt;优化解法&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">if</span> s.upper() == s.lower():</span><br><span class="line">   print(<span class="string">"WaiBiBaBo"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 判断是否全为特殊符号，只需要一点小技巧。这样可以省下不少代码。</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">if</span> ans == <span class="string">''</span>:</span><br><span class="line">   print(<span class="string">"WaiBiBaBo"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   print(ans)</span><br><span class="line"><span class="comment"># 也可以前面不做处理，最后判断。</span></span><br><span class="line"><span class="comment"># 因为题目保证了有数字必有字母，所以这样很安心。</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># 前面提到的使用索引处理字符的方法</span></span><br><span class="line">s = s + <span class="string">'/'</span>                                 <span class="comment"># 此处添加任意不是数字或字母符号均可</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">   <span class="keyword">if</span> s[i].isalpha():</span><br><span class="line">       <span class="keyword">if</span> s[i<span class="number">-1</span>].isalpha():</span><br><span class="line">           ans += s[i].lower()</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           ans += s[i].upper()</span><br><span class="line"><span class="comment"># 因为在最后添了一个特殊符号，所以第一个字符一定会被认为是词首。而且特殊符号会在这样的处理中被删除掉，所以不用添加额外处理。</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"><span class="comment">## &lt;font color=#0033FF&gt;D.仿二进制数密文系统&lt;/font&gt;</span></span><br><span class="line">考察字典的运用，当然不使用字典也可以完成。  </span><br><span class="line">以下是常见问题：  </span><br><span class="line">+ 将一个字符串分为n个一组的操作不熟练  </span><br><span class="line">+ 转换二进制和添<span class="number">0</span>的操作不熟练，`bin()`函数添加的`<span class="string">'0b'</span>`没有处理</span><br><span class="line">+ 有好多同学把<span class="number">3</span>写进了代码！题目并没有说一定是<span class="number">3</span>个一组</span><br><span class="line">+ 在判断密文是否合法时出现了各种问题  </span><br><span class="line"></span><br><span class="line"><span class="comment">#### &lt;font color=#FF5E5E&gt;错误示范&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">if</span> set(w) != &#123;<span class="string">'0'</span>,<span class="string">'1'</span>&#125;:</span><br><span class="line">   print(<span class="string">'Type Error,Please Check!'</span>)</span><br><span class="line"><span class="comment"># 密文只有0或只有1也是合法的哦，这样会排除掉正确的密文</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">m = len(w) // n</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">   w[i:i+n]</span><br><span class="line"><span class="comment"># 想到了要n个一组，但是这样并没有完成n个一组的操作</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">对于上面这个代码，比如说有一个序列`[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]`</span><br><span class="line">需要三个一组分组，然后此时`L`为<span class="number">3</span>，再执行`<span class="keyword">for</span> i <span class="keyword">in</span> range(L):`</span><br><span class="line">本来想得到的是`[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]`，`[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]`，`[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]`，</span><br><span class="line">却得到了`[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]`，`[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]`，`[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]`，</span><br><span class="line">思考一下为什么。</span><br><span class="line"><span class="comment">#### &lt;font color=#5ECCFF&gt;正确答案&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line">n = int(input())</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span> ** n):</span><br><span class="line">   k = bin(i)[<span class="number">2</span>:]                          <span class="comment"># 切片操作删除'0b'</span></span><br><span class="line">   d[<span class="string">'0'</span>*(n-len(k)) + k] = input()         <span class="comment"># 补0，输入数据</span></span><br><span class="line">w = input()</span><br><span class="line">L = len(w)</span><br><span class="line"><span class="keyword">if</span> L % n:</span><br><span class="line">   print(<span class="string">"Type Error,Please Check!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> w:</span><br><span class="line">       <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'0'</span>, <span class="string">'1'</span>):             <span class="comment"># 这里是逐一判断，下面的解法是统一判断</span></span><br><span class="line">           print(<span class="string">"Type Error,Please Check!"</span>)</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">   <span class="keyword">else</span>:                                   <span class="comment"># for...else...语句，希望大家都能掌握这个用法</span></span><br><span class="line">       p = []</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, L, n):            <span class="comment"># 带有三个参数的range()函数，第三个参数是步长</span></span><br><span class="line">           p.append(d[w[i:i+n]])</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">           print(i, end=<span class="string">' '</span>)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">#### &lt;font color=#33EEBB&gt;优化解法&lt;/font&gt;</span></span><br><span class="line">首先来看一个十分熟悉的函数`int()`，实际上这个函数可以传两个参数。`int(x, n)`的返回值是将`x`当做n进制的数，然后转化为十进制整型返回，其中`x`应传如字符串。  </span><br><span class="line">举几个例子：  </span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'100'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'0b100'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'100'</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">在了解到这个用法之后，这道题目的某些复杂的数据处理就可以省掉了</span><br><span class="line">```python</span><br><span class="line">n = int(input())</span><br><span class="line">k = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span> ** n)]              <span class="comment"># 列表生成式，生成了从0到2**n-1的整数序列</span></span><br><span class="line">v = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span> ** n):</span><br><span class="line">   v.append(input())</span><br><span class="line">d = dict(zip(k, v))                         <span class="comment"># 其实不用zip()函数更简单一些，参考正确答案的做法</span></span><br><span class="line">w = input()</span><br><span class="line"><span class="keyword">if</span> len(w) % n:</span><br><span class="line">   print(<span class="string">"Type Error,Please Check!"</span>)</span><br><span class="line"><span class="keyword">elif</span> w.replace(<span class="string">'0'</span>, <span class="string">''</span>).replace(<span class="string">'1'</span>, <span class="string">''</span>):   <span class="comment"># 判断是否全为01，如果不是，则在替换后字符串非空</span></span><br><span class="line"><span class="comment"># elif not (set(w) &lt;= &#123;'0', '1'&#125;):          # 判断不是真子集也可</span></span><br><span class="line">   print(<span class="string">"Type Error,Please Check!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   w += <span class="string">'/'</span>                                <span class="comment"># 消除伏笔</span></span><br><span class="line">   p = <span class="string">''</span></span><br><span class="line">   <span class="keyword">while</span> w != <span class="string">'/'</span>:                         <span class="comment"># 读完所有密文后w将剩下一个'/'</span></span><br><span class="line">       c = w[:n]                           <span class="comment"># 将前n个字符切片</span></span><br><span class="line">       w = w[n:]                           <span class="comment"># 删去前n个字符</span></span><br><span class="line">       p += d[int(c, <span class="number">2</span>)] + <span class="string">' '</span></span><br><span class="line">   print(p)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">注意到这个解法与上一个解法的最大的区别，在于所建立的字典不一样。上一种解法的字典的键是`<span class="string">'0000'</span>,<span class="string">'0001'</span>,<span class="string">'0010'</span>,...`这样形如二进制数的字符串，而这种解法的字典的键则是`<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,...`这样的十进制整型。通过`int(c,<span class="number">2</span>)`这样的操作可以简单地将二进制化为十进制并且不用考虑前缀或者位数这样的限制。  </span><br><span class="line">注释里有一句“消除伏笔”，这个伏笔来源于后面`w=w[n:]`的操作。因为最后一次切片时，字符串`w`只剩下了n个字符，则`w[n:]`这样会访问越界，所以在其最后任意添加一个字符防止越界，并且`<span class="keyword">while</span>`循环的判断条件也随之变化。  </span><br><span class="line">- - -</span><br><span class="line"><span class="comment">## &lt;font color=#0033FF&gt;E.构造（选做）&lt;/font&gt;</span></span><br><span class="line">本题的题目叫做构造，旨在锻炼大家的构造能力。一般像这种存在多个解，要求输出任一解的，先要考虑能否构造出通解。  </span><br><span class="line">常见问题就是没有理解题目的意图，尝试使用遍历求解。在$<span class="number">10</span>^&#123;<span class="number">100000</span>&#125;$这样大的运算量下必定会TLE。  </span><br><span class="line"><span class="comment">#### &lt;font color=#5ECCFF&gt;正确答案&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line">print(<span class="string">'2'</span>+<span class="string">'3'</span>*(int(input())<span class="number">-1</span>))</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这里给出的是一行解，如果拆成更便于理解的形式，将会是下面这样：  </span><br><span class="line">```python</span><br><span class="line">n = int(input())</span><br><span class="line">s = <span class="string">'2'</span> + <span class="string">'3'</span> * (n<span class="number">-1</span>)</span><br><span class="line">print(s)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这道题目通解有很多，比如</span><br><span class="line"><span class="number">233333333333333</span></span><br><span class="line"><span class="number">299999999999999</span></span><br><span class="line"><span class="number">533333333333333</span></span><br><span class="line"><span class="number">599999999999999</span></span><br><span class="line"><span class="number">833333333333333</span></span><br><span class="line"><span class="number">899999999999999</span></span><br><span class="line"><span class="number">263939639633939</span>（开头是<span class="number">258</span>，中间是<span class="number">369</span>随意，末尾是<span class="number">3</span>或者<span class="number">9</span>）</span><br><span class="line"><span class="number">555555555555558</span></span><br><span class="line"><span class="number">333333333333334</span></span><br><span class="line"><span class="number">566666666666666</span></span><br><span class="line"><span class="number">777777777777778</span></span><br><span class="line">等等等等，感兴趣的可以再研究研究</span><br><span class="line">- - -</span><br><span class="line"><span class="comment">## &lt;font color=#0033FF&gt;F.技能加点（选做）&lt;/font&gt;</span></span><br><span class="line">这道题做的人实在是太少了（悲），直接给出我的AC代码了。  </span><br><span class="line">这道题的思路在于将每一个技能的最优点数化为k进制数，然后如果每一个数都只含有<span class="number">0</span>或<span class="number">1</span>，且不存在两个数的同一位都是<span class="number">1</span>，那么就可以满足条件。  </span><br><span class="line">这道题有两个临界值（一般也叫“坑”），一个是所有技能的最优点数全为<span class="number">0</span>， ~~可惜样例给出了，坑不到了，~~ 另一个则是k=<span class="number">1</span>的情况。想想“一进制”有没有实际意义。  </span><br><span class="line"><span class="comment">#### &lt;font color=#5ECCFF&gt;正确答案&lt;/font&gt;</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> m</span><br><span class="line"></span><br><span class="line">T = int(input())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(T):</span><br><span class="line">   n, k = map(int, input().split())</span><br><span class="line">   req = list(map(int, input().split()))</span><br><span class="line">   top = max(req)                          <span class="comment"># top是最大的最优点数</span></span><br><span class="line">   <span class="keyword">if</span> top == <span class="number">0</span> <span class="keyword">or</span> k == <span class="number">1</span>:                  <span class="comment"># 对两个坑的特判</span></span><br><span class="line">       print(<span class="string">"YES"</span>)</span><br><span class="line">       <span class="keyword">continue</span></span><br><span class="line">   ds = m.ceil(m.log(top, k))              <span class="comment"># 这里是计算k进制的最大位数，直接给一个足够大的数也可以</span></span><br><span class="line">   dis = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(ds+<span class="number">1</span>)]          <span class="comment"># 创建0列表用于存放总和每个位数的值</span></span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> req:</span><br><span class="line">       tdis = []                           <span class="comment"># 对于每一个最优点数创建列表</span></span><br><span class="line">       <span class="keyword">while</span> j != <span class="number">0</span>:                       <span class="comment"># 熟悉的进制转换</span></span><br><span class="line">           tdis.append(j % k)</span><br><span class="line">           j = j // k</span><br><span class="line">       <span class="keyword">for</span> l <span class="keyword">in</span> range(len(tdis)):          <span class="comment"># 将当前数加到总和上</span></span><br><span class="line">           dis[l] += tdis[l]</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> dis:</span><br><span class="line">       <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>]:                 <span class="comment"># 只要有一个不是0或1就说明某一秒需要多次加点才可以满足要求</span></span><br><span class="line">           print(<span class="string">'NO'</span>)</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       print(<span class="string">"YES"</span>)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">~~给出的`n`其实没有用到~~</span><br><span class="line">关于上面代码的`dis`和`tdis`，`dis`存储的是总值，`tdis`存储的是每一个最优点数的值，第<span class="number">0</span>个元素存放个位，第<span class="number">1</span>个元素存放<span class="number">1</span>次位，以此类推。  </span><br><span class="line">举例：输入</span><br></pre></td></tr></table></figure><p>3 4<br>1 4 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对于三个最优点数，转化为四进制，分别存放，然后加和到&#96;dis&#96;上</span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">1 : [1]</span><br><span class="line">4 : [0, 1]</span><br><span class="line">1 : [1]</span><br><span class="line">dis:[2, 1, 0]</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">&#96;dis&#96;存在非01的数，输出&#96;&#39;NO&#39;&#96;</span><br><span class="line">再比如输入</span><br></pre></td></tr></table></figure><p>3 9<br>0 59049 810</p><pre><code>```python0     : []59049 : [0, 0, 0, 0, 0, 1]810   : [0, 0, 1, 1]dis   : [0, 0, 1, 1, 0, 1, 0]</code></pre><p><code>dis</code>只有01，满足要求，输出<code>&#39;YES&#39;</code></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Experiment #03&lt;br&gt;北航致真书院19级大学计算机基础第三次上机实验实验总结&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2019CCBSummary#02</title>
    <link href="http://sutai.fun/2020/04/13/2019CCBSummary-02/"/>
    <id>http://sutai.fun/2020/04/13/2019CCBSummary-02/</id>
    <published>2020-04-12T18:43:21.000Z</published>
    <updated>2020-05-03T07:51:27.576Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Experiment #02<br>北航致真书院19级大学计算机基础第二次上机实验实验总结</p><a id="more"></a><h1 id="第二次实验问题汇总"><a href="#第二次实验问题汇总" class="headerlink" title="第二次实验问题汇总"></a>第二次实验问题汇总</h1><hr><h2 id="A-FizzBuzz"><a href="#A-FizzBuzz" class="headerlink" title="A.FizzBuzz"></a><font color=0033FF>A.FizzBuzz</font></h2><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>分支条件不充分（这个是假想问题。本地可以排除，所以OJ上不会体现）  </li></ul><h4 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="python">n = int(input())data = []<span class="keyword">for</span> i <span class="keyword">in</span> range(n):    x = int(input())    data.append(x)<span class="keyword">for</span> a <span class="keyword">in</span> data:    <span class="keyword">if</span> a%<span class="number">3</span> == <span class="number">0</span>:        print(<span class="string">'fizz'</span>)    <span class="keyword">elif</span> a%<span class="number">5</span> == <span class="number">0</span>:        print(<span class="string">'buzz'</span>)    <span class="keyword">elif</span> a%<span class="number">15</span> == <span class="number">0</span>:        print(<span class="string">'fizzbuzz'</span>)    <span class="keyword">else</span>:        print(a)<span class="comment">#这样的话可以被15整除的都会输出fizz而不是fizzbuzz</span></code></pre><h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">n = int(input())data = []<span class="keyword">for</span> i <span class="keyword">in</span> range(n):    x = int(input())    data.append(x)<span class="keyword">for</span> a <span class="keyword">in</span> data:    <span class="keyword">if</span> a%<span class="number">3</span> == <span class="number">0</span> <span class="keyword">and</span> a%<span class="number">5</span> != <span class="number">0</span>:        print(<span class="string">'fizz'</span>)    <span class="keyword">elif</span> a%<span class="number">5</span> == <span class="number">0</span> <span class="keyword">and</span> a%<span class="number">3</span> != <span class="number">0</span>:        print(<span class="string">'buzz'</span>)    <span class="keyword">elif</span> a%<span class="number">15</span> == <span class="number">0</span>:        print(<span class="string">'fizzbuzz'</span>)    <span class="keyword">else</span>:        print(a)<span class="comment">#判断条件要更充分</span></code></pre><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="python">n = int(input())data = []<span class="keyword">for</span> i <span class="keyword">in</span> range(n):    x = int(input())    data.append(x)<span class="keyword">for</span> a <span class="keyword">in</span> data:    <span class="keyword">if</span> a%<span class="number">15</span> == <span class="number">0</span>:        print(<span class="string">'fizzbuzz'</span>)    <span class="keyword">elif</span> a%<span class="number">5</span> == <span class="number">0</span>:        print(<span class="string">'buzz'</span>)    <span class="keyword">elif</span> a%<span class="number">3</span> == <span class="number">0</span>:        print(<span class="string">'fizz'</span>)    <span class="keyword">else</span>:        print(a)<span class="comment">#先判断15就没有任何问题啦！不妨想想为什么</span></code></pre><h4 id="奇怪的解法"><a href="#奇怪的解法" class="headerlink" title="奇怪的解法"></a><font color=#9966FF>奇怪的解法</font></h4><pre><code class="python">n = int(input())<span class="keyword">for</span> i <span class="keyword">in</span> range(n):    x = int(input())    flag = <span class="literal">True</span>    <span class="keyword">if</span> x%<span class="number">3</span> == <span class="number">0</span>:        print(<span class="string">'fizz'</span>, end=<span class="string">''</span>)        flag = <span class="literal">False</span>    <span class="keyword">if</span> x%<span class="number">5</span> == <span class="number">0</span>:        print(<span class="string">'buzz'</span>, end=<span class="string">''</span>)        flag = <span class="literal">False</span>    <span class="keyword">if</span> flag:        print(x, end=<span class="string">''</span>)    print()<span class="comment">#这个是我写的解法啦，有点小奇妙但是并没有简化多少，所以专门开了一栏</span><span class="comment">#顺带提一下，OJ系统上检测输出数据的时候是不受输入数据影响的</span><span class="comment">#所以输出输入穿插进行是可以的</span></code></pre><hr><h2 id="B-对话过滤"><a href="#B-对话过滤" class="headerlink" title="B.对话过滤"></a><font color=0033FF>B.对话过滤</font></h2><h3 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>使用ASCII码完成大小写字母匹配，但忽略了其他符号的影响</li><li>对字母和符号一视同仁，顺便删去了重复的符号</li><li>对字符串通过下标访问时访问越界  </li></ul><h4 id="错误示范-1"><a href="#错误示范-1" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="python">s=str(input())ns=<span class="string">''</span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(s)):        <span class="keyword">if</span> s[i].isalpha()==<span class="literal">True</span>:        <span class="keyword">if</span> ord(s[i])==ord(s[i<span class="number">-1</span>]) <span class="keyword">or</span> ord(s[i])==ord(s[i<span class="number">-1</span>])+<span class="number">32</span> <span class="keyword">or</span> ord(s[i])==ord(s[i<span class="number">-1</span>])<span class="number">-32</span>:            <span class="keyword">pass</span>        <span class="keyword">else</span>:            ns+=s[i]    <span class="keyword">else</span>:        ns+=s[i]print(ns)<span class="comment">#注意到最长的一行使用了ASCII码来判断字母是否重复</span><span class="comment">#并且使用+-32的方式将大小写字母全部考虑到了</span><span class="comment">#但是需要注意的是'!'和'A','#'和'C'等字符也是ASCII码相差32的</span><span class="comment">#因此会删除一些跟在某一些特定符号后的特定字母</span></code></pre><pre><code class="python">s=input()ns=s[<span class="number">0</span>]<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):    <span class="keyword">if</span> str.upper(s[i])!=str.upper(s[i<span class="number">-1</span>]):        ns=ns+s[i]print(ns)<span class="comment">#思路很好，但是这样不仅删去了重复的字母，还删去了重复的非字母字符</span></code></pre><h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">s=input()ns=s[<span class="number">0</span>]<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):    <span class="keyword">if</span> (<span class="keyword">not</span> str.isalpha(s[i])) <span class="keyword">or</span> (str.upper(s[i])!=str.upper(s[i<span class="number">-1</span>])):        ns=ns+s[i]print(ns)</code></pre><h4 id="优化解法-1"><a href="#优化解法-1" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="python"><span class="comment">#按理说也不算优化解法，只是提供另一个思路</span><span class="comment">#同学们基本上都是通过下标将一个字符与上一个字符比较</span><span class="comment">#其实也可以创建一个变量用于存储上一个字符</span>s = input()ans = <span class="string">''</span>pre = <span class="string">''</span><span class="keyword">for</span> i <span class="keyword">in</span> s:    <span class="keyword">if</span> i.isalpha():        <span class="keyword">if</span> i.lower() == pre.lower():            <span class="keyword">continue</span>    pre = i    ans = ans + iprint(ans)<span class="comment">#注意这里pre就是用来存储上一字符的变量</span><span class="comment">#注意这里continue的用法</span></code></pre><hr><h2 id="C-Cantor表"><a href="#C-Cantor表" class="headerlink" title="C.Cantor表"></a><font color=0033FF>C.Cantor表</font></h2><h3 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>题目要求适用空格，却使用了制表符<code>\t</code>隔开</li><li>换行的时候使用了<code>print(&#39;\n&#39;)</code>  </li></ul><h4 id="错误示范-2"><a href="#错误示范-2" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="python">n=int(input())<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">2</span>-i):         print(<span class="string">'%d/%d'</span>%(i,j),end=<span class="string">'\t'</span>)     print()<span class="comment">#题目要求空格但是使用了制表符'\t'</span></code></pre><pre><code class="python">n=int(input())<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">2</span>-i):         print(<span class="string">'%d/%d'</span>%(i,j),end=<span class="string">' '</span>)     print(<span class="string">'\n'</span>)<span class="comment">#要注意print()函数自带一个end='\n'，需要仅换行的时候使用不带参数的print()即可</span></code></pre><h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">n=int(input())<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">2</span>-i):         print(<span class="string">'%d/%d'</span>%(i,j),end=<span class="string">' '</span>)     print()<span class="comment">#OJ在检验输出结果的时候一般情况下会自动忽略掉行末的空格和段落末尾的换行符</span><span class="comment">#我给命题组提意见要求删掉行尾没有多余空格那句话但是最后没改</span></code></pre><hr><h2 id="D-新数根的计算"><a href="#D-新数根的计算" class="headerlink" title="D.新数根的计算"></a><font color=0033FF>D.新数根的计算</font></h2><h3 id="常见问题-3"><a href="#常见问题-3" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>边界条件设置有问题，会输出10</li><li>循环变量的赋值时机（包括赋初始值和循环过程中赋值）把握不清楚</li><li>在比较的时候没有把握好变量类型  </li></ul><h4 id="错误示范-3"><a href="#错误示范-3" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="python">n = str(input())<span class="keyword">while</span> int(n) &gt; <span class="number">10</span>:    b = <span class="number">1</span>    <span class="keyword">for</span> i <span class="keyword">in</span> n :        <span class="keyword">if</span> i != <span class="string">'0'</span>:            b = b * int(i)        <span class="keyword">else</span>:            <span class="keyword">continue</span>    n = str(b)print(n)<span class="comment">#如果中间计算出了10这个数字，会直接跳出循环，导致结果出错</span></code></pre><pre><code class="python">n = str(input())<span class="keyword">while</span> int(n) &gt;= <span class="number">10</span>:    b = <span class="number">1</span>    <span class="keyword">for</span> i <span class="keyword">in</span> n :        <span class="keyword">if</span> i != <span class="number">0</span>:            b = b * int(i)        <span class="keyword">else</span>:            <span class="keyword">continue</span>    n = str(b)print(n)<span class="comment">#if判断的时候，i是一个字符串，所以一定不会和0相等</span></code></pre><pre><code class="python">a=input()m=<span class="number">1</span><span class="keyword">while</span> len(a)&gt;<span class="number">1</span>:    <span class="keyword">for</span> i <span class="keyword">in</span> a:        <span class="keyword">if</span> i == <span class="string">'0'</span>:            <span class="keyword">continue</span>        m=m*int(i)    a=str(m)print(a)<span class="comment">#m作为for循环的循环变量，应在for前初始化</span><span class="comment">#所以应该写在while里</span></code></pre><h4 id="正确答案-3"><a href="#正确答案-3" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">num = input()<span class="keyword">while</span> int(num) &gt;= <span class="number">10</span>:<span class="comment">#while len(num) &gt; 1:</span>    product = <span class="number">1</span>    <span class="keyword">for</span> i <span class="keyword">in</span> num:        <span class="keyword">if</span> i != <span class="string">'0'</span>:            product *= int(i)    num = str(product)print(num)<span class="comment">#通过数值大小或者字符串长度判断是否跳出循环都是正确思路</span></code></pre><hr><h2 id="E-第k对角线（选做）"><a href="#E-第k对角线（选做）" class="headerlink" title="E.第k对角线（选做）"></a><font color=0033FF>E.第k对角线（选做）</font></h2><ul><li>做的人实在太少了</li><li>一个比较常见的问题是题意理解不清</li><li>所以直接给AC代码了  </li></ul><h4 id="正确答案-4"><a href="#正确答案-4" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">n = int(input())k = int(input())vice = int(input())<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):        <span class="keyword">if</span> vice:                    <span class="comment">#如果要画副对角线</span>            <span class="keyword">if</span> k==abs(j+i-n<span class="number">-1</span>):     <span class="comment">#这里是判断(i,j)在不在n阶方阵的第k副对角线上</span>                print(<span class="string">'x'</span>, end=<span class="string">''</span>)            <span class="keyword">else</span>:                print(<span class="string">'*'</span>, end=<span class="string">''</span>)        <span class="keyword">else</span>:                       <span class="comment">#如果要画主对角线</span>            <span class="keyword">if</span> k==abs(i-j):         <span class="comment">#这里是判断(i,j)在不在n阶方阵的第k主对角线上</span>                print(<span class="string">'x'</span>, end=<span class="string">''</span>)            <span class="keyword">else</span>:                print(<span class="string">'*'</span>, end=<span class="string">''</span>)    print()                         <span class="comment">#使用print()换行</span></code></pre><hr><h2 id="F-中国剩余定理（选做）"><a href="#F-中国剩余定理（选做）" class="headerlink" title="F.中国剩余定理（选做）"></a><font color=0033FF>F.中国剩余定理（选做）</font></h2><h3 id="常见问题-4"><a href="#常见问题-4" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>忽略了输出正整数的条件</li><li>没有注意到除法会将数据转换为浮点数，而浮点数精度可能出现问题  </li></ul><h4 id="正确答案-5"><a href="#正确答案-5" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">n = int(input())con = []prod = <span class="number">1</span>                                <span class="comment">#记录所有除数的乘积</span><span class="keyword">for</span> i <span class="keyword">in</span> range(n):    x, y = map(int, input().split())    prod *= x    con.append((x, y))                  <span class="comment">#每一个元素是一个元组，第一项是除数，第二项是余数</span>rev = []                                <span class="comment">#存储每个除数的“逆”</span><span class="keyword">for</span> item <span class="keyword">in</span> con:    i = <span class="number">1</span>                               <span class="comment">#while循环变量赋初值</span>    att = prod // item[<span class="number">0</span>]               <span class="comment">#注意此处使用地板除来消除python浮点数运算精度不高的问题</span>    <span class="keyword">while</span> att * i % item[<span class="number">0</span>] != <span class="number">1</span>:        i += <span class="number">1</span>                          <span class="comment">#逐一寻找“逆”</span>    rev.append(att * i)                 <span class="comment">#将“逆”存起来</span>ans = <span class="number">0</span>                                 <span class="comment">#下面求和用的for循环变量赋初值</span><span class="keyword">for</span> i <span class="keyword">in</span> range(n):    ans += con[i][<span class="number">1</span>] * rev[i]           <span class="comment">#根据公式把ak+b形式算出来</span>ans = ans % prod                        <span class="comment">#取最小的可能值</span><span class="keyword">if</span> ans == <span class="number">0</span>:                            <span class="comment">#确保输出正整数</span>    ans = prodprint(ans)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Experiment #02&lt;br&gt;北航致真书院19级大学计算机基础第二次上机实验实验总结&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2019CCBSummary#01</title>
    <link href="http://sutai.fun/2020/04/11/2019CCBSummary-01/"/>
    <id>http://sutai.fun/2020/04/11/2019CCBSummary-01/</id>
    <published>2020-04-10T17:15:09.000Z</published>
    <updated>2020-05-03T07:50:54.049Z</updated>
    
    <content type="html"><![CDATA[<p>Summary of BUAA 1977 College Computer Basic Experiment #01<br>北航致真书院19级大学计算机基础第一次上机实验实验总结</p><a id="more"></a><h1 id="第一次实验问题汇总"><a href="#第一次实验问题汇总" class="headerlink" title="第一次实验问题汇总"></a>第一次实验问题汇总</h1><hr><h2 id="A-命题生成器"><a href="#A-命题生成器" class="headerlink" title="A.命题生成器"></a><font color=0033FF>A.命题生成器</font></h2><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><code>print()</code>函数中<code>+</code>运算符和<code>,</code>分割参数使用不够熟练，导致输出的空格数不符合要求。  </li></ul><h4 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="python">print(<span class="string">'If'</span>+a+<span class="string">','</span>+<span class="string">'then'</span>+b+<span class="string">'.'</span>)<span class="comment">#少了空格，所有输出会全部贴在一起</span></code></pre><pre><code class="python">print(<span class="string">'If'</span>,a,<span class="string">','</span>,<span class="string">'then'</span>,b,<span class="string">'.'</span>)<span class="comment">#多了空格，标点符号会跟前面的单词分开</span></code></pre><h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">print(<span class="string">'If'</span>,a+<span class="string">','</span>,<span class="string">'then'</span>,b+<span class="string">'.'</span>)<span class="comment">#在需要空格的时候使用逗号，在不需要空格的时候使用加号</span></code></pre><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="python">print(<span class="string">'If '</span>+a+<span class="string">', then'</span>+b+<span class="string">'.'</span>)<span class="comment">#将空格全部放在字符串里再全部使用加号，直观感受空格位置</span></code></pre><pre><code class="python">print(<span class="string">'If '</span>,a,<span class="string">', then'</span>,b,<span class="string">'.'</span>, sep=<span class="string">''</span>)<span class="comment">#传入sep参数来消除逗号分割对于空格的影响</span></code></pre><pre><code class="python">print(<span class="string">'If %s, then %s.'</span>%(a,b))<span class="comment">#使用格式控制符来非常直观地感受输出格式，是最为推荐的方法</span><span class="comment">#以后在使用print()函数时应首选这种方法</span></code></pre><pre><code class="python">print(<span class="string">'If {}, then {}.'</span>.format(a,b))<span class="comment">#使用.format()方法来非常直观地感受输出格式，同样也是最为推荐的方法</span><span class="comment">#同样也是使用print()函数时的首选方法</span></code></pre><hr><h2 id="B-奖状密码"><a href="#B-奖状密码" class="headerlink" title="B.奖状密码"></a><font color=0033FF>B.奖状密码</font></h2><h3 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>三引号使用不熟练，导致多输出空白符  </li><li>对位运算符不熟练，没有想到<code>&amp;</code>的用法  </li></ul><h4 id="错误示范-1"><a href="#错误示范-1" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="python">print(<span class="string">"""</span><span class="string">--------------------</span><span class="string">--------</span><span class="string">------</span><span class="string">----               -</span><span class="string">--       {}        --</span><span class="string">-               ----</span><span class="string">              ------</span><span class="string">            --------</span><span class="string">--------------------"""</span>.format(grade))<span class="comment">#可能因为有强迫症，令所有行对齐，这样第一行会多出一个换行符</span></code></pre><pre><code class="python">print(<span class="string">"""--------------------</span><span class="string">         --------</span><span class="string">         ------</span><span class="string">         ----               -</span><span class="string">         --       {}        --</span><span class="string">         -               ----</span><span class="string">                       ------</span><span class="string">                     --------</span><span class="string">         --------------------"""</span>.format(grade))<span class="comment">#和上面相似，这种写法在从第二行开始每行开头会多出空格</span></code></pre><h4 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">a = int(input())b = int(input())c = a &amp; b<span class="comment">#注意&amp;运算符可以将十进制数转换为二进制</span><span class="comment">#所以无需手动转换，直接使用十进制数运算即可</span><span class="comment">#注意此时结果c也是十进制</span>grade = chr(c)print(<span class="string">"""--------------------</span><span class="string">--------</span><span class="string">------</span><span class="string">----               -</span><span class="string">--       {}        --</span><span class="string">-               ----</span><span class="string">              ------</span><span class="string">            --------</span><span class="string">--------------------"""</span>.format(grade))</code></pre><pre><code class="python">print(<span class="string">"-"</span>*<span class="number">20</span>)print(<span class="string">"-"</span>*<span class="number">8</span>)print(<span class="string">"-"</span>*<span class="number">6</span>)print(<span class="string">"-"</span>*<span class="number">4</span>+<span class="string">" "</span>*<span class="number">15</span>+<span class="string">"-"</span>)print(<span class="string">"--"</span>+<span class="string">" "</span>*<span class="number">7</span>+grade+<span class="string">" "</span>*<span class="number">8</span>+<span class="string">"--"</span>)print(<span class="string">"-"</span>+<span class="string">" "</span>*<span class="number">15</span>+<span class="string">"-"</span>*<span class="number">4</span>)print(<span class="string">" "</span>*<span class="number">14</span>+<span class="string">"-"</span>*<span class="number">6</span>)print(<span class="string">" "</span>*<span class="number">12</span>+<span class="string">"-"</span>*<span class="number">8</span>)print(<span class="string">"-"</span>*<span class="number">20</span>)<span class="comment">#当然这样写也是可行的，但是代码稍显杂乱</span></code></pre><h4 id="优化解法-1"><a href="#优化解法-1" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="python">print(<span class="string">'--------------------'</span>)print(<span class="string">'--------            '</span>)print(<span class="string">'------              '</span>)print(<span class="string">'----               -'</span>)print(<span class="string">'--       %s        --'</span>%grade)print(<span class="string">'-               ----'</span>)print(<span class="string">'              ------'</span>)print(<span class="string">'            --------'</span>)print(<span class="string">'--------------------'</span>)<span class="comment">#不如使用多个print()，一行一个，这样可以增大代码的美观性</span><span class="comment">#虽说OJ一般不会管行末的空格，但是补全之后不是更好看吗？</span></code></pre><hr><h2 id="C-估算自然常数e"><a href="#C-估算自然常数e" class="headerlink" title="C.估算自然常数e"></a><font color=0033FF>C.估算自然常数e</font></h2><h3 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><strong><font color=FF5E5E>不够仔细！</font></strong></li></ul><h4 id="错误示范-2"><a href="#错误示范-2" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="python">n = int(input())</code></pre><h4 id="正确答案-2"><a href="#正确答案-2" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">n = float(input())<span class="comment">#自行感受一下</span></code></pre><hr><h2 id="D-四元数乘法"><a href="#D-四元数乘法" class="headerlink" title="D.四元数乘法"></a><font color=0033FF>D.四元数乘法</font></h2><h3 id="常见问题-3"><a href="#常见问题-3" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><code>print()</code>函数使用不熟练</li><li><strong><font color=FF5E5E>不够仔细！</font></strong></li></ul><h4 id="错误示范-3"><a href="#错误示范-3" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="python">a,b,c,d=input().split(<span class="string">','</span>)e,f,g,h=input().split(<span class="string">','</span>)<span class="comment">#此时所有变量都是字符串</span></code></pre><pre><code class="python">a,b,c,d=map(int,input().split(<span class="string">','</span>))e,f,g,h=map(int,input().split(<span class="string">','</span>))</code></pre><pre><code class="python">i = a*e - b*f - c*g - d*hj = b*e + a*f + c*h - d*gk = c*e + c*e + d*f - b*hl = d*e + a*h + b*g - c*f</code></pre><h4 id="正确答案-3"><a href="#正确答案-3" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">a,b,c,d=map(float,input().split(<span class="string">','</span>))e,f,g,h=map(float,input().split(<span class="string">','</span>))i = a*e - b*f - c*g - d*hj = b*e + a*f + c*h - d*gk = c*e + a*g + d*f - b*hl = d*e + a*h + b*g - c*f<span class="comment">#自行感受一下</span>print(<span class="string">'%.2f'</span>%i,<span class="string">'%.2f'</span>%j,<span class="string">'%.2f'</span>%k,<span class="string">'%.2f'</span>%l,sep=<span class="string">','</span>)</code></pre><h4 id="优化解法-2"><a href="#优化解法-2" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="python">print(<span class="string">'%.2f,%.2f,%.2f,%.2f'</span>%(i, j, k, l))<span class="comment">#这样的写法是非常清楚的，.format()方法同理</span><span class="comment">#如果可以通过格式控制输出的话，还是格式控制输出更清楚</span><span class="comment">#使用加号和逗号配合sep参数也可以完成，但是会稍显杂乱</span></code></pre><hr><h2 id="E-净化网络环境（选做）"><a href="#E-净化网络环境（选做）" class="headerlink" title="E.净化网络环境（选做）"></a><font color=0033FF>E.净化网络环境（选做）</font></h2><h3 id="常见问题-4"><a href="#常见问题-4" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>选做题也请尝试做啊！助教出题很辛苦的！</li></ul><h4 id="优化解法-3"><a href="#优化解法-3" class="headerlink" title="优化解法"></a><font color=#33EEBB>优化解法</font></h4><pre><code class="python">print(chr(m+<span class="number">65</span>))<span class="comment">#有一部分同学使用了列表或者分支语句来完成0对应A，1对应B这样的操作</span><span class="comment">#实际上将m的值加上'A'的ASCII码的值就可以转化为密文的ASCII码</span></code></pre><pre><code class="python">print(chr(m+ord(<span class="string">'A'</span>)))<span class="comment">#如果记不起来'A'的ASCII码是65的话，使用这种方式也是可以的</span></code></pre><hr><h2 id="F-求平方根（选做）"><a href="#F-求平方根（选做）" class="headerlink" title="F.求平方根（选做）"></a><font color=0033FF>F.求平方根（选做）</font></h2><ul><li>本题大家做的都不错，没有什么常见问题</li><li>个别问题在于进入循环前的准备不够充分，循环内的工作不到位</li></ul><h4 id="错误示范-4"><a href="#错误示范-4" class="headerlink" title="错误示范"></a><font color=#FF5E5E>错误示范</font></h4><pre><code class="python">a = int(input())x = <span class="number">1.0</span>count = <span class="number">0</span><span class="keyword">while</span> abs(x-b)&gt;=<span class="number">0.00001</span>:    x = b    b = (x+a/x)/<span class="number">2</span>    count += <span class="number">1</span><span class="comment">#在进入while循环时b还没有定义，会导致程序报错</span><span class="comment">#虽然说b在第一次循环之后就会工作正常，但是为了顺利进入循环，还是需要给b赋一个初始值</span></code></pre><pre><code class="python">a = int(input())x = <span class="number">1.0</span>b = (x+a/x)/<span class="number">2</span>count = <span class="number">1</span><span class="keyword">while</span> abs(x-b)&gt;=<span class="number">0.00001</span>:    x = b    b = (x+a/x)/<span class="number">2</span><span class="comment">#这个则是忘记了在循环中增加计数用循环变量count的值</span></code></pre><pre><code class="python">a = int(input())x = <span class="number">1.0</span>b = (x+a/x)/<span class="number">2</span>count = <span class="number">1</span><span class="keyword">while</span> abs(x-b)&gt;=<span class="number">0.00001</span>:    b = (x+a/x)/<span class="number">2</span>    count += <span class="number">1</span><span class="comment">#这个则是忘了在循环中更新x的值</span><span class="comment">#因为这一次循环计算出的b在下一次循环中是作为x出现的，所以一定要在合适的地方添上赋值语句</span></code></pre><h4 id="正确答案-4"><a href="#正确答案-4" class="headerlink" title="正确答案"></a><font color=#5ECCFF>正确答案</font></h4><pre><code class="python">a = int(input())x = <span class="number">1.0</span>b = (x+a/x)/<span class="number">2</span>count = <span class="number">1</span><span class="keyword">while</span> abs(x-b)&gt;=<span class="number">0.00001</span>:    x = b    b = (x+a/x)/<span class="number">2</span>    count += <span class="number">1</span>print(<span class="string">'%.3f'</span>%b)print(count)<span class="comment">#count=1的原因是在循环外就已经进行了一次迭代了</span></code></pre><pre><code class="python">a = int(input())d = <span class="number">1</span>x = <span class="number">1.0</span>count = <span class="number">0</span><span class="keyword">while</span> d &gt;= <span class="number">0.00001</span>:    b = (x+a/x)/<span class="number">2</span>    d = abs(x-b)    x = b    count += <span class="number">1</span>print(<span class="string">'%.3f'</span>%b)print(count)<span class="comment">#引入表示前后两次迭代结果的差的变量d也是一种思路</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Summary of BUAA 1977 College Computer Basic Experiment #01&lt;br&gt;北航致真书院19级大学计算机基础第一次上机实验实验总结&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://sutai.fun/tags/python/"/>
    
  </entry>
  
</feed>
